Index: linux-2.6.33/drivers/misc/guf_xml.c
===================================================================
--- /dev/null
+++ linux-2.6.33/drivers/misc/guf_xml.c
@@ -0,0 +1,1325 @@
+/*
+ * guf_xml.c - Driver for Garz & Fricke XML to sysfs conversion
+ *
+ * (C) 2011 by Phillip Durdaut <phillip.durdaut@garz-fricke.com>
+ *
+ * This software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/ezxml.h>
+#include <linux/guf_xml_config.h>
+#include <linux/mtd/mtd.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+
+#include "crc32.h"
+
+#define DRIVER_NAME 			"guf_xml"
+#define ENTRY_TAG				"configurationFile"
+#define DEBUG_MODE				0
+#define MAX_PATH_LENGTH 		500		/* incl. terminating '\0' */
+#define MAX_TAG_LENGTH 			50		/* incl. terminating '\0' */
+#define MAX_GENERATION_LENGTH	10
+#define ATTR_READ				0
+#define ATTR_WRITE				1
+
+struct guf_xml_multiple_tags {
+	char *path;
+	char *identifier;
+};
+
+struct guf_xml_tree_memory {
+	int kobj_name_bytes_cnt;
+	char *kobj_name_begin;
+	char *kobj_name;
+	int attr_group_bytes_cnt;
+	struct attribute_group *attr_group_begin;
+	struct attribute_group *attr_group;
+	int attr_group_attrs_bytes_cnt;
+	struct attribute **attr_group_attrs_begin;
+	struct attribute **attr_group_attrs;
+	int attr_name_bytes_cnt;
+	char *attr_name_begin;
+	char *attr_name;
+	int kattr_bytes_cnt;
+	struct kobj_attribute *kattr_begin;
+	struct kobj_attribute *kattr;
+};
+
+static struct guf_xml_multiple_tags mtag_flash_partition = {
+	.path = "/"ENTRY_TAG"/flash/partition",
+	.identifier = "name",
+};
+
+static struct guf_xml_multiple_tags mtag_variables_setting = {
+	.path = "/"ENTRY_TAG"/variables/setting",
+	.identifier = "key",
+};
+
+static struct guf_xml_multiple_tags mtag_end_of_list = {
+	.path = NULL,
+	.identifier = NULL,
+};
+
+static struct guf_xml_multiple_tags *mtags[] = {
+	&mtag_flash_partition,
+	&mtag_variables_setting,
+	/* another multiple tag goes here */
+	&mtag_end_of_list,
+};
+
+static struct guf_xml_tree_memory tree_memory = {
+	.kobj_name_bytes_cnt = 0,
+	.kobj_name_begin = NULL,
+	.kobj_name = NULL,
+	.attr_group_bytes_cnt = 0,
+	.attr_group_begin = NULL,
+	.attr_group = NULL,
+	.attr_group_attrs_bytes_cnt = 0,
+	.attr_group_attrs_begin = NULL,
+	.attr_group_attrs = NULL,
+	.attr_name_bytes_cnt = 0,
+	.attr_name_begin = NULL,
+	.attr_name = NULL,
+	.kattr_bytes_cnt = 0,
+	.kattr_begin = NULL,
+	.kattr = NULL,
+};
+
+static struct miscdevice guf_xml_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DRIVER_NAME,
+};
+
+static struct mtd_info *mtd_fis_directory;	/* mtd information FIS directory */
+static struct mtd_info *mtd_redundant_fis;	/* mtd information Redundant FIS */
+static struct mtd_info *mtd_active;			/* points on the currently active device */
+static struct mtd_info *mtd_backup;			/* points on the currently backup device */
+static int eb_cnt;							/* number of eraseblocks */
+static int pg_cnt;							/* pages per eraseblock */
+static unsigned char *bbt;					/* bad block table */
+static struct mutex mutex;
+
+/*
+ *  Makes mtd_backup become the new mtd_active.
+ */
+static void guf_xml_switch_mtd_devices(void)
+{
+	struct mtd_info *mtd_tmp;
+
+	/* swap the mtd_active and mtd_backup pointers */
+	mtd_tmp = mtd_active;
+	mtd_active = mtd_backup;
+	mtd_backup = mtd_tmp;
+}
+
+/*
+ *  Checks whether the eraseblock with the given number in the given mtd
+ *  device is a bad block or not.
+ *  Returns 1 when block is bad and 0 when not.
+ */
+static int guf_xml_is_block_bad(struct mtd_info *mtd, int eb_num)
+{
+	loff_t addr = eb_num * mtd->erasesize;
+
+	/* NOR flash does not implement block_isbad */
+	if (mtd->block_isbad == NULL)
+		return 0;
+
+	if (mtd->block_isbad(mtd, addr))
+		return 1;
+	else
+		return 0;
+}
+
+/*
+ *  Scans the given mtd device for bad blocks.
+ *  Returns the number of bad blocks found and a negative number on failure.
+ */
+static int guf_xml_scan_for_bad_eraseblocks(struct mtd_info *mtd)
+{
+	int i;
+	int	bad_block_cnt = 0;
+
+	bbt = vmalloc(eb_cnt * sizeof(unsigned char));
+	if (bbt == NULL) {
+		printk(KERN_ERR "%s: failed to allocate memory (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+	memset(bbt, 0, eb_cnt * sizeof(unsigned char));		/* init memory */
+
+	if (DEBUG_MODE) printk(KERN_INFO "%s: scanning for bad eraseblocks\n", DRIVER_NAME);
+	for (i = 0; i < eb_cnt; ++i) {
+		bbt[i] = guf_xml_is_block_bad(mtd, i);
+		if (bbt[i])
+			bad_block_cnt++;
+		cond_resched();
+	}
+	if (DEBUG_MODE) printk(KERN_INFO "%s: scanned %d eraseblocks, %d are bad\n", DRIVER_NAME, i, bad_block_cnt);
+
+	return bad_block_cnt;
+}
+
+/*
+ *  Erases the eraseblock with the given number in the given mtd device.
+ *  Returns 0 on success and a negative number on failure.
+ */
+static int guf_xml_erase_eraseblock(struct mtd_info *mtd, int eb_num)
+{
+	int err = 0;
+	struct erase_info ei;
+	loff_t addr = eb_num * mtd->erasesize;
+
+	memset(&ei, 0, sizeof(struct erase_info));
+	ei.mtd  = mtd;
+	ei.addr = addr;
+	ei.len  = mtd->erasesize;
+
+	err = mtd->erase(mtd, &ei);
+
+	if (err || ei.state == MTD_ERASE_FAILED) {
+		printk(KERN_ERR "%s: failure on erasing eraseblock %d (%s)\n", DRIVER_NAME, eb_num, __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ *  Writes the given buffer to the eraseblock with the given number in the given mtd device.
+ *  Returns 0 on success and a negative number on failure.
+ */
+static int guf_xml_write_eraseblock(struct mtd_info *mtd, int eb_num, char *buf)
+{
+	size_t written = 0;
+	int err = 0;
+	loff_t addr = eb_num * mtd->erasesize;
+
+	buf += addr;
+	err = mtd->write(mtd, addr, mtd->erasesize, &written, buf);
+	if (err || (written != mtd->erasesize)) {
+		printk(KERN_ERR "%s: failure on writing on mtd device at 0x%llx (%s)\n", DRIVER_NAME, (long long)addr, __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ *  Checks the given mtd device whether there are enough well-being blocks for writing the buffer.
+ *  Returns 0 on success and a negative number on failure.
+ */
+static int guf_xml_write_mtd_device(struct mtd_info *mtd, char *buf, int buf_size)
+{
+	int bad_block_cnt;
+	int available_size;
+	int i;
+	int err = 0;
+
+	bad_block_cnt = guf_xml_scan_for_bad_eraseblocks(mtd);
+	if (bad_block_cnt < 0) {
+		printk(KERN_ERR "%s: failed to scan for bad blocks (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+
+	available_size = (eb_cnt - bad_block_cnt) * mtd->erasesize;
+	if (buf_size > available_size) {
+		printk(KERN_ERR "%s: not enough space in flash (%d bytes free) for the data (%d bytes) (%s)\n", DRIVER_NAME, available_size, buf_size, __func__);
+		return -1;
+	}
+
+	/* erase flash before writing on it */
+	for (i = 0; i < eb_cnt; ++i) {
+		if (bbt[i] == 0) {	/* only erase well-being blocks */
+			err = guf_xml_erase_eraseblock(mtd, i);
+			if (err) {
+				printk(KERN_ERR "%s: failed to erase block %d (%s)\n", DRIVER_NAME, i, __func__);
+				return -1;
+			}
+		}
+	}
+
+	/* write to flash and jump over bad blocks */
+	for (i = 0; i < eb_cnt; ++i) {
+		if (bbt[i] == 0) {	/* only write well-being blocks */
+
+			err = guf_xml_write_eraseblock(mtd, i, buf);
+			if (err) {
+				printk(KERN_ERR "%s: failed to write to block %d (%s)\n", DRIVER_NAME, i, __func__);
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  Reads the eraseblock with the given number in the given mtd device
+ *  and writes the result in the buffer.
+ *  Returns 0 on success and a negative number on failure.
+ */
+static int guf_xml_read_eraseblock(struct mtd_info *mtd, int eb_num, char *buf)
+{
+	size_t read = 0;
+	int err = 0;
+	loff_t addr = eb_num * mtd->erasesize;
+
+	buf += addr;
+	err = mtd->read(mtd, addr, mtd->erasesize, &read, buf);
+	if (err || (read != mtd->erasesize)) {
+		printk(KERN_ERR "%s: failure on reading from mtd device at 0x%llx (%s)\n", DRIVER_NAME, (long long)addr, __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ *  Reads data from the given mtd device into a character string.
+ *  When reading was successful a pointer to the character array is returned, otherwise NULL.
+ *  The returned array has to be freed after using it!
+ */
+static char* guf_xml_read_partition_to_xml(struct mtd_info *mtd)
+{
+	char *buf = NULL;
+	int bad_block_cnt;
+	int i = 0;
+	int err = 0;
+
+	bad_block_cnt = guf_xml_scan_for_bad_eraseblocks(mtd);
+	if (bad_block_cnt < 0) {
+		printk(KERN_ERR "%s: failed to scan for bad blocks (%s)\n", DRIVER_NAME, __func__);
+		return NULL;
+	}
+
+	buf = vmalloc(mtd->size);
+	if (buf == NULL) {
+		printk(KERN_ERR "%s: failed to allocate memory (%s)\n", DRIVER_NAME, __func__);
+		return NULL;
+	}
+	memset(buf, 0, mtd->size);		/* init memory */
+
+	/* read from flash and jump over bad blocks */
+	for (i = 0; i < eb_cnt; ++i) {
+		if (bbt[i] == 0) {	/* only read well-being blocks */
+
+			err = guf_xml_read_eraseblock(mtd, i, buf);
+			if (err) {
+				printk(KERN_ERR "%s: failed to read from block %d (%s)\n", DRIVER_NAME, i, __func__);
+				goto err_free;
+			}
+		}
+	}
+
+	return buf;
+
+err_free:
+	vfree(buf);
+	return NULL;
+}
+
+/*
+ *  Reads the flash generation attribute from the given mtd device.
+ *  Returns the generation or an error code smaller than 0 on failure.
+ */
+static int guf_xml_get_mtd_generation(struct mtd_info *mtd)
+{
+	struct ezxml *xml_root = NULL;
+	struct ezxml *xml_flash = NULL;
+	char* xml_string = NULL;
+	int generation = 0;
+
+	/* read the xml data from the partition */
+	xml_string = guf_xml_read_partition_to_xml(mtd);
+	if (xml_string == NULL) {
+		printk(KERN_ERR "%s: failure on reading xml partition (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+
+	/* parse the xml data */
+	xml_root = ezxml_parse_str(xml_string, strlen(xml_string));
+	if (xml_root == NULL) {
+		printk(KERN_ERR "%s: failure on parsing xml data (%s)\n", DRIVER_NAME, __func__);
+		goto err_free_string;
+	}
+
+	xml_flash = ezxml_child(xml_root, "flash");
+	if (xml_flash == NULL) {
+		printk(KERN_ERR "%s: could not find any information about the flash device in xml data (%s)\n", DRIVER_NAME, __func__);
+		goto err_free_xml;
+	}
+
+	/* get the generation value*/
+	generation = simple_strtol((char *)ezxml_attr(xml_flash, "generation"), NULL, 0);
+	ezxml_free(xml_root);
+
+	return generation;
+
+err_free_xml:
+	ezxml_free(xml_root);
+err_free_string:
+	vfree(xml_string);
+	return -1;
+}
+
+/*
+ *  Reads the flash generation attribute from both mtd devices to determine
+ *  which one is the active one and which is the backup.
+ *  Returns 0 on success or an error code smaller than 0 on failure.
+ */
+static int guf_xml_update_mtd_devices(void)
+{
+	int generation_fis_directory = guf_xml_get_mtd_generation(mtd_fis_directory);
+	int generation_redundant_fis = guf_xml_get_mtd_generation(mtd_redundant_fis);
+
+	if (generation_fis_directory < 0 || generation_redundant_fis < 0) {
+		printk(KERN_ERR "%s: failure on reading mtd device generation (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+
+	/* should not happen */
+	if (generation_fis_directory == generation_redundant_fis) {
+		printk(KERN_ERR "%s: both mtd devices have the same generation value (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+
+	if (generation_fis_directory > generation_redundant_fis) {
+		mtd_active = mtd_fis_directory;
+		mtd_backup = mtd_redundant_fis;
+	}
+	else {
+		mtd_active = mtd_redundant_fis;
+		mtd_backup = mtd_fis_directory;
+	}
+
+	return 0;
+}
+
+/*
+ *  Gets the path to the given tag.
+ *  If the tag is 'rotation' the path will for example look like:
+ *		/ENTRY_TAG/variables/display/rotation
+ *  If the parameter tag is NULL the resulting path will look like:
+ *  	/ENTRY_TAG/variables/display
+ *  Returns a pointer to the path or NULL on failure.
+ *  The returned path has to be freed after using it!
+ */
+static char* guf_xml_get_path_to_tag(struct kobject *youngest_kobj, char *tag)
+{
+	char *path = NULL;
+	struct kobject *kobj = youngest_kobj;
+
+	if (kobj == NULL) {
+		printk(KERN_ERR "%s: invalid kernel object address (%s)\n", DRIVER_NAME, __func__);
+		return NULL;
+	}
+
+	path = vmalloc(MAX_PATH_LENGTH * sizeof(char));
+	if (path == NULL) {
+		printk(KERN_ERR "%s: failed to allocate memory (%s)\n", DRIVER_NAME, __func__);
+		return NULL;
+	}
+	memset(path, 0, MAX_PATH_LENGTH * sizeof(char));		/* init memory */
+
+	if (tag != NULL) {
+		memcpy(path, tag, strlen(tag) * sizeof(char));
+		memmove(path + 1, path, strlen(path) * sizeof(char));
+		*path = '/';
+	}
+
+	while(1) {
+		memmove(path + strlen(kobj->name), path, strlen(path) * sizeof(char));
+		memcpy(path, kobj->name, strlen(kobj->name) * sizeof(char));
+		memmove(path + 1, path, strlen(path) * sizeof(char));
+		*path = '/';
+
+		kobj = kobj->parent;
+		if (strcmp(kobj->name, DRIVER_NAME) == 0 || kobj == NULL)
+			break;
+	}
+
+	if (kobj == NULL) {
+		printk(KERN_ERR "%s: invalid kernel object address (%s)\n", DRIVER_NAME, __func__);
+		goto err_free;
+	}
+
+	return path;
+
+err_free:
+	vfree(path);
+	return NULL;
+}
+
+/*
+ *  Determines whether the given tag is a multiple tag.
+ *  Returns 0 if it is not or the index of the multiple tag in the mtags pointer
+ *  vector plus 1.
+ */
+static ssize_t guf_xml_is_multiple_tag(char *path_to_tag)
+{
+	int i;
+
+	/* run through the mtags vector */
+	for (i = 1; mtags[i-1]->path != NULL; i++) {
+		if (strncmp(mtags[i-1]->path, path_to_tag, strlen(mtags[i-1]->path)) == 0) {
+			return i;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  Counts and returns the number of attributes (key-value-pairs) under the given tag.
+ */
+static int guf_xml_count_attrs(struct ezxml *xml)
+{
+	int cnt = 0;
+	char **attr_name_or_value = NULL;
+
+	for (attr_name_or_value = xml->attr; *attr_name_or_value != NULL; attr_name_or_value++) {
+		cnt++;
+	}
+
+	return (cnt/2);
+}
+
+/*
+ *  Checks if the current tag is a multiple tag.
+ *  If so the name of the kernel object (which equals later one sysfs directory) has to be changed
+ *  because there can not exist files or directorys with the same name.
+ *  In this case the name of the kobject will be <tagname>_<identifier> where
+ *  identifier is specified in guf_xml_multiple_tags on top of this file.
+ *  Returns a pointer to the (un)changed kernel object name or NULL on failure.
+ */
+static int guf_xml_change_kobj_name(struct kobject *kobj, char *kobj_name, char *tag_name,
+	char *attr_name, char *attr_value)
+{
+	char *path = NULL;
+	int mtag_no;
+
+	path = guf_xml_get_path_to_tag(kobj, tag_name);
+	if (path == NULL) {
+		printk(KERN_ERR "%s: could not get path to xml tag (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+
+	mtag_no = guf_xml_is_multiple_tag(path);
+	if (mtag_no) {
+
+		if (strcmp(attr_name, mtags[mtag_no-1]->identifier) == 0) {
+
+			sprintf(kobj_name, "%s_%s", tag_name, attr_value);
+			kobj_name[strlen(tag_name) + 1 + strlen(attr_value)] = '\0';
+		}
+	}
+
+	vfree(path);
+	return 0;
+}
+
+/*
+ *  Walks through the xml data and tries to find the attribute defined by path,
+ *  attr, identifier and key. If it is found it depends on rw whether the attribute
+ *  is read or written with value. On success 0 is returned and in case of rw = ATTR_READ
+ *  presult points on a pointer which points on the value read.
+ *  On failure -1 is returned.
+ */
+static int guf_xml_rw_xml_attr(struct ezxml *xml, int rw, char *path,
+	char *attr, char *value, int multiple_tag, char *identifier, char *key, char **presult)
+{
+	int i, j;
+	char *cur_tag;
+	char *cur_value;
+
+	cur_tag = vmalloc(MAX_TAG_LENGTH * sizeof(char));
+	if (cur_tag == NULL) {
+		printk(KERN_ERR "%s: failed to allocate memory (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+	memset(cur_tag, 0, MAX_TAG_LENGTH * sizeof(char));		/* init memory */
+
+	if (*path == '/')
+		path++;
+	if (strncmp(path, ENTRY_TAG, strlen(ENTRY_TAG)) == 0)
+		path += strlen(ENTRY_TAG);
+	if (*path == '/')
+		path++;
+
+	i = 0;
+	j = 0;
+	while (i <= strlen(path)) {
+
+		if (path[i] == '/' || path[i] == '\0') {
+			cur_tag[j] = '\0';
+			j = 0;
+
+			if (DEBUG_MODE) printk(KERN_INFO "%s: trying to jump to tag '%s'\n", DRIVER_NAME, cur_tag);
+
+			xml = ezxml_child(xml, cur_tag);
+			if (xml == NULL && multiple_tag == 0) {
+				printk(KERN_ERR "%s: tag '%s' was not found (%s)\n", DRIVER_NAME, cur_tag, __func__);
+				goto err_free;
+			}
+
+			if (multiple_tag) {
+				xml = xml->child;
+				break;
+			}
+		}
+		else {
+			cur_tag[j] = path[i];
+			j++;
+		}
+
+		i++;
+	}
+
+	if (multiple_tag) {
+		if (DEBUG_MODE) printk(KERN_INFO "%s: searching for '%s=%s'\n", DRIVER_NAME, identifier, key);
+
+		i = 0;
+		while (1) {
+
+			xml = ezxml_idx(xml, !!i);
+
+			if (xml == NULL) {
+				printk(KERN_ERR "%s: could not find '%s=%s' (%s)\n", DRIVER_NAME, identifier, key, __func__);
+				goto err_free;
+			}
+
+			cur_value = (char *)ezxml_attr(xml, identifier);
+			if (DEBUG_MODE) printk(KERN_INFO "%s: current attribute is '%s'\n", DRIVER_NAME, cur_value);
+
+			if (strcmp(cur_value, key) == 0)
+				break;
+
+			i++;
+		}
+	}
+
+	switch(rw) {
+		case ATTR_READ:
+			*presult = (char *)ezxml_attr(xml, attr);
+			if (!(*presult)) {
+				printk(KERN_ERR "%s: could not find the attribute '%s' in xml data where '%s=%s' (%s)\n", DRIVER_NAME, attr, identifier, key, __func__);
+				goto err_free;
+			}
+		break;
+
+		case ATTR_WRITE:
+			if (ezxml_set_attr(xml, attr, value) == NULL) {
+				printk(KERN_ERR "%s: could not set the attribute '%s' in xml data struct with the id key '%s' (%s)\n", DRIVER_NAME, attr, key, __func__);
+				goto err_free;
+			}
+		break;
+	}
+
+	vfree(cur_tag);
+	return 0;
+
+err_free:
+	vfree(cur_tag);
+	return -1;
+}
+
+/*
+ *  Calls guf_xml_read_partition_to_xml for reading and parsing xml data and
+ *  passes every received parameter to guf_xml_get_attr_from_xml_data.
+ *  Returns the result of guf_xml_get_attr_from_xml_data or NULL on failure.
+ *  The returned string in *ppresult has to be freed after using it!
+ */
+static int guf_xml_get_attr(char *path, char *attr, int multiple_tag, char *identifier, char *key, char **ppresult)
+{
+	struct ezxml *xml_root = NULL;
+	char* xml_string = NULL;
+	char* pattr;
+	int ret;
+
+	/* read the xml data from the partition */
+	xml_string = guf_xml_read_partition_to_xml(mtd_active);
+	if (xml_string == NULL) {
+		printk(KERN_ERR "%s: failure on reading xml partition (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+
+	/* parse the xml data */
+	xml_root = ezxml_parse_str(xml_string, strlen(xml_string));
+	if (xml_root == NULL) {
+		printk(KERN_ERR "%s: failure on parsing xml data (%s)\n", DRIVER_NAME, __func__);
+		goto err_free_string;
+	}
+
+	ret = guf_xml_rw_xml_attr(xml_root, ATTR_READ, path, attr, NULL, multiple_tag, identifier, key, &pattr);
+	if (pattr != NULL)
+	{
+		/* we have to copy the attribute value, otherwise it will get lost on freeing xml_string */
+		*ppresult = vmalloc(strlen(pattr) + 1);
+		if (*ppresult == NULL) {
+			printk(KERN_ERR "%s: could not allocate memory (%s)\n", DRIVER_NAME, __func__);
+			ret = -1;
+		}
+		strcpy(*ppresult, pattr);
+	}
+
+	ezxml_free(xml_root);
+	vfree(xml_string);
+
+	return ret;
+
+err_free_string:
+	vfree(xml_string);
+	return -1;
+}
+
+/*
+ *  Calls guf_xml_read_partition_to_xml for reading and parsing xml data and
+ *  passes every received parameter to guf_xml_set_attr_from_xml_data.
+ *  The xml data gets modified accordingly and after calculating the crc32 checksum
+ *  the new buffer is written to the mtd device.
+ *  Returns 0 when finished successfully or -1 on failure.
+ */
+static int guf_xml_set_attr(char *path, char *attr, char *value, int multiple_tag, char *identifier, char *key)
+{
+	char *xml_string = NULL, *new_xml_string = NULL, *buffer = NULL;
+	struct ezxml *xml_root = NULL;
+	struct ezxml *xml_flash = NULL;
+	int err = 0;
+	unsigned int xml_len = 0;
+	unsigned long checksum;
+	int generation;
+	char new_generation[MAX_GENERATION_LENGTH];
+
+	/* read the xml data from the partition */
+	xml_string = guf_xml_read_partition_to_xml(mtd_active);
+	if (xml_string == NULL) {
+		printk(KERN_ERR "%s: failure on reading xml partition (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+
+	/* parse the xml data */
+	xml_root = ezxml_parse_str(xml_string, strlen(xml_string));
+	if (xml_root == NULL) {
+		printk(KERN_ERR "%s: failure on parsing xml data (%s)\n", DRIVER_NAME, __func__);
+		goto err_free_string;
+	}
+
+	err = guf_xml_rw_xml_attr(xml_root, ATTR_WRITE, path, attr, value, multiple_tag, identifier, key, NULL);
+	if (err) {
+		printk(KERN_ERR "%s: failed to set xml attribute (%s)\n", DRIVER_NAME, __func__);
+		goto err_rw_xml_attr;
+	}
+
+	/* get the current generation value*/
+	xml_flash = ezxml_child(xml_root, "flash");
+	if (xml_flash == NULL) {
+		printk(KERN_ERR "%s: could not find any information about the flash device in xml data (%s)\n", DRIVER_NAME, __func__);
+		goto err_rw_xml_attr;
+	}
+	generation = simple_strtol((char *)ezxml_attr(xml_flash, "generation"), NULL, 0);
+
+	/* increase the generation tag by one */
+	sprintf(new_generation, "%d", generation + 1);
+	if (ezxml_set_attr(xml_flash, "generation", new_generation) == NULL) {
+		printk(KERN_ERR "%s: could not set the generation attribute in xml data (%s)\n", DRIVER_NAME, __func__);
+		goto err_rw_xml_attr;
+	}
+
+	new_xml_string = ezxml_toxml(xml_root);	/* new_xml_string has to be freed */
+	if (!new_xml_string) {
+		printk(KERN_ERR "%s: could not write xml data to string (%s)\n", DRIVER_NAME, __func__);
+		goto err_rw_xml_attr;
+	}
+	xml_len = strlen(new_xml_string) + 1;
+
+	/* copy xml string to new, bigger buffer, so that the checksum can be appended */
+	buffer = kmalloc(xml_len + sizeof(unsigned long), GFP_KERNEL);
+	if (!buffer) {
+		printk(KERN_ERR "%s: could not allocate memory for xml string (%s)\n", DRIVER_NAME, __func__);
+		goto err_xmlstr;
+	}
+	memcpy(buffer, new_xml_string, xml_len);
+	checksum = crc32((unsigned char *)new_xml_string, xml_len);
+	memcpy(buffer + xml_len, &checksum, sizeof(unsigned long));
+
+	err = guf_xml_write_mtd_device(mtd_backup, buffer, xml_len + sizeof(unsigned long));
+	if (err) {
+		printk(KERN_ERR "%s: failure on writing on mtd device (%s)\n", DRIVER_NAME, __func__);
+		goto err_flash;
+	}
+
+	/* the just written mtd_backup should now become the new mtd_active */
+	guf_xml_switch_mtd_devices();
+
+	kfree(buffer);
+	kfree(new_xml_string);		/* use kfree as new_xml_string was allocated by ezxml lib with kmalloc */
+	ezxml_free(xml_root);
+	vfree(xml_string);
+	return 0;
+
+err_flash:
+	kfree(buffer);
+err_xmlstr:
+	kfree(new_xml_string);
+err_rw_xml_attr:
+	ezxml_free(xml_root);
+err_free_string:
+	vfree(xml_string);
+	return -1;
+}
+
+/*
+ *  Determines the parameters passing to guf_xml_get_attr and writes the result in the output buffer.
+ *  On success the total number of characters written is returned.
+ *  On failure a negative error code is returned.
+ */
+static ssize_t guf_xml_sysfs_attr_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *path = NULL;
+	char *key = NULL;
+	char *presult = NULL;
+	int err = 0;
+	int mtag_no;
+
+	mutex_lock(&mutex);
+
+	path = guf_xml_get_path_to_tag(kobj, NULL);
+	if (path == NULL) {
+		printk(KERN_ERR "%s: could not get path to xml tag (%s)\n", DRIVER_NAME, __func__);
+		return -EFAULT;
+	}
+
+	mtag_no = guf_xml_is_multiple_tag(path);
+	if (mtag_no) {
+		key = path + strlen(mtags[mtag_no-1]->path) + 1;
+		err = guf_xml_get_attr(mtags[mtag_no-1]->path, (char *)(attr->attr.name), 1, mtags[mtag_no-1]->identifier, key, &presult);
+	}
+	else {
+		err = guf_xml_get_attr(path, (char *)attr->attr.name, 0, NULL, NULL, &presult);
+	}
+
+	if (err || !presult) {
+		printk(KERN_ERR "%s: failed to get sysfs attribute (%s)\n", DRIVER_NAME, __func__);
+		goto err_free;
+	}
+
+	err = sprintf(buf, "%s\n", presult);
+
+	if (presult)
+		vfree(presult);
+	vfree(path);
+	mutex_unlock(&mutex);
+	return err;
+
+err_free:
+	if (presult)
+		vfree(presult);
+	vfree(path);
+	mutex_unlock(&mutex);
+	return -EIO;
+}
+
+/*
+ *  Determines the parameters passing to guf_xml_set_attr.
+ *  On success the count parameter is returned.
+ *  On failure a negative error code is returned.
+ */
+static ssize_t guf_xml_sysfs_attr_store(struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t count)
+{
+	char *path = NULL;
+	char *key = NULL;
+	char *target_buf = (char *)buf;
+	int err = 0;
+	int mtag_no;
+
+	mutex_lock(&mutex);
+
+	path = guf_xml_get_path_to_tag(kobj, NULL);
+	if (path == NULL) {
+		printk(KERN_ERR "%s: could not get path to xml tag (%s)\n", DRIVER_NAME, __func__);
+		return -EFAULT;
+	}
+
+	/* delete the line feed at the end of the input */
+	if (target_buf[strlen(target_buf) - 1] == 10)
+		target_buf[strlen(target_buf) - 1] = '\0';
+
+	mtag_no = guf_xml_is_multiple_tag(path);
+	if (mtag_no) {
+		key = path + strlen(mtags[mtag_no-1]->path) + 1;
+		err = guf_xml_set_attr(mtags[mtag_no-1]->path, (char *)(attr->attr.name), target_buf, 1, mtags[mtag_no-1]->identifier, key);
+	}
+	else {
+		err = guf_xml_set_attr(path, (char *)attr->attr.name, target_buf, 0, NULL, NULL);
+	}
+
+	if (err) {
+		printk(KERN_ERR "%s: failed to set sysfs attribute (%s)\n", DRIVER_NAME, __func__);
+		goto err_free;
+	}
+
+	vfree(path);
+	mutex_unlock(&mutex);
+	return count;
+
+err_free:
+	vfree(path);
+	mutex_unlock(&mutex);
+	return -EIO;
+}
+
+/*
+ *  Walks recursively through the xml data tree and calculates the amount of
+ *  memory needed for creating the sysfs tree.
+ *  Returns 0 when finished successfully or an error code smaller than 0 on failure.
+ */
+static int guf_xml_calc_space_for_tree(struct ezxml *xml)
+{
+	char **attr_name_or_value = NULL;
+	char *cur_attr_name = NULL;
+	char *cur_attr_value = NULL;
+	int attr_cnt;
+
+	if (xml == NULL)
+		return -1;
+
+	tree_memory.attr_group_bytes_cnt += sizeof(struct attribute_group);
+
+	/* count attributes finding under the current tag */
+	attr_cnt = guf_xml_count_attrs(xml);
+	tree_memory.attr_group_attrs_bytes_cnt += (attr_cnt + 1) * sizeof(struct attribute *);
+
+	/* go through the list of pointers pointing alternately on the attributes name
+	   and the attributes value */
+	for (attr_name_or_value = xml->attr; *attr_name_or_value != NULL; attr_name_or_value++) {
+
+		/* attr_name_or_value points on a pointer pointing on the current attributes name */
+		if (!cur_attr_name && !cur_attr_value) {
+			cur_attr_name = *attr_name_or_value;
+		}
+		/* attr_name_or_value points on a pointer pointing on the current attributes value */
+		else if (cur_attr_name && !cur_attr_value) {
+			cur_attr_value = *attr_name_or_value;
+		}
+
+		if (cur_attr_name && cur_attr_value) {
+
+			tree_memory.attr_name_bytes_cnt += (strlen(cur_attr_name) + 1) * sizeof(char);
+			tree_memory.kattr_bytes_cnt += sizeof(struct kobj_attribute);
+
+			cur_attr_name = NULL;
+			cur_attr_value = NULL;
+		}
+	}
+
+	tree_memory.kobj_name_bytes_cnt += MAX_TAG_LENGTH * sizeof(char);
+
+	/* jump to next child tag if exist */
+	if (xml->child != NULL)
+		if (guf_xml_calc_space_for_tree(xml->child) < 0)
+			return -1;
+
+	/* jump to next sibling tag if exist */
+	if (xml->ordered != NULL)
+		if (guf_xml_calc_space_for_tree(xml->ordered) < 0)
+			return -1;
+
+	return 0;
+}
+
+/*
+ *  Allocates the space in memory for creating the sysfs tree.
+ *  Returns 0 when finished successfully or an error code smaller than 0 on failure.
+ */
+static int guf_xml_allocate_space_for_tree(void)
+{
+	tree_memory.kobj_name_begin = vmalloc(tree_memory.kobj_name_bytes_cnt);
+	tree_memory.attr_group_begin = vmalloc(tree_memory.attr_group_bytes_cnt);
+	tree_memory.attr_group_attrs_begin = vmalloc(tree_memory.attr_group_attrs_bytes_cnt);
+	tree_memory.attr_name_begin = vmalloc(tree_memory.attr_name_bytes_cnt);
+	tree_memory.kattr_begin = vmalloc(tree_memory.kattr_bytes_cnt);
+
+	if (	!tree_memory.kobj_name_begin
+		 || !tree_memory.attr_group_begin
+		 || !tree_memory.attr_group_attrs_begin
+		 || !tree_memory.attr_name_begin
+		 || !tree_memory.kattr_begin			) {
+
+		printk(KERN_ERR "%s: failed to allocate memory (%s)\n", DRIVER_NAME, __func__);
+		goto err_free;
+	}
+
+	/* init memory */
+	memset(tree_memory.kobj_name_begin, 0, tree_memory.kobj_name_bytes_cnt);
+	memset(tree_memory.attr_group_begin, 0, tree_memory.attr_group_bytes_cnt);
+	memset(tree_memory.attr_group_attrs_begin, 0, tree_memory.attr_group_attrs_bytes_cnt);
+	memset(tree_memory.attr_name_begin, 0, tree_memory.attr_name_bytes_cnt);
+	memset(tree_memory.kattr_begin, 0, tree_memory.kattr_bytes_cnt);
+
+	tree_memory.kobj_name = tree_memory.kobj_name_begin;
+	tree_memory.attr_group = tree_memory.attr_group_begin;
+	tree_memory.attr_group_attrs = tree_memory.attr_group_attrs_begin;
+	tree_memory.attr_name = tree_memory.attr_name_begin;
+	tree_memory.kattr = tree_memory.kattr_begin;
+
+	return 0;
+
+err_free:
+	if (tree_memory.kobj_name_begin) 		vfree(tree_memory.kobj_name_begin);
+	if (tree_memory.attr_group_begin) 		vfree(tree_memory.attr_group_begin);
+	if (tree_memory.attr_group_attrs_begin) vfree(tree_memory.attr_group_attrs_begin);
+	if (tree_memory.attr_name_begin) 		vfree(tree_memory.attr_name_begin);
+	if (tree_memory.kattr_begin) 			vfree(tree_memory.kattr_begin);
+	return -1;
+}
+
+/*
+ *  Frees all the memory allocated for building the sysfs tree.
+ */
+static void guf_xml_free_space_of_tree(void)
+{
+	if (tree_memory.kobj_name_begin) 		vfree(tree_memory.kobj_name_begin);
+	if (tree_memory.attr_group_begin) 		vfree(tree_memory.attr_group_begin);
+	if (tree_memory.attr_group_attrs_begin) vfree(tree_memory.attr_group_attrs_begin);
+	if (tree_memory.attr_name_begin) 		vfree(tree_memory.attr_name_begin);
+	if (tree_memory.kattr_begin) 			vfree(tree_memory.kattr_begin);
+	return;
+}
+
+/*
+ *  Walks recursively through the xml data tree and creates the sysfs tree.
+ *  Returns 0 when finished successfully or an error code smaller than 0 on failure.
+ */
+static int guf_xml_walk_xml_tree(struct ezxml *xml, struct kobject *parent_kobj)
+{
+	struct kobject *kobj = NULL;
+	char **attr_name_or_value = NULL;
+	char *cur_attr_name = NULL;
+	char *cur_attr_value = NULL;
+	int attr_cnt;
+
+	if (xml == NULL || parent_kobj == NULL)
+		return -1;
+
+	/* count attributes finding under the current tag */
+	attr_cnt = guf_xml_count_attrs(xml);
+
+	/* save the name of the current tag as the xml data will be freed
+   	   after building the sysfs tree is completed */
+	strcpy(tree_memory.kobj_name, xml->name);
+
+	/* connect the current attribute group with the memory allocated for the single attributes */
+	tree_memory.attr_group->attrs = tree_memory.attr_group_attrs;
+
+	if (DEBUG_MODE) printk(KERN_INFO "\n<%s> (%d)\n", xml->name, attr_cnt);
+
+	/* go through the list of pointers pointing alternately on the attributes name
+	   and the attributes value */
+	for (attr_name_or_value = xml->attr; *attr_name_or_value != NULL; attr_name_or_value++) {
+
+		/* attr_name_or_value points on a pointer pointing on the current attributes name */
+		if (!cur_attr_name && !cur_attr_value) {
+			cur_attr_name = *attr_name_or_value;
+		}
+		/* attr_name_or_value points on a pointer pointing on the current attributes value */
+		else if (cur_attr_name && !cur_attr_value) {
+			cur_attr_value = *attr_name_or_value;
+		}
+
+		if (cur_attr_name && cur_attr_value) {
+
+			if (DEBUG_MODE) printk(KERN_INFO "  %s = %s\n", cur_attr_name, cur_attr_value);
+
+			/* save the name of the current attribute as the xml data will be freed
+			   after building the sysfs tree is completed */
+			strcpy(tree_memory.attr_name, cur_attr_name);
+
+			tree_memory.kattr->attr.name = tree_memory.attr_name;
+			tree_memory.kattr->attr.mode = 0666;
+			tree_memory.kattr->show = guf_xml_sysfs_attr_show;
+			tree_memory.kattr->store = guf_xml_sysfs_attr_store;
+
+			*(tree_memory.attr_group_attrs) = &tree_memory.kattr->attr;
+
+			if (guf_xml_change_kobj_name(parent_kobj, tree_memory.kobj_name, xml->name, tree_memory.attr_name, cur_attr_value) < 0) {
+				printk(KERN_ERR "%s: failed to change the name of the kernel object (%s)\n", DRIVER_NAME, __func__);
+				return -1;
+			}
+
+			/* make the tree memory pointers show on the next fields in allocated memory */
+			tree_memory.kattr++;
+			tree_memory.attr_name += strlen(cur_attr_name) + 1;
+			tree_memory.attr_group_attrs++;
+
+			cur_attr_name = NULL;
+			cur_attr_value = NULL;
+		}
+	}
+
+	/* create kobject and export it to sysfs */
+	kobj = kobject_create_and_add(tree_memory.kobj_name, parent_kobj);
+	if (kobj == NULL) {
+		printk(KERN_ERR "%s: the adress of the kernel object can not be null (%s)\n", DRIVER_NAME, __func__);
+		return -1;
+	}
+
+	/* export attributes to sysfs */
+	if (sysfs_create_group(kobj, tree_memory.attr_group) != 0) {
+		printk(KERN_ERR "%s: failure on creating sysfs attributes (%s)\n", DRIVER_NAME, __func__);
+		goto err_sysfs_create_group;
+	}
+
+	/* make the tree memory pointers show on the next fields in allocated memory */
+	tree_memory.kobj_name += MAX_TAG_LENGTH;
+	tree_memory.attr_group++;
+
+	/* jump to next child tag if exist */
+	if (xml->child != NULL)
+		if (guf_xml_walk_xml_tree(xml->child, kobj) < 0)
+			goto err_cleanup;
+
+	/* jump to next sibling tag if exist */
+	if (xml->ordered != NULL)
+		if (guf_xml_walk_xml_tree(xml->ordered, parent_kobj) < 0)
+			goto err_cleanup;
+
+	return 0;
+
+err_sysfs_create_group:
+	kobject_del(kobj);
+	return -1;
+
+err_cleanup:
+	sysfs_remove_group(kobj, tree_memory.attr_group - 1);
+	kobject_del(kobj);
+	return -1;
+}
+
+/*
+ *  Creates a kernel object called ENTRY_TAG and exports it to
+ *  /sys/class/misc/guf_xml/ENTRY_TAG.
+ *  Gets a pointer on the root element of the xml tree and starts the recursive
+ *  function which reads the xml tree and builds the sysfs tree.
+ */
+static void guf_xml_create_sysfs_tree(void)
+{
+	struct kobject *kobj_root = NULL;
+	struct ezxml *xml_root = NULL;
+	char* xml_string = NULL;
+
+	kobj_root = kobject_create_and_add(ENTRY_TAG, &guf_xml_miscdev.this_device->kobj);
+	if (kobj_root == NULL) {
+		printk(KERN_ERR "%s: failure on creating kernel object and adding it to sysfs (%s)\n", DRIVER_NAME, __func__);
+		return;
+	}
+
+	/* read the xml data from the partition */
+	xml_string = guf_xml_read_partition_to_xml(mtd_active);
+	if (xml_string == NULL) {
+		printk(KERN_ERR "%s: failure on reading xml partition (%s)\n", DRIVER_NAME, __func__);
+		goto err_free_kobj;
+	}
+
+	/* parse the xml data */
+	xml_root = ezxml_parse_str(xml_string, strlen(xml_string));
+	if (xml_root == NULL) {
+		printk(KERN_ERR "%s: failure on parsing xml data (%s)\n", DRIVER_NAME, __func__);
+		goto err_free_string;
+	}
+
+	memset(&tree_memory, 0, sizeof(struct guf_xml_tree_memory));	/* erase all tree memory data */
+	/* in standard configuration file xml_root->child points on <flash> tag */
+	if (guf_xml_calc_space_for_tree(xml_root->child) < 0) {
+		printk(KERN_ERR "%s: failure on calculating the needed memory for the sysfs tree (%s)\n", DRIVER_NAME, __func__);
+		goto err_allocate_tree;
+	}
+
+	if (DEBUG_MODE) {
+		printk(KERN_INFO "%s: kobj_name_bytes_cnt: %d bytes\n", DRIVER_NAME, tree_memory.kobj_name_bytes_cnt);
+		printk(KERN_INFO "%s: attr_group_bytes_cnt: %d bytes\n", DRIVER_NAME, tree_memory.attr_group_bytes_cnt);
+		printk(KERN_INFO "%s: attr_group_attrs_bytes_cnt: %d bytes\n", DRIVER_NAME, tree_memory.attr_group_attrs_bytes_cnt);
+		printk(KERN_INFO "%s: attr_name_bytes_cnt: %d bytes\n", DRIVER_NAME, tree_memory.attr_name_bytes_cnt);
+		printk(KERN_INFO "%s: kattr_bytes_cnt: %d bytes\n", DRIVER_NAME, tree_memory.kattr_bytes_cnt);
+	}
+
+	if (guf_xml_allocate_space_for_tree() < 0) {
+		printk(KERN_ERR "%s: failure on allocating memory for the sysfs tree (%s)\n", DRIVER_NAME, __func__);
+		goto err_allocate_tree;
+	}
+
+	/* in standard configuration file xml_root->child points on <flash> tag */
+	if (guf_xml_walk_xml_tree(xml_root->child, kobj_root) < 0) {
+		printk(KERN_ERR "%s: failure on exporting xml data to sysfs (%s)\n", DRIVER_NAME, __func__);
+		goto err_walk_tree;
+	}
+
+	ezxml_free(xml_root);
+	vfree(xml_string);
+	return;
+
+err_walk_tree:
+	guf_xml_free_space_of_tree();
+err_allocate_tree:
+	ezxml_free(xml_root);
+err_free_string:
+	vfree(xml_string);
+err_free_kobj:
+	kobject_del(kobj_root);
+	return;
+}
+
+/*
+ *  Registers this driver as a misc device, extracts the information about the
+ *  mtd devices from platform data and starts building the sysfs tree.
+ *  Returns 0 on success or an error code smaller than 0 on failure.
+ */
+static int guf_xml_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	uint64_t tmp_fis_directory_size;
+	uint64_t tmp_redundant_fis_size;
+	int fis_directory_eb_cnt;
+	int fis_directory_pg_cnt;
+	int redundant_fis_eb_cnt;
+	int redundant_fis_pg_cnt;
+
+	mutex_init(&mutex);
+
+	/* register driver as a misc device */
+	err = misc_register(&guf_xml_miscdev);
+	if (err) {
+		printk(KERN_ERR "%s: failed to register misc device (%s)\n", DRIVER_NAME, __func__);
+		return err;
+	}
+
+	/* extract information about the mtd devices from platform data
+	   that was filled in board init file */
+	mtd_fis_directory = ((struct guf_xml_device_platform_data *)(pdev->dev.platform_data))->mtd_fis_directory;
+	mtd_redundant_fis = ((struct guf_xml_device_platform_data *)(pdev->dev.platform_data))->mtd_redundant_fis;
+	if (!mtd_fis_directory || !mtd_redundant_fis) {
+		printk(KERN_ERR "%s: failed to get mount information (%s)\n", DRIVER_NAME, __func__);
+		goto err_deregister;
+	}
+
+	/* check as division by zero is not allowed */
+	if (mtd_fis_directory->writesize == 0 || mtd_redundant_fis->writesize == 0) {
+		printk(KERN_ERR "%s: invalid page size (%s)\n", DRIVER_NAME, __func__);
+		goto err_deregister;
+	}
+
+	tmp_fis_directory_size = mtd_fis_directory->size;
+	do_div(tmp_fis_directory_size, mtd_fis_directory->erasesize);
+	fis_directory_eb_cnt = tmp_fis_directory_size;
+	fis_directory_pg_cnt = mtd_fis_directory->erasesize / mtd_fis_directory->writesize;
+
+	tmp_redundant_fis_size = mtd_redundant_fis->size;
+	do_div(tmp_redundant_fis_size, mtd_redundant_fis->erasesize);
+	redundant_fis_eb_cnt = tmp_redundant_fis_size;
+	redundant_fis_pg_cnt = mtd_redundant_fis->erasesize / mtd_redundant_fis->writesize;
+
+	if (DEBUG_MODE) {
+		printk(KERN_INFO "%s: partition name: %s\n", DRIVER_NAME, mtd_fis_directory->name);
+		printk(KERN_INFO "%s: partition size: %llu bytes\n", DRIVER_NAME, (unsigned long long)mtd_fis_directory->size);
+		printk(KERN_INFO "%s: eraseblock size: %u bytes\n", DRIVER_NAME, mtd_fis_directory->erasesize);
+		printk(KERN_INFO "%s: page size: %u bytes\n", DRIVER_NAME, mtd_fis_directory->writesize);
+		printk(KERN_INFO "%s: number of eraseblocks: %u\n", DRIVER_NAME, fis_directory_eb_cnt);
+		printk(KERN_INFO "%s: pages per eraseblock: %u\n", DRIVER_NAME, fis_directory_pg_cnt);
+
+		printk(KERN_INFO "%s: partition name: %s\n", DRIVER_NAME, mtd_redundant_fis->name);
+		printk(KERN_INFO "%s: partition size: %llu bytes\n", DRIVER_NAME, (unsigned long long)mtd_redundant_fis->size);
+		printk(KERN_INFO "%s: eraseblock size: %u bytes\n", DRIVER_NAME, mtd_redundant_fis->erasesize);
+		printk(KERN_INFO "%s: page size: %u bytes\n", DRIVER_NAME, mtd_redundant_fis->writesize);
+		printk(KERN_INFO "%s: number of eraseblocks: %u\n", DRIVER_NAME, redundant_fis_eb_cnt);
+		printk(KERN_INFO "%s: pages per eraseblock: %u\n", DRIVER_NAME, redundant_fis_pg_cnt);
+	}
+
+	/* check equality of the both mtd devices */
+	if (	mtd_fis_directory->size != mtd_redundant_fis->size
+		||	mtd_fis_directory->erasesize != mtd_redundant_fis->erasesize
+		||	mtd_fis_directory->writesize != mtd_redundant_fis->writesize
+		||	fis_directory_eb_cnt != redundant_fis_eb_cnt
+		||	fis_directory_pg_cnt != redundant_fis_pg_cnt) {
+
+		printk(KERN_ERR "%s: mtd devices are not equal (%s)\n", DRIVER_NAME, __func__);
+		goto err_deregister;
+	}
+
+	eb_cnt = fis_directory_eb_cnt;
+	pg_cnt = fis_directory_pg_cnt;
+
+	/* determine which mtd device is more up to date */
+	err = guf_xml_update_mtd_devices();
+	if (err) {
+		printk(KERN_ERR "%s: failed to update mtd devices (%s)\n", DRIVER_NAME, __func__);
+		return err;
+	}
+
+	/* start creating the sysfs tree */
+	guf_xml_create_sysfs_tree();
+
+	printk(KERN_INFO "%s: driver loaded\n", DRIVER_NAME);
+	return 0;
+
+err_deregister:
+	misc_deregister(&guf_xml_miscdev);
+	return -EFAULT;
+}
+
+/*
+ *  Unregisters this driver as a misc device.
+ *  Unbuild sysfs tree?
+ *  Returns 0 on success or an error code smaller than 0 on failure.
+ */
+static int __devexit guf_xml_remove(struct platform_device *pdev)
+{
+	int err = 0;
+
+	mutex_destroy(&mutex);
+
+	err = misc_deregister(&guf_xml_miscdev);
+	if (err) {
+		printk(KERN_ERR "%s: failed to deregister misc device (%s)\n", DRIVER_NAME, __func__);
+		return err;
+	}
+
+	printk(KERN_INFO "%s: driver removed\n", DRIVER_NAME);
+	return 0;
+}
+
+static struct platform_driver guf_xml_driver = {
+	.probe		= guf_xml_probe,
+	.remove		= __devexit_p(guf_xml_remove),
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init guf_xml_init(void)
+{
+	return platform_driver_register(&guf_xml_driver);
+}
+module_init(guf_xml_init);
+
+static void __exit guf_xml_exit(void)
+{
+	platform_driver_unregister(&guf_xml_driver);
+}
+module_exit(guf_xml_exit);
+
+MODULE_DESCRIPTION("Driver for Garz & Fricke XML to sysfs conversion");
+MODULE_AUTHOR("Phillip Durdaut <phillip.durdaut@garz-fricke.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(DRIVER_NAME);
Index: linux-2.6.33/drivers/misc/Kconfig
===================================================================
--- linux-2.6.33.orig/drivers/misc/Kconfig
+++ linux-2.6.33/drivers/misc/Kconfig
@@ -292,6 +292,14 @@ config TI_DAC7512
 	  This driver can also be built as a module. If so, the module
 	  will be calles ti_dac7512.
 
+config GUF_XML
+	bool "Driver for Garz & Fricke XML to sysfs conversion"
+	select LIBEZXML
+	default n
+	---help---
+	 Driver which mirrors the Garz & Fricke XML configuration data from
+	 RedBoot FIS partition to sysfs.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
Index: linux-2.6.33/drivers/misc/Makefile
===================================================================
--- linux-2.6.33.orig/drivers/misc/Makefile
+++ linux-2.6.33/drivers/misc/Makefile
@@ -28,3 +28,6 @@ obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_IWMC3200TOP)      += iwmc3200top/
 obj-y				+= eeprom/
 obj-y				+= cb710/
+obj-$(CONFIG_GUF_XML)	+= guf_xml.o
+obj-$(CONFIG_GUF_XML)	+= crc32.o
+
Index: linux-2.6.33/drivers/misc/crc32.c
===================================================================
--- /dev/null
+++ linux-2.6.33/drivers/misc/crc32.c
@@ -0,0 +1,131 @@
+/*
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "crc32.h"
+
+  /* ============================================================= */
+  /*  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or       */
+  /*  code or tables extracted from it, as desired without restriction.     */
+  /*                                                                        */
+  /*  First, the polynomial itself and its table of feedback terms.  The    */
+  /*  polynomial is                                                         */
+  /*  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0   */
+  /*                                                                        */
+  /*  Note that we take it "backwards" and put the highest-order term in    */
+  /*  the lowest-order bit.  The X^32 term is "implied"; the LSB is the     */
+  /*  X^31 term, etc.  The X^0 term (usually shown as "+1") results in      */
+  /*  the MSB being 1.                                                      */
+  /*                                                                        */
+  /*  Note that the usual hardware shift register implementation, which     */
+  /*  is what we're using (we're merely optimizing it by doing eight-bit    */
+  /*  chunks at a time) shifts bits into the lowest-order term.  In our     */
+  /*  implementation, that means shifting towards the right.  Why do we     */
+  /*  do it this way?  Because the calculated CRC must be transmitted in    */
+  /*  order from highest-order term to lowest-order term.  UARTs transmit   */
+  /*  characters in order from LSB to MSB.  By storing the CRC this way,    */
+  /*  we hand it to the UART in the order low-byte to high-byte; the UART   */
+  /*  sends each low-bit to hight-bit; and the result is transmission bit   */
+  /*  by bit from highest- to lowest-order term without requiring any bit   */
+  /*  shuffling on our part.  Reception works similarly.                    */
+  /*                                                                        */
+  /*  The feedback terms table consists of 256, 32-bit entries.  Notes:     */
+  /*                                                                        */
+  /*      The table can be generated at runtime if desired; code to do so   */
+  /*      is shown later.  It might not be obvious, but the feedback        */
+  /*      terms simply represent the results of eight shift/xor opera-      */
+  /*      tions for all combinations of data and CRC register values.       */
+  /*                                                                        */
+  /*      The values must be right-shifted by eight bits by the "updcrc"    */
+  /*      logic; the shift must be unsigned (bring in zeroes).  On some     */
+  /*      hardware you could probably optimize the shift in assembler by    */
+  /*      using byte-swap instructions.                                     */
+  /*      polynomial $edb88320                                              */
+  /*                                                                        */
+  /*  --------------------------------------------------------------------  */
+
+static unsigned long crc32_tab[] = {
+      0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+      0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+      0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+      0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+      0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+      0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+      0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+      0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+      0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+      0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+      0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+      0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+      0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+      0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+      0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+      0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+      0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+      0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+      0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+      0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+      0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+      0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+      0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+      0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+      0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+      0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+      0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+      0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+      0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+      0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+      0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+      0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+      0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+      0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+      0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+      0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+      0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+      0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+      0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+      0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+      0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+      0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+      0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+      0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+      0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+      0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+      0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+      0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+      0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+      0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+      0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+      0x2d02ef8dL
+   };
+
+/* Return a 32-bit CRC of the contents of the buffer. */
+unsigned long crc32(const unsigned char *s, unsigned int len) {
+	unsigned int i;
+	unsigned long crc32val;
+
+	crc32val = 0;
+	// performs ~35% better with 4x unrolling, ~50% better with 16x unrolling
+	for (i = 0;  i < len-3;  i+=4)
+	{
+		crc32val = crc32_tab[(crc32val ^ s[i]) & 0xff] ^ (crc32val >> 8);
+		crc32val = crc32_tab[(crc32val ^ s[i+1]) & 0xff] ^ (crc32val >> 8);
+		crc32val = crc32_tab[(crc32val ^ s[i+2]) & 0xff] ^ (crc32val >> 8);
+		crc32val = crc32_tab[(crc32val ^ s[i+3]) & 0xff] ^ (crc32val >> 8);
+	}
+	for (i = len & ~0x3;  i < len;  i++)
+		crc32val = crc32_tab[(crc32val ^ s[i]) & 0xff] ^ (crc32val >> 8);
+
+	return crc32val;
+}
Index: linux-2.6.33/drivers/misc/crc32.h
===================================================================
--- /dev/null
+++ linux-2.6.33/drivers/misc/crc32.h
@@ -0,0 +1,23 @@
+/*
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CRC32_H_
+#define CRC32_H_
+
+/* This computes a 32 bit CRC of the data in the buffer, and returns the
+   CRC.  The polynomial used is 0xedb88320. */
+unsigned long crc32(const unsigned char *buf, unsigned int len);
+
+#endif /* CRC32_H_ */
Index: linux-2.6.33/include/linux/guf_xml_config.h
===================================================================
--- linux-2.6.33.orig/include/linux/guf_xml_config.h
+++ linux-2.6.33/include/linux/guf_xml_config.h
@@ -27,6 +27,11 @@
 #include <linux/socket.h>
 #include <linux/types.h>
 
+#define NAME_FIS_DIRECTORY 			"FIS directory"
+#define NAME_REDUNDANT_FIS 			"Redundant FIS"
+#define LENGTH_NAME_FIS_DIRECTORY 	13
+#define LENGTH_NAME_REDUNDANT_FIS 	13
+
 /*
  * Display types:
  *
@@ -57,7 +62,10 @@
 #define ROTATION_270 270
 
 
-
+struct guf_xml_device_platform_data {
+	struct mtd_info *mtd_fis_directory;
+	struct mtd_info *mtd_redundant_fis;
+};
 
 /* general configuration information */
 typedef struct
Index: linux-2.6.33/arch/arm/mach-mx3/devices.c
===================================================================
--- linux-2.6.33.orig/arch/arm/mach-mx3/devices.c
+++ linux-2.6.33/arch/arm/mach-mx3/devices.c
@@ -692,6 +692,11 @@ struct platform_device mxc_flexcan_devic
 };
 #endif
 
+struct platform_device guf_xml_device = {
+	.name   = "guf_xml",
+	.id     = -1,
+};
+
 static int mx3_devices_init(void)
 {
 	if (cpu_is_mx31()) {
Index: linux-2.6.33/arch/arm/mach-mx3/devices.h
===================================================================
--- linux-2.6.33.orig/arch/arm/mach-mx3/devices.h
+++ linux-2.6.33/arch/arm/mach-mx3/devices.h
@@ -31,3 +31,4 @@ extern struct platform_device mxc_sdhc_d
 extern struct platform_device mxc_sdhc_device2;
 extern struct platform_device mxc_flexcan_device0;
 extern struct platform_device mxc_flexcan_device1;
+extern struct platform_device guf_xml_device;
Index: linux-2.6.33/arch/arm/mach-mx2/devices.c
===================================================================
--- linux-2.6.33.orig/arch/arm/mach-mx2/devices.c
+++ linux-2.6.33/arch/arm/mach-mx2/devices.c
@@ -608,6 +608,11 @@ struct platform_device imx_ssi_device1 =
 	.resource = imx_ssi_resources1,
 };
 
+struct platform_device guf_xml_device = {
+	.name   = "guf_xml",
+	.id     = -1,
+};
+
 /* GPIO port description */
 static struct mxc_gpio_port imx_gpio_ports[] = {
 	{
Index: linux-2.6.33/arch/arm/mach-mx2/devices.h
===================================================================
--- linux-2.6.33.orig/arch/arm/mach-mx2/devices.h
+++ linux-2.6.33/arch/arm/mach-mx2/devices.h
@@ -28,3 +28,4 @@ extern struct platform_device mxc_spi_de
 extern struct platform_device mxc_spi_device2;
 extern struct platform_device imx_ssi_device0;
 extern struct platform_device imx_ssi_device1;
+extern struct platform_device guf_xml_device;
