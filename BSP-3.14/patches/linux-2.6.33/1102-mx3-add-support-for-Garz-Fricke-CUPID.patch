Index: linux-2.6.33/arch/arm/mach-mx3/Kconfig
===================================================================
--- linux-2.6.33.orig/arch/arm/mach-mx3/Kconfig
+++ linux-2.6.33/arch/arm/mach-mx3/Kconfig
@@ -112,4 +112,12 @@ config MACH_KZM_ARM11_01
 	  Include support for KZM-ARM11-01. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_GUF_CUPID
+	bool "Support Garz & Fricke Cupid platform"
+	select ARCH_MX35
+	select SMSC_PHY
+	help
+	  Include support for Cupid platform. This includes specific
+	  configurations for the board and its peripherals.
+
 endif
Index: linux-2.6.33/arch/arm/mach-mx3/Makefile
===================================================================
--- linux-2.6.33.orig/arch/arm/mach-mx3/Makefile
+++ linux-2.6.33/arch/arm/mach-mx3/Makefile
@@ -24,3 +24,4 @@ obj-$(CONFIG_MACH_PCM043)	+= mach-pcm043
 obj-$(CONFIG_MACH_ARMADILLO5X0) += mach-armadillo5x0.o
 obj-$(CONFIG_MACH_MX35_3DS)	+= mach-mx35pdk.o
 obj-$(CONFIG_MACH_KZM_ARM11_01)	+= mach-kzm_arm11_01.o
+obj-$(CONFIG_MACH_GUF_CUPID)	+= mach-guf_cupid.o
Index: linux-2.6.33/arch/arm/mach-mx3/mach-guf_cupid.c
===================================================================
--- /dev/null
+++ linux-2.6.33/arch/arm/mach-mx3/mach-guf_cupid.c
@@ -0,0 +1,1132 @@
+/*
+ * Copyright 2010 Garz & Fricke GmbH All Rights Reserved.
+ *
+ * Author: Carsten Behling <carsten.behling@garz-fricke.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301 USA
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/irq.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/ulpi.h>
+#include <linux/fsl_devices.h>
+#include <linux/pwm_backlight.h>
+#include <linux/mtd/mtd.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ucb1400.h>
+#include <video/platform_lcd.h>
+#include <sound/soc.h>
+
+#include <asm/setup.h>
+#include <asm/mach/arch.h>
+#include <asm/mach-types.h>
+#include <asm/mach/time.h>
+
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/iomux-mx35.h>
+#include <mach/audmux.h>
+#include <mach/i2c.h>
+#include <mach/gfeeprom.h>
+#include <mach/imx-uart.h>
+#include <mach/mxc_nand.h>
+#include <mach/spi.h>
+#include <mach/ssi.h>
+#include <mach/mxc_ehci.h>
+#include <mach/ulpi.h>
+#include <mach/ipu.h>
+#include <mach/mx3fb.h>
+#include <mach/mxc_ehci.h>
+#include <mach/esdhc.h>
+
+#include <linux/ezxml.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/can/platform/flexcan.h>
+#include <linux/guf_xml_config.h>
+#include <linux/input/pinnacle_ts.h>
+#include <linux/guf_board_common.h>
+
+#include "devices.h"
+
+#define MINIMUM_REDBOOT_VERSION "1.16r2757"
+
+static guf_xml_data_private_t config;
+extern struct snd_soc_dai imx_ssi_pcm_dai[2];
+
+
+/******************************************************************************/
+/* GPIO DEFINES                                                               */
+/******************************************************************************/
+
+/* two pins are controlling the PWR signals to the USB phys */
+#define USBH_PWR	(2 * 32 + 3)
+#define USBOTG_PWR	(2 * 32 + 14)
+
+/* one pin is controlling the display */
+#define LCD_ENA		(2 * 32 + 24)
+
+/* Audio pins */
+#define AC97_GPIO_TXFS	(1 * 32 + 31)
+#define AC97_GPIO_TXD	(1 * 32 + 28)
+#define AC97_GPIO_RESET	(1 * 32 + 27)
+#define AC97_GPIO_INT	(1 * 32 + 29)
+#define SPEAKER_ON	(2 * 32 + 26)
+
+/* LEDs */
+#define LED1_GPIO	(0 * 32 + 14)
+
+/* Flexcan / RS485 */
+#define CAN_RS485_PWR_EN (2 * 32 + 25)
+#define RS485_TX_EN (1*32 + 22)
+
+/* External touch interrupt lines */
+#define TOUCH_INT		(2 * 32 + 29)
+#define TOUCH_INT2		(0 * 32 + 8)
+/* External touch reset lines */
+#define TOUCH_RESET		(2 * 32 + 28)
+#define TOUCH_RESET2	(0 * 32 + 7)
+/* External touch I2C lines */
+#define TOUCH_SCL		(0 * 32 + 12)
+#define TOUCH_SDA		(0 * 32 + 13)
+
+/* GPIOs on digital I/O connector (X14) */
+#define DIG_IN1 (0 * 32 + 0)
+#define DIG_IN2 (0 * 32 + 1)
+#define DIG_OUT1 (0 * 32 + 4)
+#define DIG_OUT2 (0 * 32 + 5)
+
+/* GPIOs on keypad connector (X21) */
+#define KP_ROW0 (1 * 32 + 0)		// Pin 3
+#define KP_COL0 (1 * 32 + 12)		// Pin 4
+#define KP_ROW1 (1 * 32 + 1)		// Pin 5
+#define KP_COL1 (1 * 32 + 13)		// Pin 6
+#define KP_ROW2 (1 * 32 + 2)		// Pin 7
+#define KP_COL2 (1 * 32 + 14)		// Pin 8
+#define KP_ROW3 (1 * 32 + 3)		// Pin 9
+#define KP_COL3 (1 * 32 + 15)		// Pin 10
+#define KP_ROW4 (1 * 32 + 6)		// Pin 11
+#define KP_COL4 (1 * 32 + 17)		// Pin 12
+#define KP_ROW5_DMA (1 * 32 + 11)	// Pin 13
+#define KP_COL5_SS1 (1 * 32 + 8)	// Pin 14
+#define KP_ROW6_MISO (1 * 32 + 10)	// Pin 15
+#define KP_COL6_MOSI (1 * 32 + 9)	// Pin 16
+#define KP_ROW7_SLK (1 * 32 + 16)	// Pin 17
+#define KP_COL7_SS0 (1 * 32 + 7)	// Pin 18
+
+/******************************************************************************/
+/* PIN MULTIPLEXING                                                           */
+/******************************************************************************/
+static struct pad_desc guf_cupid_pads[] = {
+	/* UART1 */
+	MX35_PAD_CTS1__UART1_CTS,
+	MX35_PAD_RTS1__UART1_RTS,
+	MX35_PAD_TXD1__UART1_TXD_MUX,
+	MX35_PAD_RXD1__UART1_RXD_MUX,
+	/* UART2 */
+	MX35_PAD_CTS2__UART2_CTS,
+	MX35_PAD_RTS2__UART2_RTS,
+	MX35_PAD_TXD2__UART2_TXD_MUX,
+	MX35_PAD_RXD2__UART2_RXD_MUX,
+	/* UART3 */
+	MX35_PAD_ATA_DATA11__UART3_TXD_MUX,
+	MX35_PAD_ATA_DATA10__UART3_RXD_MUX,
+	MX35_PAD_ATA_DATA9__GPIO2_22,
+	/* FEC */
+	MX35_PAD_FEC_TX_CLK__FEC_TX_CLK,
+	MX35_PAD_FEC_RX_CLK__FEC_RX_CLK,
+	MX35_PAD_FEC_RX_DV__FEC_RX_DV,
+	MX35_PAD_FEC_COL__FEC_COL,
+	MX35_PAD_FEC_RDATA0__FEC_RDATA_0,
+	MX35_PAD_FEC_TDATA0__FEC_TDATA_0,
+	MX35_PAD_FEC_TX_EN__FEC_TX_EN,
+	MX35_PAD_FEC_MDC__FEC_MDC,
+	MX35_PAD_FEC_MDIO__FEC_MDIO,
+	MX35_PAD_FEC_TX_ERR__FEC_TX_ERR,
+	MX35_PAD_FEC_RX_ERR__FEC_RX_ERR,
+	MX35_PAD_FEC_CRS__FEC_CRS,
+	MX35_PAD_FEC_RDATA1__FEC_RDATA_1,
+	MX35_PAD_FEC_TDATA1__FEC_TDATA_1,
+	MX35_PAD_FEC_RDATA2__FEC_RDATA_2,
+	MX35_PAD_FEC_TDATA2__FEC_TDATA_2,
+	MX35_PAD_FEC_RDATA3__FEC_RDATA_3,
+	MX35_PAD_FEC_TDATA3__FEC_TDATA_3,
+	/* I2C1 */
+	MX35_PAD_I2C1_CLK__I2C1_SCL,
+	MX35_PAD_I2C1_DAT__I2C1_SDA,
+	/* I2C3 */
+	MX35_PAD_TX3_RX2__I2C3_SCL,
+	MX35_PAD_TX2_RX3__I2C3_SDA,
+	/* External Touch */
+	MX35_PAD_LD22__GPIO3_28, 			// TOUCH_RESET
+	MX35_PAD_LD23__GPIO3_29, 			// TOUCH_INT
+	MX35_PAD_SCKT__GPIO1_7, 			// TOUCH_RESET2
+	MX35_PAD_FST__GPIO1_8,  			// TOUCH_INT2
+	/* Display */
+	MX35_PAD_LD0__IPU_DISPB_DAT_0,
+	MX35_PAD_LD1__IPU_DISPB_DAT_1,
+	MX35_PAD_LD2__IPU_DISPB_DAT_2,
+	MX35_PAD_LD3__IPU_DISPB_DAT_3,
+	MX35_PAD_LD4__IPU_DISPB_DAT_4,
+	MX35_PAD_LD5__IPU_DISPB_DAT_5,
+	MX35_PAD_LD6__IPU_DISPB_DAT_6,
+	MX35_PAD_LD7__IPU_DISPB_DAT_7,
+	MX35_PAD_LD8__IPU_DISPB_DAT_8,
+	MX35_PAD_LD9__IPU_DISPB_DAT_9,
+	MX35_PAD_LD10__IPU_DISPB_DAT_10,
+	MX35_PAD_LD11__IPU_DISPB_DAT_11,
+	MX35_PAD_LD12__IPU_DISPB_DAT_12,
+	MX35_PAD_LD13__IPU_DISPB_DAT_13,
+	MX35_PAD_LD14__IPU_DISPB_DAT_14,
+	MX35_PAD_LD15__IPU_DISPB_DAT_15,
+	MX35_PAD_LD16__IPU_DISPB_DAT_16,
+	MX35_PAD_LD17__IPU_DISPB_DAT_17,
+	MX35_PAD_D3_HSYNC__IPU_DISPB_D3_HSYNC,
+	MX35_PAD_D3_FPSHIFT__IPU_DISPB_D3_CLK,
+	MX35_PAD_D3_DRDY__IPU_DISPB_D3_DRDY,
+	MX35_PAD_D3_VSYNC__IPU_DISPB_D3_VSYNC,
+	MX35_PAD_LD18__GPIO3_24,		/* LCD enable */
+	MX35_PAD_CSPI1_SS1__PWM_PWMO,		/* LCD backlight PWM */
+	/* USB Host*/
+	MX35_PAD_MLB_CLK__GPIO3_3,		/* USB Host PWR */
+	MX35_PAD_MLB_DAT__GPIO3_4,		/* USB Host Overcurrent */
+	/* USB OTG */
+	MX35_PAD_USBOTG_PWR__USB_TOP_USBOTG_PWR,
+	MX35_PAD_USBOTG_OC__USB_TOP_USBOTG_OC,
+	/* SSI */
+	MX35_PAD_STXFS4__AUDMUX_AUD4_TXFS,
+	MX35_PAD_STXD4__AUDMUX_AUD4_TXD,
+	MX35_PAD_SRXD4__AUDMUX_AUD4_RXD,
+	MX35_PAD_SCK4__AUDMUX_AUD4_TXC,
+	/* UCB1400 IRQ */
+	MX35_PAD_ATA_INTRQ__GPIO2_29,
+	/* Speaker On */
+	MX35_PAD_LD20__GPIO3_26,
+	/* LEDs */
+	MX35_PAD_TX1__GPIO1_14,
+	/* ESDHC1 */
+	MX35_PAD_SD1_CMD__ESDHC1_CMD,
+	MX35_PAD_SD1_CLK__ESDHC1_CLK,
+	MX35_PAD_SD1_DATA0__ESDHC1_DAT0,
+	MX35_PAD_SD1_DATA1__ESDHC1_DAT1,
+	MX35_PAD_SD1_DATA2__ESDHC1_DAT2,
+	MX35_PAD_SD1_DATA3__ESDHC1_DAT3,
+	/* Flexcan1 */
+	MX35_PAD_SD2_DATA3__CAN1_TXCAN,
+	MX35_PAD_SD2_DATA2__CAN1_RXCAN,
+	/* Flexcan2 */
+	MX35_PAD_TX5_RX0__CAN2_TXCAN,
+	MX35_PAD_TX4_RX1__CAN2_RXCAN,
+	/* CAN/RS485_PWR_EN */
+	MX35_PAD_LD19__GPIO3_25,
+	/* GPIOs Digital I/O*/
+	MX35_PAD_STXD5__GPIO1_0,
+	MX35_PAD_SRXD5__GPIO1_1,
+	MX35_PAD_SCKR__GPIO1_4,
+	MX35_PAD_FSR__GPIO1_5,
+	/* GPIOs Keypad */
+	MX35_PAD_SD2_CMD__GPIO2_0,
+	MX35_PAD_SD2_CLK__GPIO2_1,
+	MX35_PAD_SD2_DATA0__GPIO2_2,
+	MX35_PAD_SD2_DATA1__GPIO2_3,
+	MX35_PAD_ATA_CS0__GPIO2_6,
+	MX35_PAD_ATA_CS1__GPIO2_7,
+	MX35_PAD_ATA_DIOR__GPIO2_8,
+	MX35_PAD_ATA_DIOW__GPIO2_9,
+	MX35_PAD_ATA_DMACK__GPIO2_10,
+	MX35_PAD_ATA_RESET_B__GPIO2_11,
+	MX35_PAD_ATA_IORDY__GPIO2_12,
+	MX35_PAD_ATA_DATA0__GPIO2_13,
+	MX35_PAD_ATA_DATA1__GPIO2_14,
+	MX35_PAD_ATA_DATA2__GPIO2_15,
+	MX35_PAD_ATA_DATA3__GPIO2_16,
+	MX35_PAD_ATA_DATA4__GPIO2_17,
+};
+
+
+/******************************************************************************/
+/* LED                                                                        */
+/******************************************************************************/
+static struct gpio_led guf_cupid_gpio_leds[] = {
+	{
+		.name			= "led1",
+		.default_trigger	= "none",
+		.active_low		= 0,
+		.gpio			= LED1_GPIO,
+	},
+};
+
+static struct gpio_led_platform_data guf_cupid_gpio_led_info = {
+	.leds		= guf_cupid_gpio_leds,
+	.num_leds	= ARRAY_SIZE(guf_cupid_gpio_leds),
+};
+
+static struct platform_device guf_cupid_leds_gpio = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &guf_cupid_gpio_led_info,
+	},
+};
+
+/******************************************************************************/
+/* SERIAL                                                                     */
+/******************************************************************************/
+void guf_cupid_rs485_tx_enable (int enable)
+{
+	gpio_set_value(RS485_TX_EN, enable);
+}
+
+static struct imxuart_platform_data guf_cupid_uart_pdata = {
+	.flags = IMXUART_HAVE_RTSCTS,
+};
+
+static struct imxuart_platform_data guf_cupid_rs485_pdata = {
+	.flags = IMXUART_HAVE_RTSCTS | IMXUART_RS485,
+	.rs485_tx_enable = guf_cupid_rs485_tx_enable,
+};
+
+/******************************************************************************/
+/* LCD POWER                                                                  */
+/******************************************************************************/
+static void guf_cupid_lcd_power_control(struct plat_lcd_data *pd, unsigned int power)
+{
+	if (power != 0)
+		gpio_set_value(LCD_ENA, 1);	/* on */
+	else
+		gpio_set_value(LCD_ENA, 0);	/* off */
+}
+
+static struct plat_lcd_data guf_cupid_lcd_power_info = {
+	.set_power = guf_cupid_lcd_power_control,
+	.match_fb = NULL,	/* FIXME */
+};
+
+static struct platform_device guf_cupid_lcd_power = {
+	.name	= "platform-lcd",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &guf_cupid_lcd_power_info,
+	},
+};
+
+/******************************************************************************/
+/* BACKLIGHT                                                                  */
+/******************************************************************************/
+static struct platform_pwm_backlight_data guf_cupid_backlight_info = {
+	.pwm_id = 0,
+	.max_brightness = 255,
+	.dft_brightness = 255,
+	.pwm_period_ns = 4000000,
+	.lut = 0,
+};
+
+static struct platform_device guf_cupid_backlight_power = {
+	.name	= "pwm-backlight",
+	.id	= -1,
+	.dev	= {
+		.parent = &mxc_pwm_device.dev,
+		.platform_data	= &guf_cupid_backlight_info,
+	},
+};
+
+static void guf_cupid_setup_backlight_from_guf_xml(void)
+{
+	/* default brightness */
+	guf_cupid_backlight_info.dft_brightness = config.backlight.level_ac;
+	/* configure backlight */
+	guf_cupid_backlight_info.lut = config.backlight.lut; // set look-up table
+	guf_cupid_backlight_info.dft_brightness = config.backlight.level_ac; // set level
+}
+
+/******************************************************************************/
+/* VIDEO                                                                      */
+/******************************************************************************/
+static struct fb_videomode guf_cupid_fb_mode;
+
+static struct ipu_platform_data guf_cupid_ipu_pdata = {
+	.irq_base = MXC_IPU_IRQ_START,
+};
+
+static struct mx3fb_platform_data guf_cupid_mx3fb_pdata = {
+	.dma_dev	= &mx3_ipu.dev,
+	.mode		= &guf_cupid_fb_mode,
+	.num_modes	= 1,
+	.backlight_dev = &guf_cupid_backlight_power.dev,
+	.lcd_dev = &guf_cupid_lcd_power.dev,
+};
+
+static uint32_t fixed_screen_address;
+static uint32_t fixed_screen_size;
+
+static int __init guf_cupid_fixed_screen(char *options)
+{
+	int display_enabled;
+
+	if (sscanf(options, "%d,%x,%x", &display_enabled, &fixed_screen_address, &fixed_screen_size) != 3) {
+		pr_err("CUPID platform: wrong vidmem parameter syntax. Ignoring.\n");
+		fixed_screen_address = 0U;	/* to be sure */
+		return 0;
+	}
+	/* nothing shown yet? e.g. no splash screen */
+	if (display_enabled == 0)
+		/* do not use any hard coded framebuffer address in this case */
+		fixed_screen_address = 0U;
+	else
+		pr_info("CUPID platform: Using fixed framebuffer memory at %x\n",
+			fixed_screen_address);
+
+	return 0;
+}
+__setup("vidmem=", guf_cupid_fixed_screen);
+
+static void guf_cupid_setup_fb_videomode_from_guf_xml(void)
+{
+	guf_cupid_mx3fb_pdata.name = config.display.name;
+	guf_cupid_mx3fb_pdata.bpp = config.format.depth;
+	guf_cupid_fb_mode.xres = config.display.xres;
+	guf_cupid_fb_mode.yres = config.display.yres;
+	if (config.display.pix_clk == 0) {
+		guf_cupid_fb_mode.pixclock = (config.display.xres + config.hsync.start_width \
+				+ config.hsync.width + config.hsync.end_width) \
+				* (config.display.yres + config.vsync.start_width + config.vsync.width \
+				+ config.vsync.end_width) * config.display.refresh / 1000;
+	} else {
+		guf_cupid_fb_mode.pixclock = config.display.pix_clk / 1000;
+	}
+	guf_cupid_fb_mode.hsync_len = config.hsync.width;
+	guf_cupid_fb_mode.vsync_len = config.vsync.width;
+	guf_cupid_fb_mode.left_margin = config.hsync.start_width;
+	guf_cupid_fb_mode.right_margin = config.hsync.end_width;
+	guf_cupid_fb_mode.upper_margin = config.vsync.start_width;
+	guf_cupid_fb_mode.lower_margin = config.vsync.end_width;
+	guf_cupid_fb_mode.refresh = config.display.refresh;
+
+	/* change the interpratation of "polarity" and "select_enable" dependent
+	   on "original_dc" */
+	if (config.display.original_dc != NULL)
+	{
+		if (!strcmp(config.display.original_dc, "CLCDC")) {
+			/* IPU compared to CLCDC uses inverted clock.select_enable and clock.polarity */
+			config.clock.select_enable = (config.clock.select_enable == 0);
+			config.clock.polarity = (config.clock.polarity == 0);
+		}
+	}
+	else
+	{
+		printk("Your display settings are outdated, please update. System halted.\n");
+		while(1);
+	}
+	guf_cupid_fb_mode.sync =  (config.clock.idle_enable ? FB_SYNC_CLK_IDLE_EN: 0) |
+		(config.data.oe_polarity ? FB_SYNC_OE_ACT_HIGH : 0) |
+		(config.clock.polarity ? FB_SYNC_CLK_INVERT : 0) |
+		(config.clock.select_enable ? FB_SYNC_CLK_SEL_EN : 0) |
+		(config.hsync.polarity ? 0: FB_SYNC_HOR_HIGH_ACT ) |
+		(config.vsync.polarity ? FB_SYNC_VERT_HIGH_ACT : 0) |
+		(config.data.polarity ? FB_SYNC_DATA_INVERT : 0);
+	guf_cupid_fb_mode.vmode = FB_VMODE_NONINTERLACED;
+	guf_cupid_fb_mode.flag = 0;
+
+	guf_cupid_mx3fb_pdata.dma_dev = &mx3_ipu.dev;
+	guf_cupid_mx3fb_pdata.num_modes = 1;
+
+	/* If the bootloader provides a framebuffer, we will continue to use it */
+	if (fixed_screen_address != 0U) {
+		request_mem_region(fixed_screen_address,
+					fixed_screen_size, "mx3_sdc_fb");
+		guf_cupid_mx3fb_pdata.fixed_screen_cpu = ioremap(fixed_screen_address, fixed_screen_size);
+		guf_cupid_mx3fb_pdata.fixed_screen_dma = fixed_screen_address;
+	}
+
+	/* Set up the display power sequence */
+	guf_cupid_mx3fb_pdata.poweron_to_signalon = config.powerseq.poweron_to_signalon;
+	guf_cupid_mx3fb_pdata.poweron_to_backlighton = config.powerseq.poweron_to_backlighton;
+	guf_cupid_mx3fb_pdata.backlightoff_before_poweroff = config.powerseq.backlightoff_before_poweroff;
+	guf_cupid_mx3fb_pdata.signaloff_before_poweroff = config.powerseq.signaloff_before_poweroff;
+	guf_cupid_mx3fb_pdata.poweroff_to_poweron = config.powerseq.poweroff_to_poweron;
+
+	/* Register IPU and framebuffer device */
+	mxc_register_device(&mx3_ipu, &guf_cupid_ipu_pdata);
+	mxc_register_device(&mx3_fb, &guf_cupid_mx3fb_pdata);
+
+#ifdef CONFIG_FRAMEBUFFER_CONSOLE
+	/* Adjust frambuffer console rotation */
+	switch (config.rotation.angle)
+	{
+		default:
+		case ROTATION_0:
+			fbcon_change_rotation(2);
+		case ROTATION_90:
+			fbcon_change_rotation(3);
+		case ROTATION_180:
+			fbcon_change_rotation(0);
+		case ROTATION_270:
+			fbcon_change_rotation(1);
+	}
+#endif
+}
+
+/******************************************************************************/
+/* I2C / EEPROM / RTC                                                         */
+/******************************************************************************/
+static struct imxi2c_platform_data guf_cupid_i2c_1_pdata = {
+	.bitrate = 100000,
+};
+
+static struct guf_eeprom_memory_accessor gl_eeprom_acc;
+static void guf_cupid_eeprom_setup(struct memory_accessor *mem_acc, void *context)
+{
+	gl_eeprom_acc.mem_acc.read = mem_acc->read;
+	gl_eeprom_acc.mem_acc.write = mem_acc->write;
+	gl_eeprom_acc.cont = context;
+}
+
+static struct gfeeprom_platform_data guf_cupid_eeprom_pdata = {
+	.byte_len = (1 << 12),
+	.page_size = 0x20,
+	.flags = AT24_FLAG_ADDR16,
+	.bus_id = 0,
+	.context = &(guf_cupid_eeprom_pdata.bus_id),
+	.setup = guf_cupid_eeprom_setup,
+};
+
+static struct imxi2c_platform_data guf_cupid_i2c_3_pdata = {
+	.bitrate = 100000,
+};
+
+/* NOTE: The LM73 temperature sensor is also connected to
+         this bus. But the driver uses the auto detection
+		 capability of the I2C infrastructure. So, it does
+		 not need to be listed here.
+ */
+static struct i2c_board_info guf_cupid_i2c_1_devices[] = {
+    {
+		I2C_BOARD_INFO("gfeeprom", GF_GLOBAL_PLATFORM_EEPROM_ADDRESS), /* E0=0, E1=0, E2=0 */
+		.platform_data = &guf_cupid_eeprom_pdata,
+	},
+	{
+		I2C_BOARD_INFO("pcf8563", 0x51),
+	}
+};
+
+/******************************************************************************/
+/* TOUCHSCREEN                                                                */
+/******************************************************************************/
+static bool guf_cupid_pinnacle_reset(void)
+{
+	struct pad_desc pad_i2c_sda_gpio = MX35_PAD_TX2_RX3__GPIO1_13;
+	struct pad_desc pad_i2c_scl_gpio = MX35_PAD_TX3_RX2__GPIO1_12;
+	struct pad_desc pad_i2c_sda_i2c = MX35_PAD_TX2_RX3__I2C3_SDA;
+	struct pad_desc pad_i2c_scl_i2c = MX35_PAD_TX3_RX2__I2C3_SCL;
+
+	mxc_iomux_v3_setup_pad(&pad_i2c_sda_gpio);
+	mxc_iomux_v3_setup_pad(&pad_i2c_scl_gpio);
+	// switching off the pinnacle until we open the touch driver.
+	gpio_request(TOUCH_SDA, "i2c_sda");
+	gpio_direction_output(TOUCH_SDA, 0);
+	gpio_request(TOUCH_SCL, "i2c_scl");
+	gpio_direction_output(TOUCH_SCL, 0);
+	gpio_set_value(TOUCH_RESET, 1);
+	msleep(100);
+	gpio_set_value(TOUCH_RESET, 0);
+	msleep(50);
+
+	// done with reset configure the I2C pins for controller usage.
+	gpio_free(TOUCH_SDA);
+	gpio_free(TOUCH_SCL);
+	mxc_iomux_v3_setup_pad(&pad_i2c_sda_i2c);
+	mxc_iomux_v3_setup_pad(&pad_i2c_scl_i2c);
+	return true;
+};
+
+static struct gufpinnacle_platform_data guf_cupid_pinnacle_pdata = {
+	.gufpinnacle_reset = guf_cupid_pinnacle_reset,
+	.irq_flags = IRQF_TRIGGER_LOW,
+	.gpio_int_number = TOUCH_INT
+};
+
+static struct i2c_board_info guf_cupid_touch_pinnacle_info = {
+	I2C_BOARD_INFO("pinnacle_ts", 0x2A),
+	.platform_data = &guf_cupid_pinnacle_pdata,
+	.irq = gpio_to_irq(TOUCH_INT),
+};
+
+static struct ucb1400_pdata guf_cupid_ucb1400_pdata = {
+	.irq = gpio_to_irq(AC97_GPIO_INT),
+};
+
+static void guf_cupid_init_touch_driver(guf_xml_data_touch_t touch)
+{
+	switch(touch) {
+	case TOUCH_PINNACLE:
+		i2c_new_device(i2c_get_adapter(2), &guf_cupid_touch_pinnacle_info);
+		break;
+	case TOUCH_UCB1400:
+		guf_cupid_ucb1400_pdata.enable_ts = true;
+		break;
+	default:
+		printk("Warning: Selected touch not supported on this platform\n");
+	case TOUCH_NONE:
+		printk("Booting kernel without touch support\n");
+	}
+}
+
+/******************************************************************************/
+/* AUDIO                                                                      */
+/******************************************************************************/
+static void guf_cupid_toggle_speaker(int enable)
+{
+	/* Toggle speaker */
+	gpio_direction_output(SPEAKER_ON, 1);
+	gpio_set_value(SPEAKER_ON, enable);
+}
+
+static void guf_cupid_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	struct pad_desc txfs_gpio = MX35_PAD_STXFS4__GPIO2_31;
+	struct pad_desc txfs = MX35_PAD_STXFS4__AUDMUX_AUD4_TXFS;
+	int ret;
+	ret = gpio_request(AC97_GPIO_TXFS, "SSI");
+	if (ret) {
+		printk("failed to get GPIO_TXFS: %d\n", ret);
+		return;
+	}
+
+	mxc_iomux_v3_setup_pad(&txfs_gpio);
+
+	/* warm reset */
+	gpio_direction_output(AC97_GPIO_TXFS, 1);
+	udelay(2);
+	gpio_set_value(AC97_GPIO_TXFS, 0);
+
+	gpio_free(AC97_GPIO_TXFS);
+	mxc_iomux_v3_setup_pad(&txfs);
+	msleep(2);
+}
+
+static void guf_cupid_ac97_cold_reset(struct snd_ac97 *ac97)
+{
+	struct pad_desc txfs_gpio = MX35_PAD_STXFS4__GPIO2_31;
+	struct pad_desc txfs = MX35_PAD_STXFS4__AUDMUX_AUD4_TXFS;
+	struct pad_desc txd_gpio = MX35_PAD_STXD4__GPIO2_28;
+	struct pad_desc txd = MX35_PAD_STXD4__AUDMUX_AUD4_TXD;
+	struct pad_desc reset_gpio = MX35_PAD_ATA_DATA14__GPIO2_27;
+	int ret;
+
+	ret = gpio_request(AC97_GPIO_TXFS, "SSI");
+	if (ret)
+		goto err1;
+
+	ret = gpio_request(AC97_GPIO_TXD, "SSI");
+	if (ret)
+		goto err2;
+
+	ret = gpio_request(AC97_GPIO_RESET, "SSI");
+	if (ret)
+		goto err3;
+
+	ret = gpio_request(SPEAKER_ON, "SSI");
+	if (ret) {
+		goto err4;;
+	}
+
+	mxc_iomux_v3_setup_pad(&txfs_gpio);
+	mxc_iomux_v3_setup_pad(&txd_gpio);
+	mxc_iomux_v3_setup_pad(&reset_gpio);
+
+	gpio_direction_output(AC97_GPIO_TXFS, 1);
+	gpio_set_value(AC97_GPIO_TXFS, 0);
+	gpio_direction_output(AC97_GPIO_TXD, 1);
+	gpio_set_value(AC97_GPIO_TXD, 0);
+	gpio_direction_output(AC97_GPIO_RESET, 1);
+	gpio_set_value(AC97_GPIO_RESET, 1);
+
+	/* cold reset */
+	gpio_set_value(AC97_GPIO_RESET, 0);
+	udelay(10);
+	gpio_set_value(AC97_GPIO_RESET, 1);
+
+	mxc_iomux_v3_setup_pad(&txd);
+	mxc_iomux_v3_setup_pad(&txfs);
+
+	gpio_free(AC97_GPIO_RESET);
+
+	gpio_request(AC97_GPIO_INT, "SSI");
+	gpio_direction_input(AC97_GPIO_INT);
+
+err4:
+	gpio_free(AC97_GPIO_RESET);
+err3:
+	gpio_free(AC97_GPIO_TXD);
+err2:
+	gpio_free(AC97_GPIO_TXFS);
+err1:
+	if (ret)
+		printk("%s failed with %d\n", __func__, ret);
+	mdelay(1);
+}
+
+static struct imx_ssi_platform_data guf_cupid_ssi_pdata = {
+	.ac97_reset = guf_cupid_ac97_cold_reset,
+	.ac97_warm_reset = guf_cupid_ac97_warm_reset,
+	.toggle_speaker = guf_cupid_toggle_speaker,
+	.flags = IMX_SSI_USE_AC97,
+};
+
+/******************************************************************************/
+/* USB                                                                        */
+/******************************************************************************/
+static int guf_cupid_usbh1_phy_init(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = gpio_request(USBH_PWR, "USB");
+	if (ret)
+		goto usb_out;
+
+	gpio_direction_output(USBH_PWR, 1);
+	udelay(10);
+	gpio_set_value(USBH_PWR, 0);
+
+usb_out:
+	if (ret)
+		printk(KERN_WARNING "%s failed with %d\n", __func__, ret);
+	return ret;
+}
+
+static struct mxc_usbh_platform_data guf_cupid_usbh1_pdata = {
+	.init = guf_cupid_usbh1_phy_init,
+	.portsc = MXC_EHCI_MODE_SERIAL,
+	.flags = MXC_EHCI_INTERNAL_PHY | MXC_EHCI_IPPUE_DOWN,
+};
+
+static struct fsl_usb2_platform_data guf_cupid_otg_device_pdata = {
+	.operating_mode = FSL_USB2_DR_DEVICE,
+	.phy_mode       = FSL_USB2_PHY_UTMI,
+};
+
+/******************************************************************************/
+/* CAN                                                                        */
+/******************************************************************************/
+static struct flexcan_platform_data guf_cupid_flexcan1_pdata = {
+	 .core_reg = NULL,
+	 .io_reg = NULL,
+	 .xcvr_enable = NULL,
+	 .active = NULL,
+	 .inactive = NULL
+};
+
+static struct flexcan_platform_data guf_cupid_flexcan2_pdata = {
+	 .core_reg = NULL,
+	 .io_reg = NULL,
+	 .xcvr_enable = NULL,
+	 .active = NULL,
+	 .inactive = NULL
+};
+
+/******************************************************************************/
+/* ETHERNET                                                                   */
+/******************************************************************************/
+static int guf_cupid_handle_netdev_event (struct notifier_block *block,
+					 unsigned long event,
+					 void *ptr)
+{
+	struct net_device *dev = ptr;
+	int i;
+
+	if(strcmp(dev->name, "eth0"))
+		goto out;
+
+	if(event == NETDEV_REGISTER && is_valid_ether_addr(config.mac_addr.sa_data)) {
+		for(i = 0; i < 6; i++) {
+			dev->dev_addr[i] = config.mac_addr.sa_data[i];
+		}
+		config.mac_addr.sa_family = dev->type;
+		dev_set_mac_address(dev, &config.mac_addr);
+	}
+out:
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block guf_cupid_netdev_event = {
+	.notifier_call = guf_cupid_handle_netdev_event,
+};
+
+/******************************************************************************/
+/* Platform Devices                                                           */
+/******************************************************************************/
+static struct platform_device *platform_devices[] = {
+	&mxc_fec_device,
+};
+
+static struct platform_device *display_devices[] = {
+	&guf_cupid_leds_gpio,
+	&mxc_pwm_device,
+	&guf_cupid_lcd_power,
+	&guf_cupid_backlight_power,
+};
+
+/******************************************************************************/
+/* FLASH                                                                      */
+/******************************************************************************/
+static struct mxc_nand_platform_data guf_cupid_nand_pdata = {
+	.width = 1,
+	.hw_ecc = 1,
+};
+
+static struct guf_xml_device_platform_data guf_xml_device_pdata = {
+	.mtd_fis_directory = NULL,
+	.mtd_redundant_fis = NULL,
+};
+
+static int guf_xml_device_registered = 0;
+
+/*
+ * some devices will be configured at runtime by XML data from NAND
+ * So, we must wait for the NAND to occure
+ */
+static void guf_cupid_flash_add(struct mtd_info *mtd)
+{
+	char *buf = NULL;
+	size_t retlen;
+	int ret = 0;
+	struct ezxml *xml_cfg = NULL;
+
+	/* First, check RedBoot version */
+	if (strcmp(mtd->name, "RedBoot") == 0)
+	{
+		ret = guf_check_redboot_compatibility(MINIMUM_REDBOOT_VERSION);
+		if (ret == -EINVAL)
+			printk("WARNING: Could not determine required RedBoot version\n");
+		else if (ret != 0) {
+			printk("System halted.\n");
+			while(1);
+		}
+	}
+
+	/* Initialize guf_xml driver */
+	if (strncmp(NAME_FIS_DIRECTORY, mtd->name, LENGTH_NAME_FIS_DIRECTORY) == 0) {
+		printk("guf_xml: found partition %s\n", mtd->name);
+		guf_xml_device_pdata.mtd_fis_directory = mtd;
+	}
+
+	if (strncmp(NAME_REDUNDANT_FIS, mtd->name, LENGTH_NAME_REDUNDANT_FIS) == 0) {
+		printk("guf_xml: found partition %s\n", mtd->name);
+		guf_xml_device_pdata.mtd_redundant_fis = mtd;
+	}
+
+	if (guf_xml_device_pdata.mtd_fis_directory && guf_xml_device_pdata.mtd_redundant_fis && !guf_xml_device_registered) {
+		guf_xml_device.dev.platform_data = &guf_xml_device_pdata;
+		platform_device_register(&guf_xml_device);
+		guf_xml_device_registered = 1;
+	}
+
+	/* Read XML configuration */
+	if (strcmp(mtd->name, "Redundant FIS (ACTIVE)") == 0 ||
+	    strcmp(mtd->name, "FIS directory (ACTIVE)") == 0) {
+		buf = vmalloc(mtd->size);
+
+		mtd->read(mtd, 0, mtd->size, &retlen, (void*) buf);
+		if (ret || (retlen != mtd->size)) {
+			printk("Error reading config partition\n");
+			goto error;
+		}
+		xml_cfg = guf_get_config(buf);
+		if (xml_cfg == 0)
+			goto error;
+
+		if (get_machine_configuration(xml_cfg, &config) == 0)
+		{
+			/* Now register a netdev_notifier to set the mac address */
+			if (is_valid_ether_addr(config.mac_addr.sa_data))
+				register_netdevice_notifier(&guf_cupid_netdev_event);
+			/* register the remaining devices */
+			platform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));
+		}
+		else
+			goto error;
+
+		if (get_display_configuration(xml_cfg, &config) == 0)
+		{
+			/* init framebuffer from XML data */
+			guf_cupid_setup_fb_videomode_from_guf_xml();
+			/* init pwm backlight from XML data */
+			guf_cupid_setup_backlight_from_guf_xml();
+			/* Request LCD_ENA */
+			gpio_request(LCD_ENA, "FB"); /* FIXME: Should we do that here ? */
+			/* register all display-related devices (now backlight level is set)*/
+			platform_add_devices(display_devices, ARRAY_SIZE(display_devices));
+		}
+		else
+			printk("Booting kernel without display support\n");
+
+		get_touch_configuration(xml_cfg, &config);
+		guf_cupid_init_touch_driver(config.touch);
+
+		guf_free_config(xml_cfg);
+		vfree(buf);
+	}
+	return;
+
+error:
+	printk("Machine configuration data is missing in flash memory. System halted.\n");
+	while(1);
+}
+
+static void guf_cupid_flash_remove(struct mtd_info *mtd)
+{
+	/* nothing to do here */
+}
+
+static struct mtd_notifier guf_cupid_flash_notifier = {
+	.add = guf_cupid_flash_add,
+	.remove = guf_cupid_flash_remove,
+};
+
+/******************************************************************************/
+/* Digital I/O                                                                */
+/******************************************************************************/
+static uint32_t keypad_enabled;
+
+static int __init guf_cupid_keypad_enabled(char *options)
+{
+	if (sscanf(options, "%d", &keypad_enabled) != 1) {
+		pr_err("CUPID platform: wrong kepad_enabled parameter syntax. Ignoring.\n");
+		keypad_enabled = 0U;	/* to be sure */
+	}
+	return 0;
+}
+
+__setup("keypad_enabled=", guf_cupid_keypad_enabled);
+
+/* These are the pin names that will appear under /sys/class/gpio/ */
+const char* mxc_gpio_names[96] = {
+	[DIG_IN1]		= "dig_in1",
+	[DIG_IN2]		= "dig_in2",
+	[DIG_OUT1]		= "dig_out1",
+	[DIG_OUT2]		= "dig_out2",
+	[KP_ROW0]		= "keypad_pin3",
+	[KP_COL0]		= "keypad_pin4",
+	[KP_ROW1]		= "keypad_pin5",
+	[KP_COL1]		= "keypad_pin6",
+	[KP_ROW2]		= "keypad_pin7",
+	[KP_COL2]		= "keypad_pin8",
+	[KP_ROW3]		= "keypad_pin9",
+	[KP_COL3]		= "keypad_pin10",
+	[KP_ROW4]		= "keypad_pin11",
+	[KP_COL4]		= "keypad_pin12",
+	[KP_ROW5_DMA]	= "keypad_pin13",
+	[KP_COL5_SS1]	= "keypad_pin14",
+	[KP_ROW6_MISO]	= "keypad_pin15",
+	[KP_COL6_MOSI]	= "keypad_pin16",
+	[KP_ROW7_SLK]	= "keypad_pin17",
+	[KP_COL7_SS0]	= "keypad_pin18",
+};
+
+static void guf_cupid_configure_dio(void)
+{
+	/* Request, configure and register GPIOs */
+	/* Digital I/O connector (X14) */
+	gpio_request(DIG_IN1, "GPIO");
+	gpio_request(DIG_IN2, "GPIO");
+	gpio_request(DIG_OUT1, "GPIO");
+	gpio_request(DIG_OUT2, "GPIO");
+
+	gpio_direction_input(DIG_IN1);
+	gpio_direction_input(DIG_IN2);
+	gpio_direction_output(DIG_OUT1, 1);
+	gpio_direction_output(DIG_OUT2, 1);
+
+	gpio_sysfs_set_active_low(DIG_IN1, 1);
+	gpio_sysfs_set_active_low(DIG_IN2, 1);
+	gpio_sysfs_set_active_low(DIG_OUT1, 1);
+	gpio_sysfs_set_active_low(DIG_OUT2, 1);
+
+	/* For the following pins the direction is NOT user
+	   configurable because of the wiring */
+	gpio_export(DIG_IN1, 0);
+	gpio_export(DIG_IN2, 0);
+	gpio_export(DIG_OUT1, 0);
+	gpio_export(DIG_OUT2, 0);
+
+	/* If the keypad is not explicitly enabled use the keypad
+	   connector as digital I/O */
+	if(!keypad_enabled) {
+		/* Keypad connector (X21) */
+		gpio_request(KP_ROW0, "GPIO");
+		gpio_request(KP_COL0, "GPIO");
+		gpio_request(KP_ROW1, "GPIO");
+		gpio_request(KP_COL1, "GPIO");
+		gpio_request(KP_ROW2, "GPIO");
+		gpio_request(KP_COL2, "GPIO");
+		gpio_request(KP_ROW3, "GPIO");
+		gpio_request(KP_COL3, "GPIO");
+		gpio_request(KP_ROW4, "GPIO");
+		gpio_request(KP_COL4, "GPIO");
+		gpio_request(KP_ROW5_DMA, "GPIO");
+		gpio_request(KP_COL5_SS1, "GPIO");
+		gpio_request(KP_ROW6_MISO, "GPIO");
+		gpio_request(KP_COL6_MOSI, "GPIO");
+		gpio_request(KP_ROW7_SLK, "GPIO");
+		gpio_request(KP_COL7_SS0, "GPIO");
+
+		gpio_direction_input(KP_ROW0);
+		gpio_direction_input(KP_COL0);
+		gpio_direction_input(KP_ROW1);
+		gpio_direction_input(KP_COL1);
+		gpio_direction_input(KP_ROW2);
+		gpio_direction_input(KP_COL2);
+		gpio_direction_input(KP_ROW3);
+		gpio_direction_input(KP_COL3);
+		gpio_direction_input(KP_ROW4);
+		gpio_direction_input(KP_COL4);
+		gpio_direction_input(KP_ROW5_DMA);
+		gpio_direction_input(KP_COL5_SS1);
+		gpio_direction_input(KP_ROW6_MISO);
+		gpio_direction_input(KP_COL6_MOSI);
+		gpio_direction_input(KP_ROW7_SLK);
+		gpio_direction_input(KP_COL7_SS0);
+
+		gpio_sysfs_set_active_low(KP_ROW0, 0);
+		gpio_sysfs_set_active_low(KP_COL0, 0);
+		gpio_sysfs_set_active_low(KP_ROW1, 0);
+		gpio_sysfs_set_active_low(KP_COL1, 0);
+		gpio_sysfs_set_active_low(KP_ROW2, 0);
+		gpio_sysfs_set_active_low(KP_COL2, 0);
+		gpio_sysfs_set_active_low(KP_ROW3, 0);
+		gpio_sysfs_set_active_low(KP_COL3, 0);
+		gpio_sysfs_set_active_low(KP_ROW4, 0);
+		gpio_sysfs_set_active_low(KP_COL4, 0);
+		gpio_sysfs_set_active_low(KP_ROW5_DMA, 0);
+		gpio_sysfs_set_active_low(KP_COL5_SS1, 0);
+		gpio_sysfs_set_active_low(KP_ROW6_MISO, 0);
+		gpio_sysfs_set_active_low(KP_COL6_MOSI, 0);
+		gpio_sysfs_set_active_low(KP_ROW7_SLK, 0);
+		gpio_sysfs_set_active_low(KP_COL7_SS0, 0);
+
+		/* For the following pins the direction is user
+		   configurable */
+		gpio_export(KP_ROW0, 1);
+		gpio_export(KP_COL0, 1);
+		gpio_export(KP_ROW1, 1);
+		gpio_export(KP_COL1, 1);
+		gpio_export(KP_ROW2, 1);
+		gpio_export(KP_COL2, 1);
+		gpio_export(KP_ROW3, 1);
+		gpio_export(KP_COL3, 1);
+		gpio_export(KP_ROW4, 1);
+		gpio_export(KP_COL4, 1);
+		gpio_export(KP_ROW5_DMA, 1);
+		gpio_export(KP_COL5_SS1, 1);
+		gpio_export(KP_ROW6_MISO, 1);
+		gpio_export(KP_COL6_MOSI, 1);
+		gpio_export(KP_ROW7_SLK, 1);
+		gpio_export(KP_COL7_SS0, 1);
+	}
+}
+
+/******************************************************************************/
+/* Board Initialization                                                       */
+/******************************************************************************/
+static void __init guf_cupid_board_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(guf_cupid_pads, ARRAY_SIZE(guf_cupid_pads));
+
+	/* Pass UCB1400 private data to AC97 driver */
+	imx_ssi_pcm_dai[0].ac97_pdata = &guf_cupid_ucb1400_pdata;
+
+	i2c_register_board_info(0, guf_cupid_i2c_1_devices, ARRAY_SIZE(guf_cupid_i2c_1_devices));
+	mxc_register_device(&mxc_i2c_device0, &guf_cupid_i2c_1_pdata);
+	mxc_register_device(&mxc_i2c_device2, &guf_cupid_i2c_3_pdata);
+
+	mxc_audmux_v2_configure_port(3,
+			MXC_AUDMUX_V2_PTCR_SYN | /* 4wire mode */
+			MXC_AUDMUX_V2_PTCR_TFSEL(0) |
+			MXC_AUDMUX_V2_PTCR_TFSDIR,
+			MXC_AUDMUX_V2_PDCR_RXDSEL(0));
+
+	mxc_audmux_v2_configure_port(0,
+			MXC_AUDMUX_V2_PTCR_SYN | /* 4wire mode */
+			MXC_AUDMUX_V2_PTCR_TCSEL(3) |
+			MXC_AUDMUX_V2_PTCR_TCLKDIR, /* clock is output */
+			MXC_AUDMUX_V2_PDCR_RXDSEL(3));
+
+	/* Configure RS485_TX_EN */
+	gpio_request(RS485_TX_EN, "UART2");
+	gpio_direction_output(RS485_TX_EN, 1);
+
+	mxc_register_device(&mxc_uart_device0, &guf_cupid_uart_pdata);
+	mxc_register_device(&mxc_uart_device1, &guf_cupid_uart_pdata);
+	mxc_register_device(&mxc_uart_device2, &guf_cupid_rs485_pdata);
+	mxc_register_device(&mxc_nand_device, &guf_cupid_nand_pdata);
+	mxc_register_device(&imx_ssi_device0, &guf_cupid_ssi_pdata);
+	mxc_register_device(&mxc_usbh1, &guf_cupid_usbh1_pdata);
+	/* FIXME: OTG only as device function ? */
+	mxc_register_device(&mxc_otg_udc_device, &guf_cupid_otg_device_pdata);
+
+	/* Configure external touch pins */
+	gpio_request(TOUCH_INT, "CTOUCH");
+	gpio_direction_input(TOUCH_INT);
+	gpio_request(TOUCH_RESET, "CTOUCH");
+	gpio_set_value(TOUCH_RESET, 0);
+	gpio_direction_output(TOUCH_RESET, 1);
+
+	/* Request CAN_RS485_PWR_EN */
+	gpio_request(CAN_RS485_PWR_EN, "CAN"); /* FIXME: Should we do that here ? */
+	/* Enable CAN / RS458 PWR */
+	gpio_direction_output(CAN_RS485_PWR_EN, 1);
+	udelay(10);
+	gpio_set_value(CAN_RS485_PWR_EN, 1);
+	mxc_register_device(&mxc_flexcan_device0, &guf_cupid_flexcan1_pdata);
+	mxc_register_device(&mxc_flexcan_device1, &guf_cupid_flexcan2_pdata);
+
+	mxc_register_device(&mxc_sdhc_device0, NULL);
+
+	guf_cupid_configure_dio();
+
+	register_mtd_user(&guf_cupid_flash_notifier);
+}
+
+static void __init guf_cupid_timer_init(void)
+{
+	mx35_clocks_init();
+}
+
+struct sys_timer guf_cupid_timer = {
+	.init	= guf_cupid_timer_init,
+};
+
+MACHINE_START(GUF_CUPID, "Garz & Fricke CUPID")
+	/* Maintainer: Garz & Fricke GmbH */
+	.phys_io	= MX35_AIPS1_BASE_ADDR,
+	.io_pg_offst	= ((MX35_AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+#if defined CONFIG_MOVE_ATAG_LIST_FOR_GUF_REDBOOT
+	.boot_params    = MX3x_PHYS_OFFSET + 0x10000,
+#else
+	.boot_params    = MX3x_PHYS_OFFSET + 0x100,
+#endif
+	.map_io         = mx35_map_io,
+	.init_irq       = mx35_init_irq,
+	.init_machine   = guf_cupid_board_init,
+	.timer          = &guf_cupid_timer,
+MACHINE_END
Index: linux-2.6.33/sound/soc/imx/Kconfig
===================================================================
--- linux-2.6.33.orig/sound/soc/imx/Kconfig
+++ linux-2.6.33/sound/soc/imx/Kconfig
@@ -11,6 +11,16 @@ config SND_IMX_SOC
 config SND_MXC_SOC_SSI
 	tristate
 
+config SND_SOC_CUPID_AC97
+	bool "G+F CUPID sound/touch"
+ 	depends on MACH_GUF_CUPID
+ 	select SND_IMX_SOC
+	select AC97_BUS
+ 	select SND_SOC_AC97_CODEC
+	select SND_SOC_AC97_BUS
+ 	help
+	  Enable AC97 based access to the UCB1400 Sound/GPIO/Touch controller
+	  attached to the SSI0 interface
 config SND_SOC_NESO_AC97
 	bool "G+F NESO sound/touch"
 	depends on MACH_NESO
Index: linux-2.6.33/sound/soc/imx/Makefile
===================================================================
--- linux-2.6.33.orig/sound/soc/imx/Makefile
+++ linux-2.6.33/sound/soc/imx/Makefile
@@ -1,5 +1,5 @@
 # i.MX Platform Support
-snd-soc-imx-objs := imx-ssi.o imx-pcm-fiq.o imx-pcm-dma-mx2.o
+snd-soc-imx-objs := imx-ssi.o imx-pcm-fiq.o
 
 ifdef CONFIG_MACH_MX27
 snd-soc-imx-objs += imx-pcm-dma-mx2.o
@@ -8,5 +8,6 @@ endif
 obj-$(CONFIG_SND_IMX_SOC) += snd-soc-imx.o
 
 # i.MX Machine Support
+obj-$(CONFIG_SND_SOC_CUPID_AC97) += cupid-ac97.o
 
 obj-$(CONFIG_SND_SOC_NESO_AC97) += neso-ac97.o
Index: linux-2.6.33/sound/soc/imx/cupid-ac97.c
===================================================================
--- /dev/null
+++ linux-2.6.33/sound/soc/imx/cupid-ac97.c
@@ -0,0 +1,87 @@
+/*
+ * cupid-ac97.c -- SoC audio for imx_cupid
+ *
+ * Copyright 2010 Carsten Behling <carsten.behling@garz-fricke.de>
+ *
+ * This code is based on code copyrighted by Freescale,
+ * Liam Girdwood, Javier Martin and probably others.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <asm/mach-types.h>
+
+#include "../codecs/ac97.h"
+#include "imx-ssi.h"
+
+static struct snd_soc_card imx_cupid;
+
+static struct snd_soc_ops imx_cupid_hifi_ops = {
+};
+
+static struct snd_soc_dai_link imx_cupid_dai_ac97[] = {
+	{
+		.name        = "HiFi",
+		.stream_name = "AC97 HiFi",
+		.codec_dai   = &ac97_dai,
+		.ops         = &imx_cupid_hifi_ops,
+	},
+};
+
+static struct snd_soc_card imx_cupid = {
+	.name      = "cupid-audio",
+	.platform  = &imx_soc_platform,
+	.dai_link  = imx_cupid_dai_ac97,
+	.num_links = ARRAY_SIZE(imx_cupid_dai_ac97),
+};
+
+static struct snd_soc_device imx_cupid_snd_devdata = {
+	.card      = &imx_cupid,
+	.codec_dev = &soc_codec_dev_ac97,
+};
+
+static struct platform_device *imx_cupid_snd_device;
+
+static int __init imx_cupid_init(void)
+{
+	int ret;
+
+	imx_cupid_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!imx_cupid_snd_device)
+		return -ENOMEM;
+
+	imx_cupid_dai_ac97[0].cpu_dai = &imx_ssi_pcm_dai[0];
+
+	platform_set_drvdata(imx_cupid_snd_device, &imx_cupid_snd_devdata);
+	imx_cupid_snd_devdata.dev = &imx_cupid_snd_device->dev;
+	ret = platform_device_add(imx_cupid_snd_device);
+
+	if (ret) {
+		printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+		platform_device_put(imx_cupid_snd_device);
+	}
+
+	return ret;
+}
+
+static void __exit imx_cupid_exit(void)
+{
+	platform_device_unregister(imx_cupid_snd_device);
+}
+
+late_initcall(imx_cupid_init);
+module_exit(imx_cupid_exit);
+
+MODULE_AUTHOR("Carsten Behling <carsten.behling@garz-fricke.de>");
+MODULE_DESCRIPTION("CUPID ALSA SoC driver");
+MODULE_LICENSE("GPL");
