--- /dev/null
+++ b/arch/arm/mach-at91/board-eval-eco-g45.c
@@ -0,0 +1,128 @@
+/*
+ * board-eval-eco-g45.c
+ *
+ *  Created on: 09.05.2014
+ *      Author: Johannes Lode <linuxer@quantentunnel.de>
+ */
+
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode eco_g45_tft_vga_modes[] = {
+  {
+    .name           = "GP",
+    .refresh  = 60,
+    .xres   = 480,    .yres   = 272,
+    .pixclock = KHZ2PICOS(30000),
+
+    .left_margin  = 1,    .right_margin = 1,
+    .upper_margin = 40,   .lower_margin = 1,
+    .hsync_len  = 45,   .vsync_len  = 1,
+
+    .sync   = 0,
+    .vmode    = FB_VMODE_NONINTERLACED,
+  },
+};
+
+static struct fb_monspecs eco_g45_fb_default_monspecs = {
+  .manufacturer = "GP",
+  .monitor        = "GPM1035A0",
+
+  .modedb   = eco_g45_tft_vga_modes,
+  .modedb_len = ARRAY_SIZE(eco_g45_tft_vga_modes),
+  .hfmin    = 15000,
+  .hfmax    = 17640,
+  .vfmin    = 57,
+  .vfmax    = 67,
+};
+
+#define AT91SAM9G45_DEFAULT_LCDCON2   (ATMEL_LCDC_MEMOR_LITTLE \
+          | ATMEL_LCDC_DISTYPE_TFT \
+          | ATMEL_LCDC_CLKMOD_ALWAYSACTIVE \
+          | ATMEL_LCDC_INVCLK_INVERTED)
+
+/* Driver datas */
+/* If the bootloader has already initialized the controller,
+   this settings are ignored. */
+static struct atmel_lcdfb_pdata __initdata eco_g45_lcdc_data = {
+  .lcdcon_is_backlight  = false,
+  .default_bpp      = 16,
+  .default_dmacon     = ATMEL_LCDC_DMAEN,
+  .default_lcdcon2    = AT91SAM9G45_DEFAULT_LCDCON2,
+  .default_monspecs   = &eco_g45_fb_default_monspecs,
+  .guard_time       = 9,
+  .lcd_wiring_mode    = ATMEL_LCDC_WIRING_RGB,
+//  .signal_on_to_backlight_on = 150,
+//  .backlight_off_to_signal_off = 50,
+};
+
+#else
+static struct atmel_lcdfb_pdata __initdata eco_g45_lcdc_data;
+#endif
+
+/*
+ * Touchscreen
+ */
+static struct at91_tsadcc_data eco_g45_tsadcc_data = {
+  .adc_clock    = 300000,
+  .pendet_debounce  = 0x0d,
+  .ts_sample_hold_time  = 0x0a,
+};
+
+///*
+// * PWM Backlight
+// */
+//  static const u32 pwm_mask = AT91_PWM2;
+//
+///* The eye senses logaritmic, so we use a logaritmic LUT. */
+//static unsigned short gpm1035_bl_lut[256] = {
+//  0x0000, 0x0002, 0x0004, 0x0006, 0x0008, 0x000a, 0x000c, 0x000e,
+//  0x0010, 0x0012, 0x0014, 0x0016, 0x0018, 0x001a, 0x001c, 0x001e,
+//  0x0040, 0x0044, 0x0048, 0x004c, 0x0050, 0x0054, 0x0058, 0x005c,
+//  0x0060, 0x0064, 0x0068, 0x006c, 0x0070, 0x0074, 0x0078, 0x007c,
+//  0x0100, 0x0108, 0x0110, 0x0118, 0x0120, 0x0128, 0x0130, 0x0138,
+//  0x0140, 0x0148, 0x0150, 0x0158, 0x0160, 0x0168, 0x0170, 0x0178,
+//  0x0300, 0x0310, 0x0320, 0x0330, 0x0340, 0x0350, 0x0360, 0x0370,
+//  0x0380, 0x0390, 0x03a0, 0x03b0, 0x03c0, 0x03d0, 0x03e0, 0x03f0,
+//  0x0800, 0x0820, 0x0840, 0x0860, 0x0880, 0x08a0, 0x08c0, 0x08e0,
+//  0x0900, 0x0920, 0x0940, 0x0960, 0x0980, 0x09a0, 0x09c0, 0x09e0,
+//  0x1400, 0x1440, 0x1480, 0x14c0, 0x1500, 0x1540, 0x1580, 0x15c0,
+//  0x1600, 0x1640, 0x1680, 0x16c0, 0x1700, 0x1740, 0x1780, 0x17c0,
+//  0x3000, 0x3080, 0x3100, 0x3180, 0x3200, 0x3280, 0x3300, 0x3380,
+//  0x3400, 0x3480, 0x3500, 0x3580, 0x3600, 0x3680, 0x3700, 0x3780,
+//  0x7000, 0x7100, 0x7200, 0x7300, 0x7400, 0x7500, 0x7600, 0x7700,
+//  0x7800, 0x7900, 0x7a00, 0x7b00, 0x7c00, 0x7d00, 0x7e00, 0x7f00,
+//  0x8000, 0x8100, 0x8200, 0x8300, 0x8400, 0x8500, 0x8600, 0x8700,
+//  0x8800, 0x8900, 0x8a00, 0x8b00, 0x8c00, 0x8d00, 0x8e00, 0x8f00,
+//  0x9000, 0x9100, 0x9200, 0x9300, 0x9400, 0x9500, 0x9600, 0x9700,
+//  0x9800, 0x9900, 0x9a00, 0x9b00, 0x9c00, 0x9d00, 0x9e00, 0x9f00,
+//  0xa000, 0xa100, 0xa200, 0xa300, 0xa400, 0xa500, 0xa600, 0xa700,
+//  0xa800, 0xa900, 0xaa00, 0xab00, 0xac00, 0xad00, 0xae00, 0xaf00,
+//  0xb000, 0xb100, 0xb200, 0xb300, 0xb400, 0xb500, 0xb600, 0xb700,
+//  0xb800, 0xb900, 0xba00, 0xbb00, 0xbc00, 0xbd00, 0xbe00, 0xbf00,
+//  0xc000, 0xc100, 0xc200, 0xc300, 0xc400, 0xc500, 0xc600, 0xc700,
+//  0xc800, 0xc900, 0xca00, 0xcb00, 0xcc00, 0xcd00, 0xce00, 0xcf00,
+//  0xd000, 0xd100, 0xd200, 0xd300, 0xd400, 0xd500, 0xd600, 0xd700,
+//  0xd800, 0xd900, 0xda00, 0xdb00, 0xdc00, 0xdd00, 0xde00, 0xdf00,
+//  0xe000, 0xe100, 0xe200, 0xe300, 0xe400, 0xe500, 0xe600, 0xe700,
+//  0xe800, 0xe900, 0xea00, 0xeb00, 0xec00, 0xed00, 0xee00, 0xef00,
+//  0xf000, 0xf100, 0xf200, 0xf300, 0xf400, 0xf500, 0xf600, 0xf700,
+//  0xf800, 0xf900, 0xfa00, 0xfb00, 0xfc00, 0xfd00, 0xfe00, 0xffff,
+//};
+
+//static struct atmel_pwm_bl_platform_data eco_g45_pwm_bl_data = {
+//  .pwm_channel    = 2,
+//  .pwm_frequency    = 8191, /* TPS61161A requires 5-100kHz */
+//  .pwm_compare_max  = 8191, /* We cannot use the full range, because
+//                   MCK=100MHz is to slow to count above 5kHz. */
+//  .pwm_duty_max   = 255,
+//  .pwm_duty_min   = 0,
+////  .pwm_duty_init    = 255,
+////  .pwm_bl_lut     = gpm1035_bl_lut,
+//  .pwm_active_low   = 0,
+//  .gpio_on      = AT91_PIN_PE2,
+//  .on_active_low    = 0,
+//};
+
+
