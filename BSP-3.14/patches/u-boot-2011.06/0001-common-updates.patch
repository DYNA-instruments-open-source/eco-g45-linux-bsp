Index: u-boot-2011.06/boards.cfg
===================================================================
--- u-boot-2011.06.orig/boards.cfg	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/boards.cfg	2011-09-20 17:03:31.150018148 +0200
@@ -35,56 +35,68 @@
 # Target                     ARCH        CPU         Board name          Vendor	        SoC         Options
 ###########################################################################################################
 
+integratorcp_cm1136          arm         arm1136     integrator          armltd         -           integratorcp
 qong                         arm         arm1136     -                   davedenx       mx31
 mx31ads                      arm         arm1136     -                   freescale      mx31
 imx31_litekit                arm         arm1136     -                   logicpd        mx31
 mx35pdk                      arm         arm1136     -                   freescale      mx35
 omap2420h4                   arm         arm1136     -                   ti             omap24xx
 tnetv107x_evm                arm         arm1176     tnetv107xevm        ti             tnetv107x
-armadillo                    arm         arm720t
-ep7312                       arm         arm720t
-impa7                        arm         arm720t
-modnet50                     arm         arm720t
-lpc2292sodimm                arm         arm720t     -                   -              lpc2292
-SMN42                        arm         arm720t     -                   siemens        lpc2292
-evb4510                      arm         arm720t     -                   -              s3c4510b
+integratorap_cm720t          arm         arm720t     integrator          armltd         -           integratorap
+integratorap_cm920t          arm         arm920t     integrator          armltd         -           integratorap
+integratorcp_cm920t          arm         arm920t     integrator          armltd         -           integratorcp
 a320evb                      arm         arm920t     -                   faraday        a320
 at91rm9200ek                 arm         arm920t     at91rm9200ek        atmel          at91        at91rm9200ek
 at91rm9200ek_ram             arm         arm920t     at91rm9200ek        atmel          at91        at91rm9200ek:RAMBOOT
 eb_cpux9k2                   arm         arm920t     -                   BuS            at91
 cpuat91                      arm         arm920t     cpuat91             eukrea         at91        cpuat91
 cpuat91_ram                  arm         arm920t     cpuat91             eukrea         at91        cpuat91:RAMBOOT
-cmc_pu2                      arm         arm920t     -                   -              at91rm9200
-csb637                       arm         arm920t     -                   -              at91rm9200
-kb9202                       arm         arm920t     -                   -              at91rm9200
-m501sk                       arm         arm920t     -                   -              at91rm9200
-at91rm9200dk                 arm         arm920t     -                   atmel          at91rm9200
 mx1ads                       arm         arm920t     -                   -              imx
-mx1fs2                       arm         arm920t     -                   -              imx
 scb9328                      arm         arm920t     -                   -              imx
 cm4008                       arm         arm920t     -                   -              ks8695
 cm41xx                       arm         arm920t     -                   -              ks8695
-sbc2410x                     arm         arm920t     -                   -              s3c24x0
 VCMA9                        arm         arm920t     vcma9               mpl            s3c24x0
-smdk2400                     arm         arm920t     -                   samsung        s3c24x0
 smdk2410                     arm         arm920t     -                   samsung        s3c24x0
-netstar                      arm         arm925t
-voiceblue                    arm         arm925t
 omap1510inn                  arm         arm925t     -                   ti
+integratorap_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorap
+integratorcp_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorcp
+versatileqemu                arm         arm926ejs   versatile           armltd         versatile   versatile:ARCH_VERSATILE_QEMU,ARCH_VERSATILE_PB
+versatilepb                  arm         arm926ejs   versatile           armltd         versatile   versatile:ARCH_VERSATILE_PB
+versatileab                  arm         arm926ejs   versatile           armltd         versatile   versatile:ARCH_VERSATILE_AB
 aspenite                     arm         arm926ejs   -                   Marvell        armada100
+gplugd                       arm         arm926ejs   -                   Marvell        armada100
 afeb9260                     arm         arm926ejs   -                   -              at91
-at91cap9adk                  arm         arm926ejs   -                   atmel          at91
 at91sam9260ek_nandflash      arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9260,SYS_USE_NANDFLASH
 at91sam9260ek_dataflash_cs0  arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9260,SYS_USE_DATAFLASH_CS0
 at91sam9260ek_dataflash_cs1  arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9260,SYS_USE_DATAFLASH_CS1
+at91sam9261ek_nandflash      arm         arm926ejs   at91sam9261ek       atmel          at91        at91sam9261ek:AT91SAM9261,SYS_USE_NANDFLASH
+at91sam9261ek_dataflash_cs0  arm         arm926ejs   at91sam9261ek       atmel          at91        at91sam9261ek:AT91SAM9261,SYS_USE_DATAFLASH_CS0
+at91sam9261ek_dataflash_cs3  arm         arm926ejs   at91sam9261ek       atmel          at91        at91sam9261ek:AT91SAM9261,SYS_USE_DATAFLASH_CS3
+at91sam9263ek_nandflash      arm         arm926ejs   at91sam9263ek       atmel          at91        at91sam9263ek:AT91SAM9263,SYS_USE_NANDFLASH
+at91sam9263ek_dataflash_cs0  arm         arm926ejs   at91sam9263ek       atmel          at91        at91sam9263ek:AT91SAM9263,SYS_USE_DATAFLASH
+at91sam9263ek_dataflash      arm         arm926ejs   at91sam9263ek       atmel          at91        at91sam9263ek:AT91SAM9263,SYS_USE_DATAFLASH
+at91sam9263ek_norflash       arm         arm926ejs   at91sam9263ek       atmel          at91        at91sam9263ek:AT91SAM9263,SYS_USE_NORFLASH
+at91sam9263ek_norflash_boot  arm         arm926ejs   at91sam9263ek       atmel          at91        at91sam9263ek:AT91SAM9263,SYS_USE_BOOT_NORFLASH
+at91sam9g10ek_nandflash      arm         arm926ejs   at91sam9261ek       atmel          at91        at91sam9261ek:AT91SAM9G10,SYS_USE_NANDFLASH
+at91sam9g10ek_dataflash_cs0  arm         arm926ejs   at91sam9261ek       atmel          at91        at91sam9261ek:AT91SAM9G10,SYS_USE_DATAFLASH_CS0
+at91sam9g10ek_dataflash_cs3  arm         arm926ejs   at91sam9261ek       atmel          at91        at91sam9261ek:AT91SAM9G10,SYS_USE_DATAFLASH_CS3
 at91sam9g20ek_nandflash      arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9G20,SYS_USE_NANDFLASH
 at91sam9g20ek_dataflash_cs0  arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9G20,SYS_USE_DATAFLASH_CS0
 at91sam9g20ek_dataflash_cs1  arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9G20,SYS_USE_DATAFLASH_CS1
+at91sam9m10g45ek_nandflash   arm         arm926ejs   at91sam9m10g45ek    atmel          at91        at91sam9m10g45ek:AT91SAM9M10G45,SYS_USE_NANDFLASH
+at91sam9rlek_nandflash       arm         arm926ejs   at91sam9rlek        atmel          at91        at91sam9rlek:AT91SAM9RL,SYS_USE_NANDFLASH
+at91sam9rlek_dataflash       arm         arm926ejs   at91sam9rlek        atmel          at91        at91sam9rlek:AT91SAM9RL,SYS_USE_DATAFLASH
 at91sam9xeek_nandflash       arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9XE,SYS_USE_NANDFLASH
 at91sam9xeek_dataflash_cs0   arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9XE,SYS_USE_DATAFLASH_CS0
 at91sam9xeek_dataflash_cs1   arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9XE,SYS_USE_DATAFLASH_CS1
 snapper9260                  arm         arm926ejs   -                   bluewater      at91        snapper9260:AT91SAM9260
 snapper9g20                  arm         arm926ejs   snapper9260         bluewater      at91        snapper9260:AT91SAM9G20
+sbc35_a9g20_nandflash        arm         arm926ejs   sbc35_a9g20         calao          at91        sbc35_a9g20:AT91SAM9G20,SYS_USE_NANDFLASH
+sbc35_a9g20_eeprom           arm         arm926ejs   sbc35_a9g20         calao          at91        sbc35_a9g20:AT91SAM9G20,SYS_USE_EEPROM
+tny_a9g20_nandflash          arm         arm926ejs   tny_a9260           calao          at91        tny_a9260:AT91SAM9G20,SYS_USE_NANDFLASH
+tny_a9g20_eeprom             arm         arm926ejs   tny_a9260           calao          at91        tny_a9260:AT91SAM9G20,SYS_USE_EEPROM
+tny_a9260_nandflash          arm         arm926ejs   tny_a9260           calao          at91        tny_a9260:AT91SAM9260,SYS_USE_NANDFLASH
+tny_a9260_eeprom             arm         arm926ejs   tny_a9260           calao          at91        tny_a9260:AT91SAM9260,SYS_USE_EEPROM
 cpu9260                      arm         arm926ejs   cpu9260             eukrea         at91        cpu9260:CPU9260
 cpu9260_nand                 arm         arm926ejs   cpu9260             eukrea         at91        cpu9260:CPU9260,NANDBOOT
 cpu9260_128M                 arm         arm926ejs   cpu9260             eukrea         at91        cpu9260:CPU9260,CPU9260_128M
@@ -99,8 +111,9 @@
 meesc_dataflash              arm         arm926ejs   meesc               esd            at91        meesc:AT91SAM9263,SYS_USE_DATAFLASH
 otc570                       arm         arm926ejs   otc570              esd            at91        otc570:AT91SAM9263,SYS_USE_NANDFLASH
 otc570_dataflash             arm         arm926ejs   otc570              esd            at91        otc570:AT91SAM9263,SYS_USE_DATAFLASH
-pm9261                       arm         arm926ejs   -                   ronetix        at91
-pm9263                       arm         arm926ejs   -                   ronetix        at91
+pm9261                       arm         arm926ejs   pm9261              ronetix        at91        pm9261:AT91SAM9261
+pm9263                       arm         arm926ejs   pm9263              ronetix        at91        pm9263:AT91SAM9263
+pm9g45                       arm         arm926ejs   pm9g45              ronetix        at91        pm9g45:AT91SAM9G45
 da830evm                     arm         arm926ejs   da8xxevm            davinci        davinci
 da850evm                     arm         arm926ejs   da8xxevm            davinci        davinci
 hawkboard                    arm         arm926ejs   da8xxevm            davinci        davinci
@@ -115,9 +128,13 @@
 davinci_schmoogie            arm         arm926ejs   schmoogie           davinci        davinci
 davinci_sffsdr               arm         arm926ejs   sffsdr              davinci        davinci
 davinci_sonata               arm         arm926ejs   sonata              davinci        davinci
-suen3                        arm         arm926ejs   km_arm              keymile        kirkwood
-suen8                        arm         arm926ejs   km_arm              keymile        kirkwood
+km_kirkwood                  arm         arm926ejs   km_arm              keymile        kirkwood	km_kirkwood:KM_DISABLE_PCI
+km_kirkwood_pci              arm         arm926ejs   km_arm              keymile        kirkwood	km_kirkwood
 mgcoge3un                    arm         arm926ejs   km_arm              keymile        kirkwood
+portl2                       arm         arm926ejs   km_arm              keymile        kirkwood
+inetspace_v2                 arm         arm926ejs   netspace_v2         LaCie          kirkwood    netspace_v2:INETSPACE_V2
+netspace_v2                  arm         arm926ejs   netspace_v2         LaCie          kirkwood    netspace_v2:NETSPACE_V2
+netspace_max_v2              arm         arm926ejs   netspace_v2         LaCie          kirkwood    netspace_v2:NETSPACE_MAX_V2
 guruplug                     arm         arm926ejs   -                   Marvell        kirkwood
 mv88f6281gtw_ge              arm         arm926ejs   -                   Marvell        kirkwood
 openrd_base                  arm         arm926ejs   openrd              Marvell        kirkwood        openrd:BOARD_IS_OPENRD_BASE
@@ -127,6 +144,7 @@
 sheevaplug                   arm         arm926ejs   -                   Marvell        kirkwood
 dockstar                     arm         arm926ejs   -                   Seagate        kirkwood
 jadecpu                      arm         arm926ejs   jadecpu             syteco         mb86r0x
+zmx25                        arm         arm926ejs   zmx25               syteco         mx25
 imx27lite                    arm         arm926ejs   imx27lite           logicpd        mx27
 magnesium                    arm         arm926ejs   imx27lite           logicpd        mx27
 nhk8815                      arm         arm926ejs   nhk8815             st             nomadik
@@ -134,9 +152,12 @@
 omap5912osk                  arm         arm926ejs   -                   ti             omap
 edminiv2                     arm         arm926ejs   -                   LaCie          orion5x
 dkb			     arm         arm926ejs   -                   Marvell        pantheon
+integratorap_cm946es         arm         arm946es    integrator          armltd         -               integratorap
+integratorcp_cm946es         arm         arm946es    integrator          armltd         -               integratorcp
 ca9x4_ct_vxp                 arm         armv7       vexpress            armltd
-efikamx                      arm         armv7       efikamx             -              mx5		mx51evk:IMX_CONFIG=board/efikamx/imximage.cfg
+efikamx                      arm         armv7       efikamx             -              mx5		efikamx:IMX_CONFIG=board/efikamx/imximage.cfg
 mx51evk                      arm         armv7       mx51evk             freescale      mx5		mx51evk:IMX_CONFIG=board/freescale/mx51evk/imximage.cfg
+mx53ard                      arm         armv7       mx53ard             freescale      mx5		mx53ard:IMX_CONFIG=board/freescale/mx53ard/imximage_dd3.cfg
 mx53evk                      arm         armv7       mx53evk             freescale      mx5		mx53evk:IMX_CONFIG=board/freescale/mx53evk/imximage.cfg
 mx53loco                     arm         armv7       mx53loco            freescale      mx5		mx53loco:IMX_CONFIG=board/freescale/mx53loco/imximage.cfg
 mx53smd                      arm         armv7       mx53smd             freescale      mx5		mx53smd:IMX_CONFIG=board/freescale/mx53smd/imximage.cfg
@@ -159,6 +180,7 @@
 omap4_sdp4430                arm         armv7       sdp4430             ti             omap4
 s5p_goni                     arm         armv7       goni                samsung        s5pc1xx
 smdkc100                     arm         armv7       smdkc100            samsung        s5pc1xx
+origen			     arm	 armv7	     origen		 samsung	s5pc2xx
 s5pc210_universal            arm         armv7       universal_c210      samsung        s5pc2xx
 smdkv310		     arm	 armv7	     smdkv310		 samsung	s5pc2xx
 harmony                      arm         armv7       harmony             nvidia         tegra2
@@ -174,8 +196,6 @@
 dvlhost                      arm         ixp
 ixdp425                      arm         ixp
 ixdpg425                     arm         ixp         ixdp425
-lpd7a400                     arm         lh7a40x     lpd7a40x
-lpd7a404                     arm         lh7a40x     lpd7a40x
 balloon3                     arm         pxa
 cerf250                      arm         pxa
 colibri_pxa270               arm         pxa
@@ -195,20 +215,14 @@
 xaeniax                      arm         pxa
 xm250                        arm         pxa
 zipitz2                      arm         pxa
-zylonite                     arm         pxa
-B2                           arm         s3c44b0     -                   dave
-assabet                      arm         sa1100
-dnp1110                      arm         sa1100
-gcplus                       arm         sa1100
 jornada                      arm         sa1100
-lart                         arm         sa1100
-shannon                      arm         sa1100
 atngw100                     avr32       at32ap      -                   atmel          at32ap700x
 atstk1002                    avr32       at32ap      atstk1000           atmel          at32ap700x
 atstk1003                    avr32       at32ap      atstk1000           atmel          at32ap700x
 atstk1004                    avr32       at32ap      atstk1000           atmel          at32ap700x
 atstk1006                    avr32       at32ap      atstk1000           atmel          at32ap700x
 favr-32-ezkit                avr32       at32ap      -                   earthlcd       at32ap700x
+grasshopper                  avr32       at32ap      -                   in-circuit     at32ap700x
 mimc200                      avr32       at32ap      -                   mimc           at32ap700x
 hammerhead                   avr32       at32ap      -                   miromico       at32ap700x
 bct-brettl2                  blackfin    blackfin
@@ -255,7 +269,7 @@
 M5272C3                      m68k        mcf52x2     m5272c3             freescale
 M5275EVB                     m68k        mcf52x2     m5275evb            freescale
 M5282EVB                     m68k        mcf52x2     m5282evb            freescale
-M53017EVB                    m68k        mcf52x2     m53017evb           freescale
+M53017EVB                    m68k        mcf532x     m53017evb           freescale
 EP2500                       m68k        mcf52x2     ep2500              Mercury
 microblaze-generic           microblaze  microblaze  microblaze-generic  xilinx
 dbau1000                     mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1000
@@ -283,6 +297,7 @@
 vct_platinumavc_small        mips        mips32      vct                 micronas       -           vct:VCT_PLATINUMAVC,VCT_SMALL_IMAGE
 vct_platinumavc_onenand      mips        mips32      vct                 micronas       -           vct:VCT_PLATINUMAVC,VCT_ONENAND
 vct_platinumavc_onenand_small mips       mips32      vct                 micronas       -           vct:VCT_PLATINUMAVC,VCT_ONENAND,VCT_SMALL_IMAGE
+nios2-generic                nios2       nios2       nios2-generic       altera
 PCI5441                      nios2       nios2       pci5441             psyent
 PK1C20                       nios2       nios2       pk1c20              psyent
 EVB64260                     powerpc     74xx_7xx    evb64260            -              -           EVB64260
@@ -311,10 +326,10 @@
 BC3450                       powerpc     mpc5xxx     bc3450
 canmb                        powerpc     mpc5xxx
 cm5200                       powerpc     mpc5xxx
-digsy_mtc                    powerpc     mpc5xxx     digsy_mtc
-digsy_mtc_RAMBOOT            powerpc     mpc5xxx     digsy_mtc           -              -           digsy_mtc:SYS_TEXT_BASE=0x00100000
-digsy_mtc_rev5               powerpc     mpc5xxx     digsy_mtc           -              -           digsy_mtc:DIGSY_REV5
-digsy_mtc_rev5_RAMBOOT       powerpc     mpc5xxx     digsy_mtc           -              -           digsy_mtc:SYS_TEXT_BASE=0x00100000,DIGSY_REV5
+digsy_mtc                    powerpc     mpc5xxx     digsy_mtc           intercontrol
+digsy_mtc_RAMBOOT            powerpc     mpc5xxx     digsy_mtc           intercontrol   -           digsy_mtc:SYS_TEXT_BASE=0x00100000
+digsy_mtc_rev5               powerpc     mpc5xxx     digsy_mtc           intercontrol   -           digsy_mtc:DIGSY_REV5
+digsy_mtc_rev5_RAMBOOT       powerpc     mpc5xxx     digsy_mtc           intercontrol   -           digsy_mtc:SYS_TEXT_BASE=0x00100000,DIGSY_REV5
 galaxy5200                   powerpc     mpc5xxx     galaxy5200          -              -           galaxy5200:galaxy5200
 galaxy5200_LOWBOOT           powerpc     mpc5xxx     galaxy5200          -              -           galaxy5200:galaxy5200_LOWBOOT
 icecube_5200                 powerpc     mpc5xxx     icecube             -              -           IceCube
@@ -512,6 +527,7 @@
 MPC837XEMDS_HOST             powerpc     mpc83xx     mpc837xemds         freescale      -           MPC837XEMDS:PCI
 MPC837XERDB                  powerpc     mpc83xx     mpc837xerdb         freescale
 kmeter1                      powerpc     mpc83xx     km83xx              keymile
+MERGERBOX                    powerpc     mpc83xx     mergerbox           matrix_vision
 MVBLM7                       powerpc     mpc83xx     mvblm7              matrix_vision
 SIMPC8313_LP                 powerpc     mpc83xx     simpc8313           sheldon        -           SIMPC8313:NAND_LP
 SIMPC8313_SP                 powerpc     mpc83xx     simpc8313           sheldon        -           SIMPC8313:NAND_SP
@@ -569,6 +585,8 @@
 P1020RDB_SPIFLASH            powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P1020RDB,SPIFLASH
 P1022DS                      powerpc     mpc85xx     p1022ds             freescale
 P1022DS_36BIT                powerpc     mpc85xx     p1022ds             freescale      -           P1022DS:36BIT
+P1023RDS                     powerpc     mpc85xx     p1023rds            freescale      -           P1023RDS
+P1023RDS_NAND                powerpc     mpc85xx     p1023rds            freescale      -           P1023RDS:NAND
 P2010RDB                     powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2010RDB
 P2010RDB_36BIT               powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2010RDB,36BIT
 P2010RDB_36BIT_SDCARD        powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2010RDB,36BIT,SDCARD
@@ -588,13 +606,18 @@
 P2020RDB_NAND                powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2020RDB,NAND
 P2020RDB_SDCARD              powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2020RDB,SDCARD
 P2020RDB_SPIFLASH            powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2020RDB,SPIFLASH
+P2041RDB                     powerpc     mpc85xx     p2041rdb            freescale
+P2041RDB_SDCARD              powerpc     mpc85xx     p2041rdb            freescale      -           P2041RDB:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
+P2041RDB_SPIFLASH            powerpc     mpc85xx     p2041rdb            freescale      -           P2041RDB:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
 P3041DS                      powerpc     mpc85xx     corenet_ds          freescale
+P3041DS_NAND		     powerpc     mpc85xx     corenet_ds          freescale      -           P3041DS:RAMBOOT_PBL,NAND,SYS_TEXT_BASE=0xFFF80000
 P3041DS_SDCARD		     powerpc     mpc85xx     corenet_ds          freescale      -           P3041DS:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
 P3041DS_SPIFLASH	     powerpc     mpc85xx     corenet_ds          freescale      -           P3041DS:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
 P4080DS                      powerpc     mpc85xx     corenet_ds          freescale
 P4080DS_SDCARD		     powerpc     mpc85xx     corenet_ds          freescale      -           P4080DS:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
 P4080DS_SPIFLASH	     powerpc     mpc85xx     corenet_ds          freescale      -           P4080DS:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
 P5020DS                      powerpc     mpc85xx     corenet_ds          freescale
+P5020DS_NAND		     powerpc     mpc85xx     corenet_ds          freescale      -           P5020DS:RAMBOOT_PBL,NAND,SYS_TEXT_BASE=0xFFF80000
 P5020DS_SDCARD		     powerpc     mpc85xx     corenet_ds          freescale      -           P5020DS:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF80000
 P5020DS_SPIFLASH	     powerpc     mpc85xx     corenet_ds          freescale      -           P5020DS:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF80000
 mpq101                       powerpc     mpc85xx     mpq101              mercury        -           mpq101
@@ -823,9 +846,6 @@
 MIP405                       powerpc     ppc4xx      mip405              mpl
 MIP405T                      powerpc     ppc4xx      mip405              mpl            -           MIP405:MIP405T
 PIP405                       powerpc     ppc4xx      pip405              mpl
-hcu4                         powerpc     ppc4xx      hcu4                netstal
-hcu5                         powerpc     ppc4xx      hcu5                netstal
-mcu25                        powerpc     ppc4xx      mcu25               netstal
 alpr                         powerpc     ppc4xx      -                   prodrive
 p3p440                       powerpc     ppc4xx      -                   prodrive
 KAREF                        powerpc     ppc4xx      karef               sandburst
@@ -838,6 +858,7 @@
 xilinx-ppc440-generic        powerpc     ppc4xx      ppc440-generic      xilinx         -           xilinx-ppc440-generic:SYS_TEXT_BASE=0x04000000,RESET_VECTOR_ADDRESS=0x04100000,BOOT_FROM_XMD=1
 xilinx-ppc440-generic_flash  powerpc     ppc4xx      ppc440-generic      xilinx         -           xilinx-ppc440-generic:SYS_TEXT_BASE=0xF7F60000,RESET_VECTOR_ADDRESS=0xF7FFFFFC
 rsk7203                      sh          sh2         rsk7203             renesas        -
+rsk7264                      sh          sh2         rsk7264             renesas        -
 mpr2                         sh          sh3         mpr2                -              -
 ms7720se                     sh          sh3         ms7720se            -              -
 shmin                        sh          sh3         shmin               -              -
Index: u-boot-2011.06/common/cmd_bdinfo.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_bdinfo.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_bdinfo.c	2011-09-20 17:03:31.150018148 +0200
@@ -345,7 +345,7 @@
 	printf("ip_addr     = %pI4\n", &bd->bi_ip_addr);
 #endif
 	printf("baudrate    = %d bps\n", bd->bi_baudrate);
-#if !(defined(CONFIG_SYS_NO_ICACHE) && defined(CONFIG_SYS_NO_DCACHE))
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
 	print_num("TLB addr", gd->tlb_addr);
 #endif
 	print_num("relocaddr", gd->relocaddr);
Index: u-boot-2011.06/common/cmd_bootm.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_bootm.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_bootm.c	2011-09-20 17:03:31.150018148 +0200
@@ -432,6 +432,9 @@
 		printf ("Unimplemented compression type %d\n", comp);
 		return BOOTM_ERR_UNIMPLEMENTED;
 	}
+
+	flush_cache(load, (*load_end - load) * sizeof(ulong));
+
 	puts ("OK\n");
 	debug ("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
 	if (boot_progress)
@@ -708,6 +711,21 @@
 	return 1;
 }
 
+int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
+{
+	const char *ep = getenv("autostart");
+
+	if (ep && !strcmp(ep, "yes")) {
+		char *local_args[2];
+		local_args[0] = (char *)cmd;
+		local_args[1] = NULL;
+		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
+		return do_bootm(cmdtp, 0, 1, local_args);
+	}
+
+	return 0;
+}
+
 /**
  * image_get_kernel - verify legacy format kernel image
  * @img_addr: in RAM address of the legacy format image to be verified
Index: u-boot-2011.06/common/cmd_cache.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_cache.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_cache.c	2011-09-20 17:03:31.150018148 +0200
@@ -26,18 +26,27 @@
  */
 #include <common.h>
 #include <command.h>
+#include <linux/compiler.h>
 
-static int on_off (const char *);
+static int parse_argv(const char *);
+
+void __weak flush_icache(void)
+{
+	/* please define arch specific flush_icache */
+	puts("No arch specific flush_icache available!\n");
+}
 
 int do_icache ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	switch (argc) {
 	case 2:			/* on / off	*/
-		switch (on_off(argv[1])) {
+		switch (parse_argv(argv[1])) {
 		case 0:	icache_disable();
 			break;
 		case 1:	icache_enable ();
 			break;
+		case 2: flush_icache();
+			break;
 		}
 		/* FALL TROUGH */
 	case 1:			/* get status */
@@ -50,15 +59,23 @@
 	return 0;
 }
 
+void __weak flush_dcache(void)
+{
+	puts("No arch specific flush_dcache available!\n");
+	/* please define arch specific flush_dcache */
+}
+
 int do_dcache ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	switch (argc) {
 	case 2:			/* on / off	*/
-		switch (on_off(argv[1])) {
+		switch (parse_argv(argv[1])) {
 		case 0:	dcache_disable();
 			break;
 		case 1:	dcache_enable ();
 			break;
+		case 2: flush_dcache();
+			break;
 		}
 		/* FALL TROUGH */
 	case 1:			/* get status */
@@ -72,9 +89,11 @@
 
 }
 
-static int on_off (const char *s)
+static int parse_argv(const char *s)
 {
-	if (strcmp(s, "on") == 0) {
+	if (strcmp(s, "flush") == 0) {
+		return (2);
+	} else if (strcmp(s, "on") == 0) {
 		return (1);
 	} else if (strcmp(s, "off") == 0) {
 		return (0);
@@ -86,13 +105,13 @@
 U_BOOT_CMD(
 	icache,   2,   1,     do_icache,
 	"enable or disable instruction cache",
-	"[on, off]\n"
-	"    - enable or disable instruction cache"
+	"[on, off, flush]\n"
+	"    - enable, disable, or flush instruction cache"
 );
 
 U_BOOT_CMD(
 	dcache,   2,   1,     do_dcache,
 	"enable or disable data cache",
-	"[on, off]\n"
-	"    - enable or disable data (writethrough) cache"
+	"[on, off, flush]\n"
+	"    - enable, disable, or flush data (writethrough) cache"
 );
Index: u-boot-2011.06/common/cmd_dtt.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_dtt.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_dtt.c	2011-09-20 17:03:31.150018148 +0200
@@ -28,12 +28,16 @@
 #include <dtt.h>
 #include <i2c.h>
 
+static unsigned long sensor_initialized;
+
 int do_dtt (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 {
 	int i;
 	unsigned char sensors[] = CONFIG_DTT_SENSORS;
 	int old_bus;
 
+	/* Force a compilation error, if there are more then 32 sensors */
+	BUILD_BUG_ON(sizeof(sensors) > 32);
 	/* switch to correct I2C bus */
 	old_bus = I2C_GET_BUS();
 	I2C_SET_BUS(CONFIG_SYS_DTT_BUS_NUM);
@@ -42,8 +46,16 @@
 	 * Loop through sensors, read
 	 * temperature, and output it.
 	 */
-	for (i = 0; i < sizeof (sensors); i++)
-		printf ("DTT%d: %i C\n", i + 1, dtt_get_temp (sensors[i]));
+	for (i = 0; i < sizeof(sensors); i++) {
+		if ((sensor_initialized & (1 << i)) == 0) {
+			if (dtt_init_one(sensors[i]) != 0) {
+				printf("DTT%d: Failed init!\n", i);
+				continue;
+			}
+			sensor_initialized |= (1 << i);
+		}
+		printf("DTT%d: %i C\n", i + 1, dtt_get_temp(sensors[i]));
+	}
 
 	/* switch back to original I2C bus */
 	I2C_SET_BUS(old_bus);
Index: u-boot-2011.06/common/cmd_eeprom.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_eeprom.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_eeprom.c	2011-09-20 17:03:31.150018148 +0200
@@ -250,7 +250,7 @@
 
 		/*
 		 * For a FRAM device there is no limit on the number of the
-		 * bytes that can be ccessed with the single read or write
+		 * bytes that can be accessed with the single read or write
 		 * operation.
 		 */
 #if !defined(CONFIG_SYS_I2C_FRAM)
Index: u-boot-2011.06/common/cmd_fdc.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_fdc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_fdc.c	2011-09-20 17:03:31.150018148 +0200
@@ -721,8 +721,6 @@
 	image_header_t *hdr;  /* used for fdc boot */
 	unsigned char boot_drive;
 	int i,nrofblk;
-	char *ep;
-	int rcode = 0;
 #if defined(CONFIG_FIT)
 	const void *fit_hdr = NULL;
 #endif
@@ -823,19 +821,7 @@
 	/* Loading ok, update default load address */
 	load_addr = addr;
 
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
-		char *local_args[2];
-
-		local_args[0] = argv[0];
-		local_args[1] = NULL;
-
-		printf ("Automatic boot of image at addr 0x%08lX ...\n", addr);
-
-		do_bootm (cmdtp, 0, 1, local_args);
-		rcode ++;
-	}
-	return rcode;
+	return bootm_maybe_autostart(cmdtp, argv[0]);
 }
 
 U_BOOT_CMD(
Index: u-boot-2011.06/common/cmd_fdos.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_fdos.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_fdos.c	2011-09-20 17:03:31.150018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
@@ -40,7 +40,6 @@
     char *name;
     char *ep;
     int size;
-    int rcode = 0;
     char buf [12];
     int drive = CONFIG_SYS_FDC_DRIVE_NUMBER;
 
@@ -98,15 +97,7 @@
     printf("Floppy DOS load complete: %d bytes loaded to 0x%lx\n",
 	   size, load_addr);
 
-    /* Check if we should attempt an auto-start */
-    if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
-	char *local_args[2];
-	local_args[0] = argv[0];
-	local_args[1] = NULL;
-	printf ("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
-	rcode = do_bootm (cmdtp, 0, 1, local_args);
-    }
-    return rcode;
+    return bootm_maybe_autostart(cmdtp, argv[0]);
 }
 
 /*-----------------------------------------------------------------------------
Index: u-boot-2011.06/common/cmd_fitupd.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/common/cmd_fitupd.c	2011-09-20 17:03:31.150018148 +0200
@@ -0,0 +1,36 @@
+/*
+ * (C) Copyright 2011
+ * Andreas Pretzsch, carpe noctem engineering, apr@cn-eng.de
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <command.h>
+
+#if !defined(CONFIG_UPDATE_TFTP)
+#error "CONFIG_UPDATE_TFTP required"
+#endif
+
+extern int update_tftp(ulong addr);
+
+static int do_fitupd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong addr = 0UL;
+
+	if (argc > 2)
+		return cmd_usage(cmdtp);
+
+	if (argc == 2)
+		addr = simple_strtoul(argv[1], NULL, 16);
+
+	return update_tftp(addr);
+}
+
+U_BOOT_CMD(fitupd, 2, 0, do_fitupd,
+	"update from FIT image",
+	"[addr]\n"
+	"\t- run update from FIT image at addr\n"
+	"\t  or from tftp 'updatefile'"
+);
Index: u-boot-2011.06/common/cmd_flash.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_flash.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_flash.c	2011-09-20 17:03:31.150018148 +0200
@@ -139,7 +139,7 @@
 		} /* bank */
 	}
 	if (!found) {
-		/* error, addres not in flash */
+		/* error, address not in flash */
 		printf("Error: end address (0x%08lx) not in flash!\n", *addr);
 		return 1;
 	}
Index: u-boot-2011.06/common/cmd_fpga.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_fpga.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_fpga.c	2011-09-20 17:03:31.150018148 +0200
@@ -289,7 +289,7 @@
 			{
 				const void *fit_hdr = (const void *)fpga_data;
 				int noffset;
-				void *fit_data;
+				const void *fit_data;
 
 				if (fit_uname == NULL) {
 					puts ("No FIT subimage unit name\n");
Index: u-boot-2011.06/common/cmd_i2c.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_i2c.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_i2c.c	2011-09-20 17:03:31.150018148 +0200
@@ -1397,8 +1397,8 @@
 	return tmp;
 }
 
-/* Analyses a Muxstring and sends immediately the
-   Commands to the Muxes. Runs from Flash.
+/* Analyses a Muxstring and immediately sends the
+   commands to the muxes. Runs from flash.
  */
 int i2c_mux_ident_muxstring_f (uchar *buf)
 {
Index: u-boot-2011.06/common/cmd_ide.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_ide.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_ide.c	2011-09-20 17:03:31.150018148 +0200
@@ -356,7 +356,6 @@
 	ulong addr, cnt;
 	disk_partition_t info;
 	image_header_t *hdr;
-	int rcode = 0;
 #if defined(CONFIG_FIT)
 	const void *fit_hdr = NULL;
 #endif
@@ -495,19 +494,7 @@
 
 	load_addr = addr;
 
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
-		char *local_args[2];
-
-		local_args[0] = argv[0];
-		local_args[1] = NULL;
-
-		printf ("Automatic boot of image at addr 0x%08lX ...\n", addr);
-
-		do_bootm (cmdtp, 0, 1, local_args);
-		rcode = 1;
-	}
-	return rcode;
+	return bootm_maybe_autostart(cmdtp, argv[0]);
 }
 
 /* ------------------------------------------------------------------------- */
@@ -732,10 +719,12 @@
 
 /* ------------------------------------------------------------------------- */
 
+#ifdef CONFIG_PARTITIONS
 block_dev_desc_t * ide_get_dev(int dev)
 {
 	return (dev < CONFIG_SYS_IDE_MAXDEVICE) ? &ide_dev_desc[dev] : NULL;
 }
+#endif
 
 
 #ifdef CONFIG_IDE_8xx_DIRECT
Index: u-boot-2011.06/common/cmd_led.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_led.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_led.c	2011-09-20 17:03:31.150018148 +0200
@@ -34,8 +34,9 @@
 struct led_tbl_s {
 	char		*string;	/* String for use in the command */
 	led_id_t	mask;		/* Mask used for calling __led_set() */
-	void		(*on)(void);	/* Optional fucntion for turning LED on */
-	void		(*off)(void);	/* Optional fucntion for turning LED on */
+	void		(*off)(void);	/* Optional function for turning LED off */
+	void		(*on)(void);	/* Optional function for turning LED on */
+	void		(*toggle)(void);/* Optional function for toggling LED */
 };
 
 typedef struct led_tbl_s led_tbl_t;
@@ -43,76 +44,94 @@
 static const led_tbl_t led_commands[] = {
 #ifdef CONFIG_BOARD_SPECIFIC_LED
 #ifdef STATUS_LED_BIT
-	{ "0", STATUS_LED_BIT, NULL, NULL },
+	{ "0", STATUS_LED_BIT, NULL, NULL, NULL },
 #endif
 #ifdef STATUS_LED_BIT1
-	{ "1", STATUS_LED_BIT1, NULL, NULL },
+	{ "1", STATUS_LED_BIT1, NULL, NULL, NULL },
 #endif
 #ifdef STATUS_LED_BIT2
-	{ "2", STATUS_LED_BIT2, NULL, NULL },
+	{ "2", STATUS_LED_BIT2, NULL, NULL, NULL },
 #endif
 #ifdef STATUS_LED_BIT3
-	{ "3", STATUS_LED_BIT3, NULL, NULL },
+	{ "3", STATUS_LED_BIT3, NULL, NULL, NULL },
 #endif
 #endif
 #ifdef STATUS_LED_GREEN
-	{ "green", STATUS_LED_GREEN, green_LED_off, green_LED_on },
+	{ "green", STATUS_LED_GREEN, green_led_off, green_led_on, NULL },
 #endif
 #ifdef STATUS_LED_YELLOW
-	{ "yellow", STATUS_LED_YELLOW, yellow_LED_off, yellow_LED_on },
+	{ "yellow", STATUS_LED_YELLOW, yellow_led_off, yellow_led_on, NULL },
 #endif
 #ifdef STATUS_LED_RED
-	{ "red", STATUS_LED_RED, red_LED_off, red_LED_on },
+	{ "red", STATUS_LED_RED, red_led_off, red_led_on, NULL },
 #endif
 #ifdef STATUS_LED_BLUE
-	{ "blue", STATUS_LED_BLUE, blue_LED_off, blue_LED_on },
+	{ "blue", STATUS_LED_BLUE, blue_led_off, blue_led_on, NULL },
 #endif
-	{ NULL, 0, NULL, NULL }
+	{ NULL, 0, NULL, NULL, NULL }
 };
 
-int str_onoff (char *var)
+enum led_cmd { LED_ON, LED_OFF, LED_TOGGLE };
+
+enum led_cmd get_led_cmd(char *var)
 {
 	if (strcmp(var, "off") == 0) {
-		return 0;
+		return LED_OFF;
 	}
 	if (strcmp(var, "on") == 0) {
-		return 1;
+		return LED_ON;
 	}
+	if (strcmp(var, "toggle") == 0)
+		return LED_TOGGLE;
 	return -1;
 }
 
 int do_led (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
-	int state, i;
+	int i, match = 0;
+	enum led_cmd cmd;
 
 	/* Validate arguments */
 	if ((argc != 3)) {
 		return cmd_usage(cmdtp);
 	}
 
-	state = str_onoff(argv[2]);
-	if (state < 0) {
+	cmd = get_led_cmd(argv[2]);
+	if (cmd < 0) {
 		return cmd_usage(cmdtp);
 	}
 
 	for (i = 0; led_commands[i].string; i++) {
 		if ((strcmp("all", argv[1]) == 0) ||
 		    (strcmp(led_commands[i].string, argv[1]) == 0)) {
-			if (led_commands[i].on) {
-				if (state) {
+			match = 1;
+			switch (cmd) {
+			case LED_ON:
+				if (led_commands[i].on)
 					led_commands[i].on();
-				} else {
+				else
+					__led_set(led_commands[i].mask, 1);
+				break;
+			case LED_OFF:
+				if (led_commands[i].off)
 					led_commands[i].off();
-				}
-			} else {
-				__led_set(led_commands[i].mask, state);
+				else
+					__led_set(led_commands[i].mask, 0);
+				break;
+			case LED_TOGGLE:
+				if (led_commands[i].toggle)
+					led_commands[i].toggle();
+				else
+					__led_toggle(led_commands[i].mask);
 			}
-			break;
+			/* Need to set only 1 led if led_name wasn't 'all' */
+			if (strcmp("all", argv[1]) != 0)
+				break;
 		}
 	}
 
 	/* If we ran out of matches, print Usage */
-	if (!led_commands[i].string && !(strcmp("all", argv[1]) == 0)) {
+	if (!match) {
 		return cmd_usage(cmdtp);
 	}
 
@@ -148,6 +167,6 @@
 #ifdef STATUS_LED_BLUE
 	"blue|"
 #endif
-	"all] [on|off]\n",
-	"led [led_name] [on|off] sets or clears led(s)\n"
+	"all] [on|off|toggle]\n",
+	"led [led_name] [on|off|toggle] sets or clears led(s)\n"
 );
Index: u-boot-2011.06/common/cmd_mac.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_mac.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_mac.c	2011-09-20 17:03:31.150018148 +0200
@@ -30,8 +30,8 @@
 	mac, 3, 1,  do_mac,
 	"display and program the system ID and MAC addresses in EEPROM",
 	"[read|save|id|num|errata|date|ports|0|1|2|3|4|5|6|7]\n"
-	"read\n"
-	"    - show content of EEPROM\n"
+	"mac read\n"
+	"    - read EEPROM content into memory\n"
 	"mac save\n"
 	"    - save to the EEPROM\n"
 	"mac id\n"
Index: u-boot-2011.06/common/cmd_md5sum.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_md5sum.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_md5sum.c	2011-09-20 17:03:31.150018148 +0200
@@ -37,7 +37,7 @@
 	addr = simple_strtoul(argv[1], NULL, 16);
 	len = simple_strtoul(argv[2], NULL, 16);
 
-	md5((unsigned char *) addr, len, output);
+	md5_wd((unsigned char *) addr, len, output, CHUNKSZ_MD5);
 	printf("md5 for %08lx ... %08lx ==> ", addr, addr + len - 1);
 	for (i = 0; i < 16; i++)
 		printf("%02x", output[i]);
Index: u-boot-2011.06/common/cmd_mem.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_mem.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_mem.c	2011-09-20 17:03:31.150018148 +0200
@@ -1092,7 +1092,7 @@
 
 	length = simple_strtoul (argv[2], NULL, 16);
 
-	crc = crc32 (0, (const uchar *) addr, length);
+	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
 
 	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
 			addr, addr + length - 1, crc);
@@ -1137,7 +1137,7 @@
 	addr += base_address;
 	length = simple_strtoul(*av++, NULL, 16);
 
-	crc = crc32(0, (const uchar *) addr, length);
+	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
 
 	if (!verify) {
 		printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
Index: u-boot-2011.06/common/cmd_mmc.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_mmc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_mmc.c	2011-09-20 17:03:31.150018148 +0200
@@ -87,6 +87,12 @@
 );
 #else /* !CONFIG_GENERIC_MMC */
 
+enum mmc_state {
+	MMC_INVALID,
+	MMC_READ,
+	MMC_WRITE,
+	MMC_ERASE,
+};
 static void print_mmcinfo(struct mmc *mmc)
 {
 	printf("Device: %s\n", mmc->name);
@@ -144,6 +150,8 @@
 
 int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
+	enum mmc_state state;
+
 	if (argc < 2)
 		return cmd_usage(cmdtp);
 
@@ -165,9 +173,11 @@
 		}
 
 		mmc->has_init = 0;
-		mmc_init(mmc);
 
-		return 0;
+		if (mmc_init(mmc))
+			return 1;
+		else
+			return 0;
 	} else if (strncmp(argv[1], "part", 4) == 0) {
 		block_dev_desc_t *mmc_dev;
 		struct mmc *mmc = find_mmc_device(curr_device);
@@ -239,53 +249,61 @@
 				curr_device, mmc->part_num);
 
 		return 0;
-	} else if (strcmp(argv[1], "read") == 0) {
-		void *addr = (void *)simple_strtoul(argv[2], NULL, 16);
-		u32 cnt = simple_strtoul(argv[4], NULL, 16);
-		u32 n;
-		u32 blk = simple_strtoul(argv[3], NULL, 16);
-		struct mmc *mmc = find_mmc_device(curr_device);
-
-		if (!mmc) {
-			printf("no mmc device at slot %x\n", curr_device);
-			return 1;
-		}
-
-		printf("\nMMC read: dev # %d, block # %d, count %d ... ",
-				curr_device, blk, cnt);
-
-		mmc_init(mmc);
-
-		n = mmc->block_dev.block_read(curr_device, blk, cnt, addr);
+	}
 
-		/* flush cache after read */
-		flush_cache((ulong)addr, cnt * 512); /* FIXME */
+	if (strcmp(argv[1], "read") == 0)
+		state = MMC_READ;
+	else if (strcmp(argv[1], "write") == 0)
+		state = MMC_WRITE;
+	else if (strcmp(argv[1], "erase") == 0)
+		state = MMC_ERASE;
+	else
+		state = MMC_INVALID;
 
-		printf("%d blocks read: %s\n",
-				n, (n==cnt) ? "OK" : "ERROR");
-		return (n == cnt) ? 0 : 1;
-	} else if (strcmp(argv[1], "write") == 0) {
-		void *addr = (void *)simple_strtoul(argv[2], NULL, 16);
-		u32 cnt = simple_strtoul(argv[4], NULL, 16);
-		u32 n;
+	if (state != MMC_INVALID) {
 		struct mmc *mmc = find_mmc_device(curr_device);
-
-		int blk = simple_strtoul(argv[3], NULL, 16);
+		int idx = 2;
+		u32 blk, cnt, n;
+		void *addr;
+
+		if (state != MMC_ERASE) {
+			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
+			++idx;
+		} else
+			addr = 0;
+		blk = simple_strtoul(argv[idx], NULL, 16);
+		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
 
 		if (!mmc) {
 			printf("no mmc device at slot %x\n", curr_device);
 			return 1;
 		}
 
-		printf("\nMMC write: dev # %d, block # %d, count %d ... ",
-				curr_device, blk, cnt);
+		printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
+				argv[1], curr_device, blk, cnt);
 
 		mmc_init(mmc);
 
-		n = mmc->block_dev.block_write(curr_device, blk, cnt, addr);
+		switch (state) {
+		case MMC_READ:
+			n = mmc->block_dev.block_read(curr_device, blk,
+						      cnt, addr);
+			/* flush cache after read */
+			flush_cache((ulong)addr, cnt * 512); /* FIXME */
+			break;
+		case MMC_WRITE:
+			n = mmc->block_dev.block_write(curr_device, blk,
+						      cnt, addr);
+			break;
+		case MMC_ERASE:
+			n = mmc->block_dev.block_erase(curr_device, blk, cnt);
+			break;
+		default:
+			BUG();
+		}
 
-		printf("%d blocks written: %s\n",
-				n, (n == cnt) ? "OK" : "ERROR");
+		printf("%d blocks %s: %s\n",
+				n, argv[1], (n == cnt) ? "OK" : "ERROR");
 		return (n == cnt) ? 0 : 1;
 	}
 
@@ -297,6 +315,7 @@
 	"MMC sub system",
 	"read addr blk# cnt\n"
 	"mmc write addr blk# cnt\n"
+	"mmc erase blk# cnt\n"
 	"mmc rescan\n"
 	"mmc part - lists available partition on current mmc device\n"
 	"mmc dev [dev] [part] - show or set current mmc device [partition]\n"
Index: u-boot-2011.06/common/cmd_nand.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_nand.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_nand.c	2011-09-20 17:03:31.150018148 +0200
@@ -575,13 +575,24 @@
 			else
 				ret = nand_write_skip_bad(nand, off, &rwsize,
 							  (u_char *)addr, 0);
+#ifdef CONFIG_CMD_NAND_TRIMFFS
+		} else if (!strcmp(s, ".trimffs")) {
+			if (read) {
+				printf("Unknown nand command suffix '%s'\n", s);
+				return 1;
+			}
+			ret = nand_write_skip_bad(nand, off, &rwsize,
+						(u_char *)addr,
+						WITH_DROP_FFS);
+#endif
 #ifdef CONFIG_CMD_NAND_YAFFS
 		} else if (!strcmp(s, ".yaffs")) {
 			if (read) {
 				printf("Unknown nand command suffix '%s'.\n", s);
 				return 1;
 			}
-			ret = nand_write_skip_bad(nand, off, &rwsize, (u_char *)addr, 1);
+			ret = nand_write_skip_bad(nand, off, &rwsize,
+						(u_char *)addr, WITH_YAFFS_OOB);
 #endif
 		} else if (!strcmp(s, ".oob")) {
 			/* out-of-band data */
@@ -688,6 +699,12 @@
 	"nand write - addr off|partition size\n"
 	"    read/write 'size' bytes starting at offset 'off'\n"
 	"    to/from memory address 'addr', skipping bad blocks.\n"
+#ifdef CONFIG_CMD_NAND_TRIMFFS
+	"nand write.trimffs - addr off|partition size\n"
+	"    write 'size' bytes starting at offset 'off' from memory address\n"
+	"    'addr', skipping bad blocks and dropping any pages at the end\n"
+	"    of eraseblocks that contain only 0xFF\n"
+#endif
 #ifdef CONFIG_CMD_NAND_YAFFS
 	"nand write.yaffs - addr off|partition size\n"
 	"    write 'size' bytes starting at offset 'off' with yaffs format\n"
@@ -724,7 +741,7 @@
 			   ulong offset, ulong addr, char *cmd)
 {
 	int r;
-	char *ep, *s;
+	char *s;
 	size_t cnt;
 	image_header_t *hdr;
 #if defined(CONFIG_FIT)
@@ -799,19 +816,7 @@
 
 	load_addr = addr;
 
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
-		char *local_args[2];
-
-		local_args[0] = cmd;
-		local_args[1] = NULL;
-
-		printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
-
-		do_bootm(cmdtp, 0, 1, local_args);
-		return 1;
-	}
-	return 0;
+	return bootm_maybe_autostart(cmdtp, cmd);
 }
 
 int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
Index: u-boot-2011.06/common/cmd_net.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_net.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_net.c	2011-09-20 17:03:31.150018148 +0200
@@ -227,17 +227,8 @@
 	/* flush cache */
 	flush_cache(load_addr, size);
 
-	/* Loading ok, check if we should attempt an auto-start */
-	if (((s = getenv("autostart")) != NULL) && (strcmp(s,"yes") == 0)) {
-		char *local_args[2];
-		local_args[0] = argv[0];
-		local_args[1] = NULL;
-
-		printf ("Automatic boot of image at addr 0x%08lX ...\n",
-			load_addr);
-		show_boot_progress (82);
-		rcode = do_bootm (cmdtp, 0, 1, local_args);
-	}
+	show_boot_progress(82);
+	rcode = bootm_maybe_autostart(cmdtp, argv[0]);
 
 	if (rcode < 0)
 		show_boot_progress (-83);
Index: u-boot-2011.06/common/cmd_nvedit.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_nvedit.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_nvedit.c	2011-09-20 17:03:31.150018148 +0200
@@ -367,13 +367,14 @@
 	return 0;
 }
 
-int setenv(char *varname, char *varvalue)
+int setenv(const char *varname, const char *varvalue)
 {
-	char * const argv[4] = { "setenv", varname, varvalue, NULL };
+	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
+
 	if ((varvalue == NULL) || (varvalue[0] == '\0'))
-		return _do_env_set(0, 2, argv);
+		return _do_env_set(0, 2, (char * const *)argv);
 	else
-		return _do_env_set(0, 3, argv);
+		return _do_env_set(0, 3, (char * const *)argv);
 }
 
 int do_env_set(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
@@ -482,7 +483,7 @@
  * return address of storage for that variable,
  * or NULL if not found
  */
-char *getenv(char *name)
+char *getenv(const char *name)
 {
 	if (gd->flags & GD_FLG_ENV_READY) {	/* after import into hashtable */
 		ENTRY e, *ep;
@@ -507,7 +508,7 @@
 /*
  * Look up variable from environment for restricted C runtime env.
  */
-int getenv_f(char *name, char *buf, unsigned len)
+int getenv_f(const char *name, char *buf, unsigned len)
 {
 	int i, nxt;
 
Index: u-boot-2011.06/common/cmd_sata.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_sata.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_sata.c	2011-09-20 17:03:31.150018148 +0200
@@ -57,10 +57,12 @@
 }
 int sata_initialize(void) __attribute__((weak,alias("__sata_initialize")));
 
+#ifdef CONFIG_PARTITIONS
 block_dev_desc_t *sata_get_dev(int dev)
 {
 	return (dev < CONFIG_SYS_SATA_MAX_DEVICE) ? &sata_dev_desc[dev] : NULL;
 }
+#endif
 
 int do_sata(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
Index: u-boot-2011.06/common/cmd_scsi.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_scsi.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_scsi.c	2011-09-20 17:03:31.160018148 +0200
@@ -46,7 +46,7 @@
 #define SCSI_VEND_ID 0x10b9
 #define SCSI_DEV_ID  0x5288
 
-#else
+#elif !defined(CONFIG_SCSI_AHCI_PLAT)
 #error no scsi device defined
 #endif
 
@@ -174,7 +174,7 @@
 		scsi_curr_dev = -1;
 }
 
-
+#ifdef CONFIG_PCI
 void scsi_init(void)
 {
 	int busdevfunc;
@@ -192,12 +192,14 @@
 	scsi_low_level_init(busdevfunc);
 	scsi_scan(1);
 }
+#endif
 
+#ifdef CONFIG_PARTITIONS
 block_dev_desc_t * scsi_get_dev(int dev)
 {
 	return (dev < CONFIG_SYS_SCSI_MAX_DEVICE) ? &scsi_dev_desc[dev] : NULL;
 }
-
+#endif
 
 /******************************************************************************
  * scsi boot command intepreter. Derived from diskboot
@@ -210,7 +212,6 @@
 	ulong addr, cnt;
 	disk_partition_t info;
 	image_header_t *hdr;
-	int rcode = 0;
 #if defined(CONFIG_FIT)
 	const void *fit_hdr = NULL;
 #endif
@@ -326,15 +327,7 @@
 
 	flush_cache (addr, (cnt+1)*info.blksz);
 
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
-		char *local_args[2];
-		local_args[0] = argv[0];
-		local_args[1] = NULL;
-		printf ("Automatic boot of image at addr 0x%08lX ...\n", addr);
-		rcode = do_bootm (cmdtp, 0, 1, local_args);
-	}
-	 return rcode;
+	return bootm_maybe_autostart(cmdtp, argv[0]);
 }
 
 /*********************************************************************************
Index: u-boot-2011.06/common/cmd_sf.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_sf.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_sf.c	2011-09-20 17:03:31.160018148 +0200
@@ -53,7 +53,7 @@
 		return -1;
 
 	if (round_up_len && flash->sector_size > 0)
-		*len = ROUND(len_arg - 1, flash->sector_size);
+		*len = ROUND(len_arg, flash->sector_size);
 	else
 		*len = len_arg;
 
Index: u-boot-2011.06/common/cmd_sha1sum.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_sha1sum.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_sha1sum.c	2011-09-20 17:03:31.160018148 +0200
@@ -37,7 +37,7 @@
 	addr = simple_strtoul(argv[1], NULL, 16);
 	len = simple_strtoul(argv[2], NULL, 16);
 
-	sha1_csum((unsigned char *) addr, len, output);
+	sha1_csum_wd((unsigned char *) addr, len, output, CHUNKSZ_SHA1);
 	printf("SHA1 for %08lx ... %08lx ==> ", addr, addr + len - 1);
 	for (i = 0; i < 20; i++)
 		printf("%02x", output[i]);
Index: u-boot-2011.06/common/cmd_usb.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_usb.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_usb.c	2011-09-20 17:03:31.160018148 +0200
@@ -356,7 +356,7 @@
 {
 	char *boot_device = NULL;
 	char *ep;
-	int dev, part = 1, rcode;
+	int dev, part = 1;
 	ulong addr, cnt;
 	disk_partition_t info;
 	image_header_t *hdr;
@@ -490,16 +490,7 @@
 
 	flush_cache(addr, (cnt+1)*info.blksz);
 
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
-		char *local_args[2];
-		local_args[0] = argv[0];
-		local_args[1] = NULL;
-		printf("Automatic boot of image at addr 0x%08lX ...\n", addr);
-		rcode = do_bootm(cmdtp, 0, 1, local_args);
-		return rcode;
-	}
-	return 0;
+	return bootm_maybe_autostart(cmdtp, argv[0]);
 }
 #endif /* CONFIG_USB_STORAGE */
 
Index: u-boot-2011.06/common/cmd_version.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_version.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_version.c	2011-09-20 17:03:31.160018148 +0200
@@ -24,8 +24,9 @@
 #include <common.h>
 #include <command.h>
 #include <version.h>
+#include <linux/compiler.h>
 
-extern char version_string[];
+const char __weak version_string[] = U_BOOT_VERSION_STRING;
 
 int do_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
Index: u-boot-2011.06/common/cmd_ximg.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_ximg.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_ximg.c	2011-09-20 17:03:31.160018148 +0200
@@ -215,6 +215,7 @@
 			memmove ((char *) dest, (char *)data, len);
 #endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
 			break;
+#ifdef CONFIG_GZIP
 		case IH_COMP_GZIP:
 			printf ("   Uncompressing part %d ... ", part);
 			if (gunzip ((void *) dest, unc_len,
@@ -223,6 +224,7 @@
 				return 1;
 			}
 			break;
+#endif
 #if defined(CONFIG_BZIP2)
 		case IH_COMP_BZIP2:
 			{
Index: u-boot-2011.06/common/cmd_yaffs2.c
===================================================================
--- u-boot-2011.06.orig/common/cmd_yaffs2.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/cmd_yaffs2.c	2011-09-20 17:03:31.160018148 +0200
@@ -66,7 +66,7 @@
     ulong value = simple_strtoul(argv[2], NULL, 16);
     ulong numValues = simple_strtoul(argv[3], NULL, 16);
 
-    printf ("Writing value (%x) %x times to %s... ", value, numValues, filename);
+    printf ("Writing value (%lx) %lx times to %s... ", value, numValues, filename);
 
     cmd_yaffs_write_file(filename,value,numValues);
 
Index: u-boot-2011.06/common/command.c
===================================================================
--- u-boot-2011.06.orig/common/command.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/command.c	2011-09-20 17:03:31.160018148 +0200
@@ -140,7 +140,7 @@
 	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
 }
 
-int cmd_usage(cmd_tbl_t *cmdtp)
+int cmd_usage(const cmd_tbl_t *cmdtp)
 {
 	printf("%s - %s\n\n", cmdtp->name, cmdtp->usage);
 
Index: u-boot-2011.06/common/dlmalloc.c
===================================================================
--- u-boot-2011.06.orig/common/dlmalloc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/dlmalloc.c	2011-09-20 17:03:31.160018148 +0200
@@ -286,13 +286,6 @@
 
 */
 
-#ifdef DEBUG
-#include <assert.h>
-#else
-#define assert(x) ((void)0)
-#endif
-
-
 /*
   INTERNAL_SIZE_T is the word-size used for internal bookkeeping
   of chunk sizes. On a 64-bit machine, you can reduce malloc
@@ -1654,9 +1647,7 @@
 static void do_check_chunk(p) mchunkptr p;
 #endif
 {
-#if 0	/* causes warnings because assert() is off */
   INTERNAL_SIZE_T sz = p->size & ~PREV_INUSE;
-#endif	/* 0 */
 
   /* No checkable chunk is mmapped */
   assert(!chunk_is_mmapped(p));
@@ -1678,9 +1669,7 @@
 #endif
 {
   INTERNAL_SIZE_T sz = p->size & ~PREV_INUSE;
-#if 0	/* causes warnings because assert() is off */
   mchunkptr next = chunk_at_offset(p, sz);
-#endif	/* 0 */
 
   do_check_chunk(p);
 
@@ -1744,10 +1733,8 @@
 static void do_check_malloced_chunk(p, s) mchunkptr p; INTERNAL_SIZE_T s;
 #endif
 {
-#if 0	/* causes warnings because assert() is off */
   INTERNAL_SIZE_T sz = p->size & ~PREV_INUSE;
   long room = sz - s;
-#endif	/* 0 */
 
   do_check_inuse_chunk(p);
 
Index: u-boot-2011.06/common/env_common.c
===================================================================
--- u-boot-2011.06.orig/common/env_common.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/env_common.c	2011-09-20 17:03:31.160018148 +0200
@@ -47,7 +47,7 @@
 #define XMK_STR(x)	#x
 #define MK_STR(x)	XMK_STR(x)
 
-uchar default_environment[] = {
+const uchar default_environment[] = {
 #ifdef	CONFIG_BOOTARGS
 	"bootargs="	CONFIG_BOOTARGS			"\0"
 #endif
@@ -162,7 +162,7 @@
 	return (c);
 }
 
-uchar *env_get_addr (int index)
+const uchar *env_get_addr (int index)
 {
 	if (gd->env_valid)
 		return (uchar *)(gd->env_addr + index);
Index: u-boot-2011.06/common/env_embedded.c
===================================================================
--- u-boot-2011.06.orig/common/env_embedded.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/env_embedded.c	2011-09-20 17:03:31.160018148 +0200
@@ -44,7 +44,7 @@
  * Generate embedded environment table
  * inside U-Boot image, if needed.
  */
-#if defined(ENV_IS_EMBEDDED)
+#if defined(ENV_IS_EMBEDDED) || defined(CONFIG_BUILD_ENVCRC)
 /*
  * Only put the environment in it's own section when we are building
  * U-Boot proper.  The host based program "tools/envcrc" does not need
Index: u-boot-2011.06/common/env_flash.c
===================================================================
--- u-boot-2011.06.orig/common/env_flash.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/env_flash.c	2011-09-20 17:03:31.160018148 +0200
@@ -74,7 +74,7 @@
 static ulong end_addr_new = CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SECT_SIZE - 1;
 #endif /* CONFIG_ENV_ADDR_REDUND */
 
-extern uchar default_environment[];
+extern const uchar default_environment[];
 
 
 uchar env_get_char_spec(int index)
Index: u-boot-2011.06/common/fdt_support.c
===================================================================
--- u-boot-2011.06.orig/common/fdt_support.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/fdt_support.c	2011-09-20 17:03:31.160018148 +0200
@@ -1195,6 +1195,46 @@
 	return phandle + 1;
 }
 
+/*
+ * fdt_create_phandle: Create a phandle property for the given node
+ *
+ * @fdt: ptr to device tree
+ * @nodeoffset: node to update
+ * @phandle: phandle value to set (must be unique)
+*/
+int fdt_create_phandle(void *fdt, int nodeoffset, uint32_t phandle)
+{
+	int ret;
+
+#ifdef DEBUG
+	int off = fdt_node_offset_by_phandle(fdt, phandle);
+
+	if ((off >= 0) && (off != nodeoffset)) {
+		char buf[64];
+
+		fdt_get_path(fdt, nodeoffset, buf, sizeof(buf));
+		printf("Trying to update node %s with phandle %u ",
+		       buf, phandle);
+
+		fdt_get_path(fdt, off, buf, sizeof(buf));
+		printf("that already exists in node %s.\n", buf);
+		return -FDT_ERR_BADPHANDLE;
+	}
+#endif
+
+	ret = fdt_setprop_cell(fdt, nodeoffset, "phandle", phandle);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * For now, also set the deprecated "linux,phandle" property, so that we
+	 * don't break older kernels.
+	 */
+	ret = fdt_setprop_cell(fdt, nodeoffset, "linux,phandle", phandle);
+
+	return ret;
+}
+
 #if defined(CONFIG_VIDEO)
 int fdt_add_edid(void *blob, const char *compat, unsigned char *edid_buf)
 {
@@ -1223,3 +1263,70 @@
 	return ret;
 }
 #endif
+
+/*
+ * Verify the physical address of device tree node for a given alias
+ *
+ * This function locates the device tree node of a given alias, and then
+ * verifies that the physical address of that device matches the given
+ * parameter.  It displays a message if there is a mismatch.
+ *
+ * Returns 1 on success, 0 on failure
+ */
+int fdt_verify_alias_address(void *fdt, int anode, const char *alias, u64 addr)
+{
+	const char *path;
+	const u32 *reg;
+	int node, len;
+	u64 dt_addr;
+
+	path = fdt_getprop(fdt, anode, alias, NULL);
+	if (!path) {
+		/* If there's no such alias, then it's not a failure */
+		return 1;
+	}
+
+	node = fdt_path_offset(fdt, path);
+	if (node < 0) {
+		printf("Warning: device tree alias '%s' points to invalid "
+		       "node %s.\n", alias, path);
+		return 0;
+	}
+
+	reg = fdt_getprop(fdt, node, "reg", &len);
+	if (!reg) {
+		printf("Warning: device tree node '%s' has no address.\n",
+		       path);
+		return 0;
+	}
+
+	dt_addr = fdt_translate_address(fdt, node, reg);
+	if (addr != dt_addr) {
+		printf("Warning: U-Boot configured device %s at address %llx,\n"
+		       " but the device tree has it address %llx.\n",
+		       alias, addr, dt_addr);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * Returns the base address of an SOC or PCI node
+ */
+u64 fdt_get_base_address(void *fdt, int node)
+{
+	int size;
+	u32 naddr;
+	const u32 *prop;
+
+	prop = fdt_getprop(fdt, node, "#address-cells", &size);
+	if (prop && size == 4)
+		naddr = *prop;
+	else
+		naddr = 2;
+
+	prop = fdt_getprop(fdt, node, "ranges", &size);
+
+	return prop ? fdt_translate_address(fdt, node, prop + naddr) : 0;
+}
Index: u-boot-2011.06/common/image.c
===================================================================
--- u-boot-2011.06.orig/common/image.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/image.c	2011-09-20 17:03:31.160018148 +0200
@@ -130,17 +130,22 @@
 };
 
 static const table_entry_t uimage_type[] = {
-	{	IH_TYPE_INVALID,    NULL,	  "Invalid Image",	},
 	{	IH_TYPE_FILESYSTEM, "filesystem", "Filesystem Image",	},
 	{	IH_TYPE_FIRMWARE,   "firmware",	  "Firmware",		},
+	{	IH_TYPE_FLATDT,     "flat_dt",    "Flat Device Tree",	},
+	{	IH_TYPE_INVALID,    NULL,	  "Invalid Image",	},
+	{	IH_TYPE_IMXIMAGE,   "imximage",   "Freescale i.MX Boot Image",},
 	{	IH_TYPE_KERNEL,	    "kernel",	  "Kernel Image",	},
+	{	IH_TYPE_KWBIMAGE,   "kwbimage",   "Kirkwood Boot Image",},
 	{	IH_TYPE_MULTI,	    "multi",	  "Multi-File Image",	},
+	{	IH_TYPE_OMAPIMAGE,  "omapimage",  "TI OMAP SPL With GP CH",},
 	{	IH_TYPE_RAMDISK,    "ramdisk",	  "RAMDisk Image",	},
 	{	IH_TYPE_SCRIPT,     "script",	  "Script",		},
 	{	IH_TYPE_STANDALONE, "standalone", "Standalone Program", },
 	{	IH_TYPE_FLATDT,     "flat_dt",    "Flat Device Tree",	},
 	{	IH_TYPE_KWBIMAGE,   "kwbimage",   "Kirkwood Boot Image",},
 	{	IH_TYPE_IMXIMAGE,   "imximage",   "Freescale i.MX Boot Image",},
+	{	IH_TYPE_UBLIMAGE,   "ublimage",   "Davinci UBL image",},
 	{	-1,		    "",		  "",			},
 };
 
@@ -965,17 +970,6 @@
 			rd_data = rd_len = rd_load = 0;
 			return 1;
 		}
-
-#if defined(CONFIG_B2) || defined(CONFIG_EVB4510) || defined(CONFIG_ARMADILLO)
-		/*
-		 * We need to copy the ramdisk to SRAM to let Linux boot
-		 */
-		if (rd_data) {
-			memmove ((void *)rd_load, (uchar *)rd_data, rd_len);
-			rd_data = rd_load;
-		}
-#endif /* CONFIG_B2 || CONFIG_EVB4510 || CONFIG_ARMADILLO */
-
 	} else if (images->legacy_hdr_valid &&
 			image_check_type (&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
 		/*
@@ -1234,8 +1228,10 @@
 {
 	void	*fdt_blob = *of_flat_tree;
 	void	*of_start = 0;
+	char	*fdt_high;
 	ulong	of_len = 0;
 	int	err;
+	int	disable_relocation = 0;
 
 	/* nothing to do */
 	if (*of_size == 0)
@@ -1249,26 +1245,62 @@
 	/* position on a 4K boundary before the alloc_current */
 	/* Pad the FDT by a specified amount */
 	of_len = *of_size + CONFIG_SYS_FDT_PAD;
-	of_start = (void *)(unsigned long)lmb_alloc_base(lmb, of_len, 0x1000,
-			getenv_bootm_mapsize() + getenv_bootm_low());
+
+	/* If fdt_high is set use it to select the relocation address */
+	fdt_high = getenv("fdt_high");
+	if (fdt_high) {
+		void *desired_addr = (void *)simple_strtoul(fdt_high, NULL, 16);
+
+		if (((ulong) desired_addr) == ~0UL) {
+			/* All ones means use fdt in place */
+			desired_addr = fdt_blob;
+			disable_relocation = 1;
+		}
+		if (desired_addr) {
+			of_start =
+			    (void *)(ulong) lmb_alloc_base(lmb, of_len, 0x1000,
+							   ((ulong)
+							    desired_addr)
+							   + of_len);
+			if (desired_addr && of_start != desired_addr) {
+				puts("Failed using fdt_high value for Device Tree");
+				goto error;
+			}
+		} else {
+			of_start =
+			    (void *)(ulong) lmb_alloc(lmb, of_len, 0x1000);
+		}
+	} else {
+		of_start =
+		    (void *)(ulong) lmb_alloc_base(lmb, of_len, 0x1000,
+						   getenv_bootm_mapsize()
+						   + getenv_bootm_low());
+	}
 
 	if (of_start == 0) {
 		puts("device tree - allocation error\n");
 		goto error;
 	}
 
-	debug ("## device tree at %p ... %p (len=%ld [0x%lX])\n",
-		fdt_blob, fdt_blob + *of_size - 1, of_len, of_len);
+	if (disable_relocation) {
+		/* We assume there is space after the existing fdt to use for padding */
+		fdt_set_totalsize(of_start, of_len);
+		printf("   Using Device Tree in place at %p, end %p\n",
+		       of_start, of_start + of_len - 1);
+	} else {
+		debug ("## device tree at %p ... %p (len=%ld [0x%lX])\n",
+			fdt_blob, fdt_blob + *of_size - 1, of_len, of_len);
 
-	printf ("   Loading Device Tree to %p, end %p ... ",
-		of_start, of_start + of_len - 1);
+		printf ("   Loading Device Tree to %p, end %p ... ",
+			of_start, of_start + of_len - 1);
 
-	err = fdt_open_into (fdt_blob, of_start, of_len);
-	if (err != 0) {
-		fdt_error ("fdt move failed");
-		goto error;
+		err = fdt_open_into (fdt_blob, of_start, of_len);
+		if (err != 0) {
+			fdt_error ("fdt move failed");
+			goto error;
+		}
+		puts ("OK\n");
 	}
-	puts ("OK\n");
 
 	*of_flat_tree = of_start;
 	*of_size = of_len;
Index: u-boot-2011.06/common/main.c
===================================================================
--- u-boot-2011.06.orig/common/main.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/main.c	2011-09-20 17:03:31.160018148 +0200
@@ -30,6 +30,7 @@
 #include <common.h>
 #include <watchdog.h>
 #include <command.h>
+#include <version.h>
 #ifdef CONFIG_MODEM_SUPPORT
 #include <malloc.h>		/* for free() prototype */
 #endif
@@ -51,15 +52,11 @@
 void show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progress")));
 
 #if defined(CONFIG_UPDATE_TFTP)
-void update_tftp (void);
+int update_tftp (ulong addr);
 #endif /* CONFIG_UPDATE_TFTP */
 
 #define MAX_DELAY_STOP_STR 32
 
-#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
-static int abortboot(int);
-#endif
-
 #undef DEBUG_PARSER
 
 char        console_buffer[CONFIG_SYS_CBSIZE + 1];	/* console I/O buffer	*/
@@ -91,7 +88,7 @@
  */
 #if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
 # if defined(CONFIG_AUTOBOOT_KEYED)
-static __inline__ int abortboot(int bootdelay)
+static inline int abortboot(int bootdelay)
 {
 	int abort = 0;
 	uint64_t etime = endtick(bootdelay);
@@ -205,7 +202,7 @@
 static int menukey = 0;
 #endif
 
-static __inline__ int abortboot(int bootdelay)
+static inline int abortboot(int bootdelay)
 {
 	int abort = 0;
 
@@ -311,8 +308,6 @@
 
 #ifdef CONFIG_VERSION_VARIABLE
 	{
-		extern char version_string[];
-
 		setenv ("ver", version_string);  /* set version variable */
 	}
 #endif /* CONFIG_VERSION_VARIABLE */
@@ -345,7 +340,7 @@
 #endif /* CONFIG_PREBOOT */
 
 #if defined(CONFIG_UPDATE_TFTP)
-	update_tftp ();
+	update_tftp (0UL);
 #endif /* CONFIG_UPDATE_TFTP */
 
 #if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
@@ -395,15 +390,15 @@
 
 # ifdef CONFIG_MENUKEY
 	if (menukey == CONFIG_MENUKEY) {
-	    s = getenv("menucmd");
-	    if (s) {
+		s = getenv("menucmd");
+		if (s) {
 # ifndef CONFIG_SYS_HUSH_PARSER
-		run_command (s, 0);
+			run_command(s, 0);
 # else
-		parse_string_outer(s, FLAG_PARSE_SEMICOLON |
-				    FLAG_EXIT_FROM_LOOP);
+			parse_string_outer(s, FLAG_PARSE_SEMICOLON |
+						FLAG_EXIT_FROM_LOOP);
 # endif
-	    }
+		}
 	}
 #endif /* CONFIG_MENUKEY */
 #endif /* CONFIG_BOOTDELAY */
Index: u-boot-2011.06/common/Makefile
===================================================================
--- u-boot-2011.06.orig/common/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/Makefile	2011-09-20 17:03:31.160018148 +0200
@@ -26,17 +26,15 @@
 LIB	= $(obj)libcommon.o
 
 # core
+ifndef CONFIG_SPL_BUILD
 COBJS-y += main.o
-COBJS-y += console.o
 COBJS-y += command.o
 COBJS-y += dlmalloc.o
 COBJS-y += exports.o
 COBJS-$(CONFIG_SYS_HUSH_PARSER) += hush.o
 COBJS-y += image.o
-COBJS-y += memsize.o
 COBJS-y += s_record.o
 COBJS-$(CONFIG_SERIAL_MULTI) += serial.o
-COBJS-y += stdio.o
 COBJS-y += xyzModem.o
 
 # core command
@@ -94,6 +92,7 @@
 COBJS-$(CONFIG_CMD_FDC)$(CONFIG_CMD_FDOS) += cmd_fdc.o
 COBJS-$(CONFIG_OF_LIBFDT) += cmd_fdt.o fdt_support.o
 COBJS-$(CONFIG_CMD_FDOS) += cmd_fdos.o
+COBJS-$(CONFIG_CMD_FITUPD) += cmd_fitupd.o
 COBJS-$(CONFIG_CMD_FLASH) += cmd_flash.o
 ifdef CONFIG_FPGA
 COBJS-$(CONFIG_CMD_FPGA) += cmd_fpga.o
@@ -107,6 +106,7 @@
 COBJS-$(CONFIG_CMD_JFFS2) += cmd_jffs2.o
 COBJS-$(CONFIG_CMD_CRAMFS) += cmd_cramfs.o
 COBJS-$(CONFIG_CMD_LDRINFO) += cmd_ldrinfo.o
+COBJS-$(CONFIG_CMD_LED) += cmd_led.o
 COBJS-$(CONFIG_CMD_LICENSE) += cmd_license.o
 COBJS-y += cmd_load.o
 COBJS-$(CONFIG_LOGBUFFER) += cmd_log.o
@@ -173,6 +173,11 @@
 COBJS-$(CONFIG_MODEM_SUPPORT) += modem.o
 COBJS-$(CONFIG_UPDATE_TFTP) += update.o
 COBJS-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
+endif
+
+COBJS-y += console.o
+COBJS-y += memsize.o
+COBJS-y += stdio.o
 
 
 COBJS	:= $(sort $(COBJS-y))
Index: u-boot-2011.06/common/memsize.c
===================================================================
--- u-boot-2011.06.orig/common/memsize.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/memsize.c	2011-09-20 17:03:31.160018148 +0200
@@ -37,7 +37,7 @@
  * the actually available RAM size between addresses `base' and
  * `base + maxsize'.
  */
-long get_ram_size(volatile long *base, long maxsize)
+long get_ram_size(long *base, long maxsize)
 {
 	volatile long *addr;
 	long           save[32];
Index: u-boot-2011.06/common/miiphyutil.c
===================================================================
--- u-boot-2011.06.orig/common/miiphyutil.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/miiphyutil.c	2011-09-20 17:03:31.160018148 +0200
@@ -111,7 +111,8 @@
 {
 	struct mii_dev *new_dev;
 	struct legacy_mii_dev *ldev;
-	unsigned int name_len;
+
+	BUG_ON(strlen(name) >= MDIO_NAME_LEN);
 
 	/* check if we have unique name */
 	new_dev = miiphy_get_dev_by_name(name);
@@ -121,14 +122,6 @@
 	}
 
 	/* allocate memory */
-	name_len = strlen(name);
-	if (name_len > MDIO_NAME_LEN - 1) {
-		/* Hopefully this won't happen, but if it does, we'll know */
-		printf("miiphy_register: MDIO name was longer than %d\n",
-			MDIO_NAME_LEN);
-		return;
-	}
-
 	new_dev = mdio_alloc();
 	ldev = malloc(sizeof(*ldev));
 
@@ -141,7 +134,8 @@
 	/* initalize mii_dev struct fields */
 	new_dev->read = legacy_miiphy_read;
 	new_dev->write = legacy_miiphy_write;
-	sprintf(new_dev->name, name);
+	strncpy(new_dev->name, name, MDIO_NAME_LEN);
+	new_dev->name[MDIO_NAME_LEN - 1] = 0;
 	ldev->read = read;
 	ldev->write = write;
 	new_dev->priv = ldev;
Index: u-boot-2011.06/common/serial.c
===================================================================
--- u-boot-2011.06.orig/common/serial.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/serial.c	2011-09-20 17:03:31.160018148 +0200
@@ -24,81 +24,15 @@
 #include <common.h>
 #include <serial.h>
 #include <stdio_dev.h>
+#include <post.h>
+#include <linux/compiler.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
 static struct serial_device *serial_devices = NULL;
 static struct serial_device *serial_current = NULL;
 
-#if !defined(CONFIG_LWMON) && !defined(CONFIG_PXA250) && !defined(CONFIG_PXA27X)
-struct serial_device *__default_serial_console (void)
-{
-#if defined(CONFIG_8xx_CONS_SMC1) || defined(CONFIG_8xx_CONS_SMC2)
-	return &serial_smc_device;
-#elif defined(CONFIG_8xx_CONS_SCC1) || defined(CONFIG_8xx_CONS_SCC2) \
-   || defined(CONFIG_8xx_CONS_SCC3) || defined(CONFIG_8xx_CONS_SCC4)
-	return &serial_scc_device;
-#elif defined(CONFIG_4xx) \
-   || defined(CONFIG_MB86R0x) || defined(CONFIG_MPC5xxx) \
-   || defined(CONFIG_MPC83xx) || defined(CONFIG_MPC85xx) \
-   || defined(CONFIG_MPC86xx) || defined(CONFIG_SYS_SC520) \
-   || defined(CONFIG_TEGRA2)
-#if defined(CONFIG_CONS_INDEX) && defined(CONFIG_SYS_NS16550_SERIAL)
-#if (CONFIG_CONS_INDEX==1)
-	return &eserial1_device;
-#elif (CONFIG_CONS_INDEX==2)
-	return &eserial2_device;
-#elif (CONFIG_CONS_INDEX==3)
-	return &eserial3_device;
-#elif (CONFIG_CONS_INDEX==4)
-	return &eserial4_device;
-#else
-#error "Bad CONFIG_CONS_INDEX."
-#endif
-#else
-	return &serial0_device;
-#endif
-#elif defined(CONFIG_MPC512X)
-#if (CONFIG_PSC_CONSOLE == 3)
-		return &serial3_device;
-#elif (CONFIG_PSC_CONSOLE == 6)
-		return &serial6_device;
-#else
-#error "Bad CONFIG_PSC_CONSOLE."
-#endif
-#elif defined(CONFIG_S3C2410)
-#if defined(CONFIG_SERIAL1)
-	return &s3c24xx_serial0_device;
-#elif defined(CONFIG_SERIAL2)
-	return &s3c24xx_serial1_device;
-#elif defined(CONFIG_SERIAL3)
-	return &s3c24xx_serial2_device;
-#else
-#error "CONFIG_SERIAL? missing."
-#endif
-#elif defined(CONFIG_S5P)
-#if defined(CONFIG_SERIAL0)
-	return &s5p_serial0_device;
-#elif defined(CONFIG_SERIAL1)
-	return &s5p_serial1_device;
-#elif defined(CONFIG_SERIAL2)
-	return &s5p_serial2_device;
-#elif defined(CONFIG_SERIAL3)
-	return &s5p_serial3_device;
-#else
-#error "CONFIG_SERIAL? missing."
-#endif
-#elif defined(CONFIG_OMAP3_ZOOM2)
-		return ZOOM2_DEFAULT_SERIAL_DEVICE;
-#else
-#error No default console
-#endif
-}
-
-struct serial_device *default_serial_console(void) __attribute__((weak, alias("__default_serial_console")));
-#endif
-
-int serial_register (struct serial_device *dev)
+void serial_register(struct serial_device *dev)
 {
 #ifdef CONFIG_NEEDS_MANUAL_RELOC
 	dev->init += gd->reloc_off;
@@ -111,8 +45,6 @@
 
 	dev->next = serial_devices;
 	serial_devices = dev;
-
-	return 0;
 }
 
 void serial_initialize (void)
@@ -173,6 +105,9 @@
 	serial_register(&serial6_device);
 #endif
 #endif
+#if defined(CONFIG_SYS_BFIN_UART)
+	serial_register_bfin_uart();
+#endif
 	serial_assign (default_serial_console ()->name);
 }
 
@@ -291,3 +226,91 @@
 
 	serial_current->puts (s);
 }
+
+#if CONFIG_POST & CONFIG_SYS_POST_UART
+static const int bauds[] = CONFIG_SYS_BAUDRATE_TABLE;
+
+/* Mark weak until post/cpu/.../uart.c migrate over */
+__weak
+int uart_post_test(int flags)
+{
+	unsigned char c;
+	int ret, saved_baud, b;
+	struct serial_device *saved_dev, *s;
+	bd_t *bd = gd->bd;
+
+	/* Save current serial state */
+	ret = 0;
+	saved_dev = serial_current;
+	saved_baud = bd->bi_baudrate;
+
+	for (s = serial_devices; s; s = s->next) {
+		/* If this driver doesn't support loop back, skip it */
+		if (!s->loop)
+			continue;
+
+		/* Test the next device */
+		serial_current = s;
+
+		ret = serial_init();
+		if (ret)
+			goto done;
+
+		/* Consume anything that happens to be queued */
+		while (serial_tstc())
+			serial_getc();
+
+		/* Enable loop back */
+		s->loop(1);
+
+		/* Test every available baud rate */
+		for (b = 0; b < ARRAY_SIZE(bauds); ++b) {
+			bd->bi_baudrate = bauds[b];
+			serial_setbrg();
+
+			/*
+			 * Stick to printable chars to avoid issues:
+			 *  - terminal corruption
+			 *  - serial program reacting to sequences and sending
+			 *    back random extra data
+			 *  - most serial drivers add in extra chars (like \r\n)
+			 */
+			for (c = 0x20; c < 0x7f; ++c) {
+				/* Send it out */
+				serial_putc(c);
+
+				/* Make sure it's the same one */
+				ret = (c != serial_getc());
+				if (ret) {
+					s->loop(0);
+					goto done;
+				}
+
+				/* Clean up the output in case it was sent */
+				serial_putc('\b');
+				ret = ('\b' != serial_getc());
+				if (ret) {
+					s->loop(0);
+					goto done;
+				}
+			}
+		}
+
+		/* Disable loop back */
+		s->loop(0);
+
+		/* XXX: There is no serial_uninit() !? */
+		if (s->uninit)
+			s->uninit();
+	}
+
+ done:
+	/* Restore previous serial state */
+	serial_current = saved_dev;
+	bd->bi_baudrate = saved_baud;
+	serial_reinit_all();
+	serial_setbrg();
+
+	return ret;
+}
+#endif
Index: u-boot-2011.06/common/stdio.c
===================================================================
--- u-boot-2011.06.orig/common/stdio.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/stdio.c	2011-09-20 17:03:31.160018148 +0200
@@ -160,7 +160,7 @@
 	int l;
 	struct list_head *pos;
 	struct stdio_dev *dev;
-	char temp_names[3][8];
+	char temp_names[3][16];
 
 	dev = stdio_get_by_name(devname);
 
@@ -174,7 +174,7 @@
 		}
 		memcpy (&temp_names[l][0],
 			stdio_devices[l]->name,
-			sizeof(stdio_devices[l]->name));
+			sizeof(temp_names[l]));
 	}
 
 	list_del(&(dev->list));
Index: u-boot-2011.06/common/update.c
===================================================================
--- u-boot-2011.06.orig/common/update.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/update.c	2011-09-20 17:03:31.160018148 +0200
@@ -238,13 +238,17 @@
 	return 0;
 }
 
-void update_tftp(void)
+int update_tftp(ulong addr)
 {
 	char *filename, *env_addr;
 	int images_noffset, ndepth, noffset;
 	ulong update_addr, update_fladdr, update_size;
-	ulong addr;
 	void *fit;
+	int ret = 0;
+
+	/* use already present image */
+	if (addr)
+		goto got_update_file;
 
 	printf("Auto-update from TFTP: ");
 
@@ -253,7 +257,7 @@
 	if (filename == NULL) {
 		printf("failed, env. variable '%s' not found\n",
 							UPDATE_FILE_ENV);
-		return;
+		return 1;
 	}
 
 	printf("trying update file '%s'\n", filename);
@@ -268,15 +272,16 @@
 	if (update_load(filename, CONFIG_UPDATE_TFTP_MSEC_MAX,
 					CONFIG_UPDATE_TFTP_CNT_MAX, addr)) {
 		printf("Can't load update file, aborting auto-update\n");
-		return;
+		return 1;
 	}
 
+got_update_file:
 	fit = (void *)addr;
 
 	if (!fit_check_format((void *)fit)) {
 		printf("Bad FIT format of the update file, aborting "
 							"auto-update\n");
-		return;
+		return 1;
 	}
 
 	/* process updates */
@@ -293,6 +298,7 @@
 
 		if (!fit_image_check_hashes(fit, noffset)) {
 			printf("Error: invalid update hash, aborting\n");
+			ret = 1;
 			goto next_node;
 		}
 
@@ -301,15 +307,17 @@
 					&update_fladdr, &update_size)) {
 			printf("Error: can't get update parameteres, "
 								"aborting\n");
+			ret = 1;
 			goto next_node;
 		}
 		if (update_flash(update_addr, update_fladdr, update_size)) {
 			printf("Error: can't flash update, aborting\n");
+			ret = 1;
 			goto next_node;
 		}
 next_node:
 		noffset = fdt_next_node(fit, noffset, &ndepth);
 	}
 
-	return;
+	return ret;
 }
Index: u-boot-2011.06/common/usb.c
===================================================================
--- u-boot-2011.06.orig/common/usb.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/usb.c	2011-09-20 17:03:31.160018148 +0200
@@ -957,8 +957,8 @@
 	/* insert "driver" if possible */
 #ifdef CONFIG_USB_KEYBOARD
 	drv_usb_kbd_init();
-	USB_PRINTF("scan end\n");
 #endif
+	USB_PRINTF("scan end\n");
 }
 
 
@@ -1166,6 +1166,7 @@
 
 	dev->children[port] = usb;
 	usb->parent = dev;
+	usb->portnr = port + 1;
 	/* Run it through the hoops (find a driver, etc) */
 	if (usb_new_device(usb)) {
 		/* Woops, disable the port */
Index: u-boot-2011.06/common/usb_storage.c
===================================================================
--- u-boot-2011.06.orig/common/usb_storage.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/usb_storage.c	2011-09-20 17:03:31.160018148 +0200
@@ -173,11 +173,12 @@
 struct usb_device * usb_get_dev_index(int index);
 void uhci_show_temp_int_td(void);
 
+#ifdef CONFIG_PARTITIONS
 block_dev_desc_t *usb_stor_get_dev(int index)
 {
 	return (index < usb_max_devs) ? &usb_dev_desc[index] : NULL;
 }
-
+#endif
 
 void usb_show_progress(void)
 {
Index: u-boot-2011.06/common/xyzModem.c
===================================================================
--- u-boot-2011.06.orig/common/xyzModem.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/common/xyzModem.c	2011-09-20 17:03:31.160018148 +0200
@@ -786,7 +786,7 @@
       ZM_DEBUG (zm_dprintf ("Engaging cleanup mode...\n"));
       /*
        * Consume any trailing crap left in the inbuffer from
-       * previous recieved blocks. Since very few files are an exact multiple
+       * previous received blocks. Since very few files are an exact multiple
        * of the transfer block size, there will almost always be some gunk here.
        * If we don't eat it now, RedBoot will think the user typed it.
        */
Index: u-boot-2011.06/config.mk
===================================================================
--- u-boot-2011.06.orig/config.mk	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/config.mk	2011-09-20 17:03:31.170018148 +0200
@@ -23,19 +23,31 @@
 
 #########################################################################
 
-ifneq ($(OBJTREE),$(SRCTREE))
 ifeq ($(CURDIR),$(SRCTREE))
 dir :=
 else
 dir := $(subst $(SRCTREE)/,,$(CURDIR))
 endif
 
+ifneq ($(OBJTREE),$(SRCTREE))
+# Create object files for SPL in a separate directory
+ifeq ($(CONFIG_SPL_BUILD),y)
+obj := $(if $(dir),$(SPLTREE)/$(dir)/,$(SPLTREE)/)
+else
 obj := $(if $(dir),$(OBJTREE)/$(dir)/,$(OBJTREE)/)
+endif
 src := $(if $(dir),$(SRCTREE)/$(dir)/,$(SRCTREE)/)
 
 $(shell mkdir -p $(obj))
 else
+# Create object files for SPL in a separate directory
+ifeq ($(CONFIG_SPL_BUILD),y)
+obj := $(if $(dir),$(SPLTREE)/$(dir)/,$(SPLTREE)/)
+
+$(shell mkdir -p $(obj))
+else
 obj :=
+endif
 src :=
 endif
 
@@ -160,10 +172,25 @@
 
 CPPFLAGS := $(DBGFLAGS) $(OPTFLAGS) $(RELFLAGS)		\
 	-D__KERNEL__
+
+# Enable garbage collection of un-used sections for SPL
+ifeq ($(CONFIG_SPL_BUILD),y)
+CPPFLAGS += -ffunction-sections -fdata-sections
+LDFLAGS_FINAL += --gc-sections
+endif
+
 ifneq ($(CONFIG_SYS_TEXT_BASE),)
 CPPFLAGS += -DCONFIG_SYS_TEXT_BASE=$(CONFIG_SYS_TEXT_BASE)
 endif
 
+ifneq ($(CONFIG_SPL_TEXT_BASE),)
+CPPFLAGS += -DCONFIG_SPL_TEXT_BASE=$(CONFIG_SPL_TEXT_BASE)
+endif
+
+ifeq ($(CONFIG_SPL_BUILD),y)
+CPPFLAGS += -DCONFIG_SPL_BUILD
+endif
+
 ifneq ($(RESET_VECTOR_ADDRESS),)
 CPPFLAGS += -DRESET_VECTOR_ADDRESS=$(RESET_VECTOR_ADDRESS)
 endif
@@ -184,6 +211,10 @@
 endif
 
 CFLAGS += $(call cc-option,-fno-stack-protector)
+# Some toolchains enable security related warning flags by default,
+# but they don't make much sense in the u-boot world, so disable them.
+CFLAGS += $(call cc-option,-Wno-format-nonliteral)
+CFLAGS += $(call cc-option,-Wno-format-security)
 
 # $(CPPFLAGS) sets -g, which causes gcc to pass a suitable -g<format>
 # option to the assembler.
@@ -206,6 +237,11 @@
 LDFLAGS_u-boot += -Ttext $(CONFIG_SYS_TEXT_BASE)
 endif
 
+LDFLAGS_u-boot-spl += -T $(obj)u-boot-spl.lds $(LDFLAGS_FINAL)
+ifneq ($(CONFIG_SPL_TEXT_BASE),)
+LDFLAGS_u-boot-spl += -Ttext $(CONFIG_SPL_TEXT_BASE)
+endif
+
 # Location of a usable BFD library, where we define "usable" as
 # "built for ${HOST}, supports ${TARGET}".  Sensible values are
 # - When cross-compiling: the root of the cross-environment
Index: u-boot-2011.06/CREDITS
===================================================================
--- u-boot-2011.06.orig/CREDITS	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/CREDITS	2011-09-20 17:03:31.170018148 +0200
@@ -82,7 +82,6 @@
 N: Curt Brune
 E: curt@cucy.com
 D: Added support for Samsung S3C4510B CPU (ARM7tdmi based SoC)
-D: Added support for ESPD-Inc. EVB4510 Board
 W: http://www.cucy.com
 
 N: Jonathan De Bruyne
@@ -134,11 +133,6 @@
 E: DGE@sixnetio.com
 D: EEPROM Speedup, SXNI855T port
 
-N: Thomas Elste
-E: info@elste.org
-D: Port for the ModNET50 Board, NET+50 CPU Port
-W: http://www.imms.de
-
 N: Daniel Engstr?m
 E: daniel@omicron.se
 D: x86 port, Support for sc520_cdp board
@@ -161,11 +155,6 @@
 E: ThomasF@hyperion-entertainment.com
 D: Support for AmigaOne
 
-N: Niklaus Giger
-E: niklaus.giger@netstal.com
-D: Support for HCU(x) boards
-W: www.netstal.com
-
 N: Paul Gortmaker
 E: paul.gortmaker@windriver.com
 D: Support for WRS SBC8347/8349 boards
Index: u-boot-2011.06/disk/Makefile
===================================================================
--- u-boot-2011.06.orig/disk/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/disk/Makefile	2011-09-20 17:03:31.170018148 +0200
@@ -27,7 +27,7 @@
 
 LIB	= $(obj)libdisk.o
 
-COBJS-y += part.o
+COBJS-$(CONFIG_PARTITIONS) 	+= part.o
 COBJS-$(CONFIG_MAC_PARTITION)   += part_mac.o
 COBJS-$(CONFIG_DOS_PARTITION)   += part_dos.o
 COBJS-$(CONFIG_ISO_PARTITION)   += part_iso.o
Index: u-boot-2011.06/disk/part_dos.c
===================================================================
--- u-boot-2011.06.orig/disk/part_dos.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/disk/part_dos.c	2011-09-20 17:03:31.170018148 +0200
@@ -87,7 +87,7 @@
 
 int test_part_dos (block_dev_desc_t *dev_desc)
 {
-	unsigned char buffer[DEFAULT_SECTOR_SIZE];
+	unsigned char buffer[dev_desc->blksz];
 
 	if ((dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1) ||
 	    (buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
@@ -102,7 +102,7 @@
 static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
 							   int part_num)
 {
-	unsigned char buffer[DEFAULT_SECTOR_SIZE];
+	unsigned char buffer[dev_desc->blksz];
 	dos_partition_t *pt;
 	int i;
 
@@ -166,7 +166,7 @@
 				 int relative, int part_num,
 				 int which_part, disk_partition_t *info)
 {
-	unsigned char buffer[DEFAULT_SECTOR_SIZE];
+	unsigned char buffer[dev_desc->blksz];
 	dos_partition_t *pt;
 	int i;
 
Index: u-boot-2011.06/disk/part_dos.h
===================================================================
--- u-boot-2011.06.orig/disk/part_dos.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/disk/part_dos.h	2011-09-20 17:03:31.170018148 +0200
@@ -25,13 +25,6 @@
 #define _DISK_PART_DOS_H
 
 
-#ifdef CONFIG_ISO_PARTITION
-/* Make the buffers bigger if ISO partition support is enabled -- CD-ROMS
-   have 2048 byte blocks */
-#define DEFAULT_SECTOR_SIZE	2048
-#else
-#define DEFAULT_SECTOR_SIZE	512
-#endif
 #define DOS_PART_TBL_OFFSET	0x1be
 #define DOS_PART_MAGIC_OFFSET	0x1fe
 #define DOS_PBR_FSTYPE_OFFSET	0x36
Index: u-boot-2011.06/doc/README.arm-caches
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/doc/README.arm-caches	2011-09-20 17:03:31.170018148 +0200
@@ -0,0 +1,51 @@
+Disabling I-cache:
+- Set CONFIG_SYS_ICACHE_OFF
+
+Disabling D-cache:
+- Set CONFIG_SYS_DCACHE_OFF
+
+Enabling I-cache:
+- Make sure CONFIG_SYS_ICACHE_OFF is not set and call icache_enable().
+
+Enabling D-cache:
+- Make sure CONFIG_SYS_DCACHE_OFF is not set and call dcache_enable().
+
+Enabling Caches at System Startup:
+- Implement enable_caches() for your platform and enable the I-cache and
+  D-cache from this function. This function is called immediately
+  after relocation.
+
+Guidelines for Working with D-cache:
+
+Memory to Peripheral DMA:
+- Flush the buffer after the MPU writes the data and before the DMA is
+  initiated.
+
+Peripheral to Memory DMA:
+- Invalidate the buffer before starting the DMA. In case there are any dirty
+  lines from the DMA buffer in the cache, subsequent cache-line replacements
+  may corrupt the buffer in memory while the DMA is still going on. Cache-line
+  replacement can happen if the CPU tries to bring some other memory locations
+  into the cache while the DMA is going on.
+- Invalidate the buffer after the DMA is complete and before the MPU reads
+  it. This may be needed in addition to the invalidation before the DMA
+  mentioned above, because in some processors memory contents can spontaneously
+  come to the cache due to speculative memory access by the CPU. If this
+  happens with the DMA buffer while DMA is going on we have a coherency problem.
+
+Buffer Requirements:
+- Any buffer that is invalidated(that is, typically the peripheral to
+  memory DMA buffer) should be aligned to cache-line boundary both at
+  at the beginning and at the end of the buffer.
+- If the buffer is not cache-line aligned invalidation will be restricted
+  to the aligned part. That is, one cache-line at the respective boundary
+  may be left out while doing invalidation.
+
+Cleanup Before Linux:
+- cleanup_before_linux() should flush the D-cache, invalidate I-cache, and
+  disable MMU and caches.
+- The following sequence is advisable while disabling d-cache:
+  1. disable_dcache() - flushes and disables d-cache
+  2. invalidate_dcache_all() - invalid any entry that came to the cache
+	in the short period after the cache was flushed but before the
+	cache got disabled.
Index: u-boot-2011.06/doc/README.nand
===================================================================
--- u-boot-2011.06.orig/doc/README.nand	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/doc/README.nand	2011-09-20 17:03:31.170018148 +0200
@@ -78,6 +78,16 @@
       should work well, but loading an image copied from another flash is
       going to be trouble if there are any bad blocks.
 
+   nand write.trimffs addr ofs|partition size
+      Enabled by the CONFIG_CMD_NAND_TRIMFFS macro. This command will write to
+      the NAND flash in a manner identical to the 'nand write' command
+      described above -- with the additional check that all pages at the end
+      of eraseblocks which contain only 0xff data will not be written to the
+      NAND flash. This behaviour is required when flashing UBI images
+      containing UBIFS volumes as per the UBI FAQ[1].
+
+      [1] http://www.linux-mtd.infradead.org/doc/ubi.html#L_flasher_algo
+
    nand write.oob addr ofs|partition size
       Write `size' bytes from `addr' to the out-of-band data area
       corresponding to `ofs' in NAND flash. This is limited to the 16 bytes
Index: u-boot-2011.06/doc/README.ublimage
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/doc/README.ublimage	2011-09-20 17:03:31.170018148 +0200
@@ -0,0 +1,141 @@
+---------------------------------------------
+UBL image Boot Image generation using mkimage
+---------------------------------------------
+
+This document describes how to set up an U-Boot image that can be directly
+booted by a DaVinci processor via NAND boot mode, using an UBL header,
+but without need for UBL.
+
+For more details see section 11.2 "ARM ROM Boot Modes" of
+http://focus.ti.com/lit/ug/sprufg5a/sprufg5a.pdf
+
+Command syntax:
+--------------
+./tools/mkimage -l <u-boot_file>
+		to list the UBL image file details
+
+./tools/mkimage -T ublimage \
+		-n <board specific configuration file> \
+		-d <u-boot binary>  <output image file>
+
+For example, for the davinci dm365evm board:
+./tools/mkimage -n ./board/davinci/dm365evm/ublimage.cfg \
+		-T ublimage \
+		-d u-boot-nand.bin u-boot.ubl
+
+You can generate the image directly when you compile u-boot with:
+
+$ make u-boot.ubl
+
+The output image can be flashed into the NAND.
+
+Please check the DaVinci documentation for further details.
+
+Board specific configuration file specifications:
+-------------------------------------------------
+1. This file must present in the $(BOARDDIR) and the name should be
+	ublimage.cfg (since this is used in Makefile).
+2. This file can have empty lines and lines starting with "#" as first
+	character to put comments.
+3. This file can have configuration command lines as mentioned below,
+	any other information in this file is treated as invalid.
+
+Configuration command line syntax:
+---------------------------------
+1. Each command line must have two strings, first one command or address
+	and second one data string
+2. Following are the valid command strings and associated data strings:-
+	Command string		data string
+	--------------		-----------
+	MODE			UBL special mode, on of:
+				safe
+				Example:
+				MODE	safe
+
+	ENTRY			Entry point address for the user
+				bootloader (absolute address) = TEXT_BASE
+				nand_spl loader.
+				Example:
+				ENTRY	0x00000020
+
+	PAGES			Number of pages (size of user bootloader
+				in number of pages)
+				Example:
+				PAGES	27
+
+	START_BLOCK		Block number where user bootloader is present
+				Example:
+				START_BLOCK	5
+
+	START_PAGE		Page number where user bootloader is present
+				(for RBL always 0)
+				Example:
+				START_PAGE	0
+
+------------------------------------------------
+
+Structure of the u-boot.ubl binary:
+
+compile steps:
+
+1) nand_spl code compile, with pad_to = (TEXT_BASE +
+   (CONFIG_SYS_NROF_PAGES_NAND_SPL * pagesize))
+   Example: cam_enc_4xx pad_to = 0x20 + (6 * 0x800) = 0x3020 = 12320
+   -> u-boot-spl-16k.bin
+
+   !! TEXT_BASE = 0x20, as the RBL starts at 0x20
+
+2) compile u-boot.bin ("normal" u-boot)
+   -> u-boot.bin
+
+3) create u-boot-nand.bin = u-boot-spl-16k.bin + u-boot.bin
+
+4) create u-boot.ubl, size = 1 page size NAND
+   create UBL header and paste it before u-boot.bin
+
+This steps are done automagically if you do a "make all"
+
+-> You get an u-boot.ubl binary, which you can flash
+   into your NAND.
+
+Structure of this binary (Example for the cam_enc_4xx board with a NAND
+page size = 0x800):
+
+offset :    0x00000 | 0x800	  | 0x3800
+content:    UBL     | nand_spl	  | u-boot code
+	    Header  | code	  |
+
+The NAND layout looks for example like this:
+
+(Example for the cam_enc_4xx board with a NAND page size = 0x800, block
+size = 0x20000 and CONFIG_SYS_NROF_UBL_HEADER 5):
+
+offset :    0x80000 | 0xa0000	  | 0xa3000
+content:    UBL     | nand_spl	  | u-boot code
+	    Header  | code	  |
+	    ^	      ^
+	    ^	      0xa0000 = CONFIG_SYS_NROF_UBL_HEADER * 0x20000
+	    ^
+	    0x80000 = Block 4 * 0x20000
+
+If the cpu starts in NAND boot mode, it checks the UBL descriptor
+starting with block 1 (page 0).  When a valid UBL signature is found,
+the corresponding block number (from 1 to 24) is written to the last 32
+bits of ARM internal memory (0x7ffc-0x8000).  This feature is provided
+as a basic debug mechanism.  If not found, it continues with block 2
+... last possible block is 24
+
+If a valid UBL descriptor is found, the UBL descriptor is read and
+processed.  The descriptor gives the information required for loading
+and control transfer to the nand_spl code.  The nand_spl code is then
+read and processed.
+
+Once the user-specified start-up conditions are set, the RBL copies the
+nand_spl into ARM internal RAM, starting at address 0x0000: 0020.
+							    ^^^^
+
+The nand_spl code itself now does necessary intializations, and at least,
+copies the u-boot code from NAND into RAM, and jumps to it ...
+
+------------------------------------------------
+Author: Heiko Schocher <hs@denx.de>
Index: u-boot-2011.06/doc/README.update
===================================================================
--- u-boot-2011.06.orig/doc/README.update	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/doc/README.update	2011-09-20 17:03:31.170018148 +0200
@@ -51,6 +51,11 @@
 to be prepared. Refer to the doc/uImage.FIT/ directory for more details on FIT
 images.
 
+This mechanism can be also triggered by the commmand "fitupd".
+If an optional, non-zero address is provided as argument, the TFTP transfer
+is skipped and the image at this address is used.
+The fitupd command is enabled by CONFIG_CMD_FITUPD.
+
 
 Example .its files
 ------------------
Index: u-boot-2011.06/doc/README.usb
===================================================================
--- u-boot-2011.06.orig/doc/README.usb	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/doc/README.usb	2011-09-20 17:03:31.170018148 +0200
@@ -79,4 +79,159 @@
 		    if using CONFIG_CMD_USB
 CONFIG_USB_KEYBOARD enables the USB Keyboard
 CONFIG_USB_STORAGE  enables the USB storage devices
-CONFIG_USB_HOST_ETHER	enables USB ethernet dongle support
+CONFIG_USB_HOST_ETHER	enables USB ethernet adapter support
+
+
+USB Host Networking
+===================
+
+If you have a supported USB Ethernet adapter you can use it in U-Boot
+to obtain an IP address and load a kernel from a network server.
+
+Note: USB Host Networking is not the same as making your board act as a USB
+client. In that case your board is pretending to be an Ethernet adapter
+and will appear as a network interface to an attached computer. In that
+case the connection is via a USB cable with the computer acting as the host.
+
+With USB Host Networking, your board is the USB host. It controls the
+Ethernet adapter to which it is directly connected and the connection to
+the outside world is your adapter's Ethernet cable. Your board becomes an
+independent network device, able to connect and perform network operations
+independently of your computer.
+
+
+Device support
+--------------
+
+Currently supported devices are listed in the drivers according to
+their vendor and product IDs. You can check your device by connecting it
+to a Linux machine and typing 'lsusb'. The drivers are in
+drivers/usb/eth.
+
+For example this lsusb output line shows a device with Vendor ID 0x0x95
+and product ID 0x7720:
+
+Bus 002 Device 010: ID 0b95:7720 ASIX Electronics Corp. AX88772
+
+If you look at drivers/usb/eth/asix.c you will see this line within the
+supported device list, so we know this adapter is supported.
+
+	{ 0x0b95, 0x7720 },	/* Trendnet TU2-ET100 V3.0R */
+
+If your adapter is not listed there is a still a chance that it will
+work. Try looking up the manufacturer of the chip inside your adapter.
+or take the adapter apart and look for chip markings. Then add a line
+for your vendor/product ID into the table of the appropriate driver,
+build U-Boot and see if it works. If not then there might be differences
+between the chip in your adapter and the driver. You could try to get a
+datasheet for your device and add support for it to U-Boot. This is not
+particularly difficult - you only need to provide support for four basic
+functions: init, halt, send and recv.
+
+
+Enabling USB Host Networking
+----------------------------
+
+The normal U-Boot commands are used with USB networking, but you must
+start USB first. For example:
+
+usb start
+setenv bootfile /tftpboot/uImage
+bootp
+
+
+To enable USB Host Ethernet in U-Boot, your platform must of course
+support USB with CONFIG_CMD_USB enabled and working. You will need to
+add some config settings to your board header file:
+
+#define CONFIG_USB_HOST_ETHER	/* Enable USB Ethernet adapters */
+#define CONFIG_USB_ETHER_ASIX	/* Asix, or whatever driver(s) you want */
+
+As with built-in networking, you will also want to enable some network
+commands, for example:
+
+#define CONFIG_CMD_NET
+#define CONFIG_NET_MULTI
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+
+and some bootp options, which tell your board to obtain its subnet,
+gateway IP, host name and boot path from the bootp/dhcp server. These
+settings should start you off:
+
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_BOOTPATH
+
+You can also set the default IP address of your board and the server
+as well as the default file to load when a 'bootp' command is issued.
+All of these can be obtained from the bootp server if not set.
+
+#define CONFIG_IPADDR		10.0.0.2  (replace with your value)
+#define CONFIG_SERVERIP		10.0.0.1  (replace with your value)
+#define CONFIG_BOOTFILE		uImage
+
+
+The 'usb start' command should identify the adapter something like this:
+
+CrOS> usb start
+(Re)start USB...
+USB EHCI 1.00
+scanning bus for devices... 3 USB Device(s) found
+       scanning bus for storage devices... 0 Storage Device(s) found
+       scanning bus for ethernet devices... 1 Ethernet Device(s) found
+CrOS> print ethact
+ethact=asx0
+
+You can see that it found an ethernet device and we can print out the
+device name (asx0 in this case).
+
+Then 'bootp' or 'dhcp' should use it to obtain an IP address from DHCP,
+perhaps something like this:
+
+CrOS> bootp
+Waiting for Ethernet connection... done.
+BOOTP broadcast 1
+BOOTP broadcast 2
+DHCP client bound to address 172.22.73.81
+Using asx0 device
+TFTP from server 172.22.72.144; our IP address is 172.22.73.81
+Filename '/tftpboot/uImage-sjg-seaboard-261347'.
+Load address: 0x40c000
+Loading: #################################################################
+	 #################################################################
+	 #################################################################
+	 ################################################
+done
+Bytes transferred = 3557464 (364858 hex)
+CrOS>
+
+
+Another way of doing this is to issue a tftp command, which will cause the
+bootp to happen automatically.
+
+
+MAC Addresses
+-------------
+
+Most Ethernet dongles have a built-in MAC address which is unique in the
+world. This is important so that devices on the network can be
+distinguised from each other. MAC address conflicts are evil and
+generally result in strange and eratic behaviour.
+
+Some boards have USB Ethernet chips on-board, and these sometimes do not
+have an assigned MAC address. In this case it is up to you to assign
+one which is unique. You should obtain a valid MAC address from a range
+assigned to you before you ship the product.
+
+Built-in Ethernet adapters support setting the MAC address by means of
+an ethaddr environment variable for each interface (ethaddr, eth1addr,
+eth2addr). There is similar support on the USB network side, using the
+names usbethaddr, usbeth1addr, etc. They are kept separate since we
+don't want a USB device taking the MAC address of a built-in device or
+vice versa.
+
+So if your USB Ethernet chip doesn't have a MAC address available then
+you must set usbethaddr to a suitable MAC address. At the time of
+writing this functionality is only supported by the SMSC driver.
Index: u-boot-2011.06/fs/ext2/dev.c
===================================================================
--- u-boot-2011.06.orig/fs/ext2/dev.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/ext2/dev.c	2011-09-20 17:03:31.170018148 +0200
@@ -31,7 +31,7 @@
 static block_dev_desc_t *ext2fs_block_dev_desc;
 static disk_partition_t part_info;
 
-int ext2fs_set_blk_dev (block_dev_desc_t * rbdd, int part)
+int ext2fs_set_blk_dev(block_dev_desc_t *rbdd, int part)
 {
 	ext2fs_block_dev_desc = rbdd;
 
@@ -46,94 +46,86 @@
 			return 0;
 		}
 	}
-	return (part_info.size);
+	return part_info.size;
 }
 
 
-int ext2fs_devread (int sector, int byte_offset, int byte_len, char *buf) {
+int ext2fs_devread(int sector, int byte_offset, int byte_len, char *buf)
+{
 	char sec_buf[SECTOR_SIZE];
-	unsigned block_len;
+	unsigned sectors;
 
-/*
- *  Check partition boundaries
- */
-	if ((sector < 0)
-	    || ((sector + ((byte_offset + byte_len - 1) >> SECTOR_BITS)) >=
+	/*
+	 *  Check partition boundaries
+	 */
+	if ((sector < 0) ||
+	    ((sector + ((byte_offset + byte_len - 1) >> SECTOR_BITS)) >=
 		part_info.size)) {
-	/*      errnum = ERR_OUTSIDE_PART; */
-		printf (" ** ext2fs_devread() read outside partition sector %d\n", sector);
-		return (0);
+		/* errnum = ERR_OUTSIDE_PART; */
+		printf(" ** %s read outside partition sector %d\n",
+		       __func__,
+		       sector);
+		return 0;
 	}
 
-/*
- *  Get the read to the beginning of a partition.
- */
+	/*
+	 *  Get the read to the beginning of a partition.
+	 */
 	sector += byte_offset >> SECTOR_BITS;
 	byte_offset &= SECTOR_SIZE - 1;
 
-	debug (" <%d, %d, %d>\n", sector, byte_offset, byte_len);
+	debug(" <%d, %d, %d>\n", sector, byte_offset, byte_len);
 
 	if (ext2fs_block_dev_desc == NULL) {
-		printf ("** Invalid Block Device Descriptor (NULL)\n");
-		return (0);
+		printf(" ** %s Invalid Block Device Descriptor (NULL)\n",
+		       __func__);
+		return 0;
 	}
 
 	if (byte_offset != 0) {
 		/* read first part which isn't aligned with start of sector */
 		if (ext2fs_block_dev_desc->
-		    block_read (ext2fs_block_dev_desc->dev,
-				part_info.start + sector, 1,
-				(unsigned long *) sec_buf) != 1) {
-			printf (" ** ext2fs_devread() read error **\n");
-			return (0);
+		    block_read(ext2fs_block_dev_desc->dev,
+			       part_info.start + sector, 1,
+			       (unsigned long *) sec_buf) != 1) {
+			printf(" ** %s read error **\n", __func__);
+			return 0;
 		}
-		memcpy (buf, sec_buf + byte_offset,
-			min (SECTOR_SIZE - byte_offset, byte_len));
-		buf += min (SECTOR_SIZE - byte_offset, byte_len);
-		byte_len -= min (SECTOR_SIZE - byte_offset, byte_len);
+		memcpy(buf, sec_buf + byte_offset,
+		       min(SECTOR_SIZE - byte_offset, byte_len));
+		buf += min(SECTOR_SIZE - byte_offset, byte_len);
+		byte_len -= min(SECTOR_SIZE - byte_offset, byte_len);
 		sector++;
 	}
 
-	if (byte_len == 0)
-		return 1;
-
 	/*  read sector aligned part */
-	block_len = byte_len & ~(SECTOR_SIZE - 1);
+	sectors = byte_len / SECTOR_SIZE;
 
-	if (block_len == 0) {
-		u8 p[SECTOR_SIZE];
+	if (sectors > 0) {
+		if (ext2fs_block_dev_desc->block_read(
+			ext2fs_block_dev_desc->dev,
+			part_info.start + sector,
+			sectors,
+			(unsigned long *) buf) != sectors) {
+			printf(" ** %s read error - block\n", __func__);
+			return 0;
+		}
 
-		block_len = SECTOR_SIZE;
-		ext2fs_block_dev_desc->block_read(ext2fs_block_dev_desc->dev,
-						  part_info.start + sector,
-						  1, (unsigned long *)p);
-		memcpy(buf, p, byte_len);
-		return 1;
-	}
-
-	if (ext2fs_block_dev_desc->block_read (ext2fs_block_dev_desc->dev,
-					       part_info.start + sector,
-					       block_len / SECTOR_SIZE,
-					       (unsigned long *) buf) !=
-	    block_len / SECTOR_SIZE) {
-		printf (" ** ext2fs_devread() read error - block\n");
-		return (0);
-	}
-	block_len = byte_len & ~(SECTOR_SIZE - 1);
-	buf += block_len;
-	byte_len -= block_len;
-	sector += block_len / SECTOR_SIZE;
+		buf += sectors * SECTOR_SIZE;
+		byte_len -= sectors * SECTOR_SIZE;
+		sector += sectors;
+	}
 
 	if (byte_len != 0) {
 		/* read rest of data which are not in whole sector */
 		if (ext2fs_block_dev_desc->
-		    block_read (ext2fs_block_dev_desc->dev,
-				part_info.start + sector, 1,
-				(unsigned long *) sec_buf) != 1) {
-			printf (" ** ext2fs_devread() read error - last part\n");
-			return (0);
+		    block_read(ext2fs_block_dev_desc->dev,
+			       part_info.start + sector, 1,
+			       (unsigned long *) sec_buf) != 1) {
+			printf(" ** %s read error - last part\n", __func__);
+			return 0;
 		}
-		memcpy (buf, sec_buf, byte_len);
+		memcpy(buf, sec_buf, byte_len);
 	}
-	return (1);
+	return 1;
 }
Index: u-boot-2011.06/fs/fat/Makefile
===================================================================
--- u-boot-2011.06.orig/fs/fat/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fat/Makefile	2011-09-20 17:03:31.170018148 +0200
@@ -24,7 +24,11 @@
 LIB	= $(obj)libfat.o
 
 AOBJS	=
-COBJS-$(CONFIG_CMD_FAT)	:= fat.o file.o
+COBJS-$(CONFIG_CMD_FAT)	:= fat.o
+
+ifndef CONFIG_SPL_BUILD
+COBJS-$(CONFIG_CMD_FAT)	+= file.o
+endif
 
 SRCS	:= $(AOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(AOBJS) $(COBJS-y))
Index: u-boot-2011.06/fs/fdos/dev.c
===================================================================
--- u-boot-2011.06.orig/fs/fdos/dev.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/dev.c	2011-09-20 17:03:31.170018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/fs/fdos/dos.h
===================================================================
--- u-boot-2011.06.orig/fs/fdos/dos.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/dos.h	2011-09-20 17:03:31.170018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/fs/fdos/fat.c
===================================================================
--- u-boot-2011.06.orig/fs/fdos/fat.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/fat.c	2011-09-20 17:03:31.170018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/fs/fdos/fdos.c
===================================================================
--- u-boot-2011.06.orig/fs/fdos/fdos.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/fdos.c	2011-09-20 17:03:31.170018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/fs/fdos/fdos.h
===================================================================
--- u-boot-2011.06.orig/fs/fdos/fdos.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/fdos.h	2011-09-20 17:03:31.170018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/fs/fdos/fs.c
===================================================================
--- u-boot-2011.06.orig/fs/fdos/fs.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/fs.c	2011-09-20 17:03:31.170018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/fs/fdos/Makefile
===================================================================
--- u-boot-2011.06.orig/fs/fdos/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/Makefile	2011-09-20 17:03:31.170018148 +0200
@@ -3,7 +3,7 @@
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
 # (C) Copyright 2002
-# St‰ubli Faverges - <www.staubli.com>
+# St√§ubli Faverges - <www.staubli.com>
 # Pierre AUBERT  p.aubert@staubli.com
 #
 #
Index: u-boot-2011.06/fs/fdos/subdir.c
===================================================================
--- u-boot-2011.06.orig/fs/fdos/subdir.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/subdir.c	2011-09-20 17:03:31.170018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/fs/fdos/vfat.c
===================================================================
--- u-boot-2011.06.orig/fs/fdos/vfat.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/fdos/vfat.c	2011-09-20 17:03:31.170018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/fs/ubifs/ubifs.c
===================================================================
--- u-boot-2011.06.orig/fs/ubifs/ubifs.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/ubifs/ubifs.c	2011-09-20 17:03:31.170018148 +0200
@@ -360,6 +360,8 @@
 		return err;
 	}
 
+	if (file->private_data)
+		kfree(file->private_data);
 	if (file)
 		free(file);
 	if (dentry)
@@ -367,10 +369,6 @@
 	if (dir)
 		free(dir);
 
-	if (file->private_data)
-		kfree(file->private_data);
-	file->private_data = NULL;
-	file->f_pos = 2;
 	return 0;
 }
 
@@ -688,6 +686,7 @@
 	int i;
 	int count;
 	int last_block_size = 0;
+	char buf [10];
 
 	c->ubi = ubi_open_volume(c->vi.ubi_num, c->vi.vol_id, UBI_READONLY);
 	/* ubifs_findfile will resolve symlinks, so we know that we get
@@ -739,8 +738,11 @@
 
 	if (err)
 		printf("Error reading file '%s'\n", filename);
-	else
+	else {
+	        sprintf(buf, "%X", size);
+		setenv("filesize", buf);
 		printf("Done\n");
+	}
 
 	ubifs_iput(inode);
 
Index: u-boot-2011.06/fs/yaffs2/Makefile
===================================================================
--- u-boot-2011.06.orig/fs/yaffs2/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/yaffs2/Makefile	2011-09-20 17:03:31.170018148 +0200
@@ -31,7 +31,7 @@
 OBJS    := $(addprefix $(obj),$(COBJS-y))
 
 # -DCONFIG_YAFFS_NO_YAFFS1
-CFLAGS +=    -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DLINUX_VERSION_CODE=0x20622
+CFLAGS +=    -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DLINUX_VERSION_CODE=0x20622
 
 all:  $(LIB)
 
Index: u-boot-2011.06/fs/yaffs2/yaffscfg.c
===================================================================
--- u-boot-2011.06.orig/fs/yaffs2/yaffscfg.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/yaffs2/yaffscfg.c	2011-09-20 17:03:31.170018148 +0200
@@ -313,7 +313,7 @@
 
 	yaffs_stat(fn,&s);
 
-	printf ("Copy %s to 0x%08x... ", fn, addr);
+	printf ("Copy %s to 0x%p... ", fn, addr);
 	h = yaffs_open(fn, O_RDWR,0);
 	if(h<0)
 	{
@@ -368,7 +368,7 @@
 			{
 				sprintf(tempstr, "%s/%s", mountpt, de->d_name);
 				yaffs_stat(tempstr, &stat);
-				printf("%-25s\t%7d\n",de->d_name, stat.st_size);
+				printf("%-25s\t%7ld\n",de->d_name, stat.st_size);
 			}
 			else
 			{
Index: u-boot-2011.06/fs/yaffs2/yaffs_guts.c
===================================================================
--- u-boot-2011.06.orig/fs/yaffs2/yaffs_guts.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/yaffs2/yaffs_guts.c	2011-09-20 17:03:31.170018148 +0200
@@ -391,17 +391,17 @@
  * Verification code
  */
 
-static int yaffs_SkipVerification(yaffs_Device *dev)
+static Y_INLINE int yaffs_SkipVerification(yaffs_Device *dev)
 {
 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
 }
 
-static int yaffs_SkipFullVerification(yaffs_Device *dev)
+static Y_INLINE int yaffs_SkipFullVerification(yaffs_Device *dev)
 {
 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));
 }
 
-static int yaffs_SkipNANDVerification(yaffs_Device *dev)
+static Y_INLINE int yaffs_SkipNANDVerification(yaffs_Device *dev)
 {
 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));
 }
@@ -2140,7 +2140,7 @@
 {
 
 	yaffs_Object *theObject;
-	yaffs_Tnode *tn;
+	yaffs_Tnode *tn = NULL;
 
 	if (number < 0) {
 		number = yaffs_CreateNewObjectNumber(dev);
@@ -2255,7 +2255,7 @@
 				       const YCHAR * aliasString, __u32 rdev)
 {
 	yaffs_Object *in;
-	YCHAR *str;
+	YCHAR *str = NULL;
 
 	yaffs_Device *dev = parent->myDev;
 
@@ -4605,8 +4605,8 @@
 			   int nBytes)
 {
 
-	int chunk;
-	int start;
+	__u32 chunk;
+	__u32 start;
 	int nToCopy;
 	int n = nBytes;
 	int nDone = 0;
@@ -4725,8 +4725,8 @@
 			  int nBytes, int writeThrough)
 {
 
-	int chunk;
-	int start;
+	__u32 chunk;
+	__u32 start;
 	int nToCopy;
 	int n = nBytes;
 	int nDone = 0;
@@ -4960,8 +4960,8 @@
 {
 
 	int oldFileSize = in->variant.fileVariant.fileSize;
-	int newSizeOfPartialChunk;
-	int newFullChunks;
+	__u32 newSizeOfPartialChunk;
+	__u32 newFullChunks;
 
 	yaffs_Device *dev = in->myDev;
 
@@ -7232,7 +7232,8 @@
 			dev->nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;
 		}
 
-		buf = dev->srCache =  YMALLOC(srCacheBytes);
+		dev->srCache = YMALLOC(srCacheBytes);
+		buf = (__u8 *)dev->srCache;
 
 		if(dev->srCache)
 			memset(dev->srCache,0,srCacheBytes);
Index: u-boot-2011.06/fs/yaffs2/yaffs_nand.c
===================================================================
--- u-boot-2011.06.orig/fs/yaffs2/yaffs_nand.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/yaffs2/yaffs_nand.c	2011-09-20 17:03:31.170018148 +0200
@@ -101,7 +101,7 @@
 int yaffs_QueryInitialBlockState(yaffs_Device * dev,
 						 int blockNo,
 						 yaffs_BlockState * state,
-						 unsigned *sequenceNumber)
+						 int *sequenceNumber)
 {
 	blockNo -= dev->blockOffset;
 
Index: u-boot-2011.06/fs/yaffs2/yaffs_nand.h
===================================================================
--- u-boot-2011.06.orig/fs/yaffs2/yaffs_nand.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/fs/yaffs2/yaffs_nand.h	2011-09-20 17:03:31.170018148 +0200
@@ -33,7 +33,7 @@
 int yaffs_QueryInitialBlockState(yaffs_Device * dev,
 						 int blockNo,
 						 yaffs_BlockState * state,
-						 unsigned *sequenceNumber);
+						 int *sequenceNumber);
 
 int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
 				  int blockInNAND);
Index: u-boot-2011.06/include/bedbug/bedbug.h
===================================================================
--- u-boot-2011.06.orig/include/bedbug/bedbug.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/bedbug/bedbug.h	2011-09-20 17:03:31.170018148 +0200
@@ -21,8 +21,6 @@
 #endif
 #endif
 
-#define assert( condition ) if( (condition) ) _exit(0)
-
 #endif /* _BEDBUG_H */
 
 
Index: u-boot-2011.06/include/command.h
===================================================================
--- u-boot-2011.06.orig/include/command.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/command.h	2011-09-20 17:03:31.170018148 +0200
@@ -71,7 +71,7 @@
 cmd_tbl_t *find_cmd(const char *cmd);
 cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len);
 
-extern int cmd_usage(cmd_tbl_t *cmdtp);
+extern int cmd_usage(const cmd_tbl_t *cmdtp);
 
 #ifdef CONFIG_AUTO_COMPLETE
 extern int var_complete(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);
@@ -98,7 +98,15 @@
 #ifdef CONFIG_CMD_BOOTD
 extern int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 #endif
+#ifdef CONFIG_CMD_BOOTM
 extern int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+extern int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd);
+#else
+static inline int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
+{
+	return 0;
+}
+#endif
 extern int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 
 #endif	/* __ASSEMBLY__ */
Index: u-boot-2011.06/include/common.h
===================================================================
--- u-boot-2011.06.orig/include/common.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/common.h	2011-09-20 17:03:31.180018148 +0200
@@ -124,6 +124,27 @@
 #define debugX(level,fmt,args...)
 #endif	/* DEBUG */
 
+#ifdef DEBUG
+# define _DEBUG 1
+#else
+# define _DEBUG 0
+#endif
+
+/*
+ * An assertion is run-time check done in debug mode only. If DEBUG is not
+ * defined then it is skipped. If DEBUG is defined and the assertion fails,
+ * then it calls panic*( which may or may not reset/halt U-Boot (see
+ * CONFIG_PANIC_HANG), It is hoped that all failing assertions are found
+ * before release, and after release it is hoped that they don't matter. But
+ * in any case these failing assertions cannot be fixed with a reset (which
+ * may just do the same assertion again).
+ */
+void __assert_fail(const char *assertion, const char *file, unsigned line,
+		   const char *function);
+#define assert(x) \
+	({ if (!(x) && _DEBUG) \
+		__assert_fail(#x, __FILE__, __LINE__, __func__); })
+
 #define error(fmt, args...) do {					\
 		printf("ERROR: " fmt "\nat %s:%d/%s()\n",		\
 			##args, __FILE__, __LINE__, __func__);		\
@@ -137,6 +158,9 @@
 #define BUG_ON(condition) do { if (unlikely((condition)!=0)) BUG(); } while(0)
 #endif /* BUG */
 
+/* Force a compilation error if condition is true */
+#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
+
 typedef void (interrupt_handler_t)(void *);
 
 #include <asm/u-boot.h> /* boot information for Linux kernel */
@@ -219,6 +243,9 @@
 
 void	hang		(void) __attribute__ ((noreturn));
 
+int	timer_init(void);
+int	cpu_init(void);
+
 /* */
 phys_size_t initdram (int);
 int	display_options (void);
@@ -259,13 +286,13 @@
 int	env_init     (void);
 void	env_relocate (void);
 int	envmatch     (uchar *, int);
-char	*getenv	     (char *);
-int	getenv_f     (char *name, char *buf, unsigned len);
+char	*getenv	     (const char *);
+int	getenv_f     (const char *name, char *buf, unsigned len);
 int	saveenv	     (void);
 #ifdef CONFIG_PPC		/* ARM version to be fixed! */
-int inline setenv   (char *, char *);
+int inline setenv    (const char *, const char *);
 #else
-int	setenv	     (char *, char *);
+int	setenv	     (const char *, const char *);
 #endif /* CONFIG_PPC */
 #ifdef CONFIG_ARM
 # include <asm/mach-types.h>
@@ -317,7 +344,7 @@
 void	api_init (void);
 
 /* common/memsize.c */
-long	get_ram_size  (volatile long *, long);
+long	get_ram_size  (long *, long);
 
 /* $(BOARD)/$(BOARD).c */
 void	reset_phy     (void);
@@ -413,6 +440,7 @@
 int	dcache_status (void);
 void	dcache_enable (void);
 void	dcache_disable(void);
+void	mmu_disable(void);
 void	relocate_code (ulong, gd_t *, ulong) __attribute__ ((noreturn));
 ulong	get_endaddr   (void);
 void	trap_init     (ulong);
@@ -586,7 +614,6 @@
 void	irq_free_handler   (int);
 void	reset_timer	   (void);
 ulong	get_timer	   (ulong base);
-void	set_timer	   (ulong t);
 void	enable_interrupts  (void);
 int	disable_interrupts (void);
 
@@ -610,10 +637,13 @@
 ulong	video_setmem (ulong);
 
 /* arch/$(ARCH)/lib/cache.c */
+void	enable_caches(void);
 void	flush_cache   (unsigned long, unsigned long);
+void	flush_dcache_all(void);
 void	flush_dcache_range(unsigned long start, unsigned long stop);
 void	invalidate_dcache_range(unsigned long start, unsigned long stop);
-
+void	invalidate_dcache_all(void);
+void	invalidate_icache_all(void);
 
 /* arch/$(ARCH)/lib/ticks.S */
 unsigned long long get_ticks(void);
@@ -651,7 +681,7 @@
 unsigned long long	simple_strtoull(const char *cp,char **endp,unsigned int base);
 long	simple_strtol(const char *cp,char **endp,unsigned int base);
 void	panic(const char *fmt, ...)
-		__attribute__ ((format (__printf__, 1, 2)));
+		__attribute__ ((format (__printf__, 1, 2), noreturn));
 int	sprintf(char * buf, const char *fmt, ...)
 		__attribute__ ((format (__printf__, 2, 3)));
 int	vsprintf(char *buf, const char *fmt, va_list args);
@@ -751,7 +781,7 @@
 
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 
-#define ROUND(a,b)		(((a) + (b)) & ~((b) - 1))
+#define ROUND(a,b)		(((a) + (b) - 1) & ~((b) - 1))
 #define DIV_ROUND(n,d)		(((n) + ((d)/2)) / (d))
 #define DIV_ROUND_UP(n,d)	(((n) + (d) - 1) / (d))
 #define roundup(x, y)		((((x) + ((y) - 1)) / (y)) * (y))
@@ -759,4 +789,9 @@
 #define ALIGN(x,a)		__ALIGN_MASK((x),(typeof(x))(a)-1)
 #define __ALIGN_MASK(x,mask)	(((x)+(mask))&~(mask))
 
+/* Pull in stuff for the build system */
+#ifdef DO_DEPS_ONLY
+# include <environment.h>
+#endif
+
 #endif	/* __COMMON_H_ */
Index: u-boot-2011.06/include/commproc.h
===================================================================
--- u-boot-2011.06.orig/include/commproc.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/commproc.h	2011-09-20 17:03:31.180018148 +0200
@@ -108,7 +108,7 @@
 	uint	cbd_bufaddr;	/* Buffer address in host memory */
 } cbd_t;
 
-#define BD_SC_EMPTY	((ushort)0x8000)	/* Recieve is empty */
+#define BD_SC_EMPTY	((ushort)0x8000)	/* Receive is empty */
 #define BD_SC_READY	((ushort)0x8000)	/* Transmit is ready */
 #define BD_SC_WRAP	((ushort)0x2000)	/* Last buffer descriptor */
 #define BD_SC_INTRPT	((ushort)0x1000)	/* Interrupt on change */
Index: u-boot-2011.06/include/compiler.h
===================================================================
--- u-boot-2011.06.orig/include/compiler.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/compiler.h	2011-09-20 17:03:31.180018148 +0200
@@ -44,7 +44,7 @@
 #ifdef __linux__
 # include <endian.h>
 # include <byteswap.h>
-#elif defined(__MACH__)
+#elif defined(__MACH__) || defined(__FreeBSD__)
 # include <machine/endian.h>
 typedef unsigned long ulong;
 #endif
Index: u-boot-2011.06/include/config_defaults.h
===================================================================
--- u-boot-2011.06.orig/include/config_defaults.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/config_defaults.h	2011-09-20 17:03:31.180018148 +0200
@@ -16,5 +16,6 @@
 
 #define CONFIG_GZIP 1
 #define CONFIG_ZLIB 1
+#define CONFIG_PARTITIONS 1
 
 #endif
Index: u-boot-2011.06/include/ddr_spd.h
===================================================================
--- u-boot-2011.06.orig/include/ddr_spd.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/ddr_spd.h	2011-09-20 17:03:31.180018148 +0200
@@ -219,7 +219,9 @@
 					     Delay Time*/
 	unsigned char opt_features;    /* 30 SDRAM Optional Features */
 	unsigned char therm_ref_opt;   /* 31 SDRAM Thermal and Refresh Opts */
-	unsigned char res_32_59[28];   /* 32-59 Reserved, General Section */
+	unsigned char therm_sensor;    /* 32 Module Thermal Sensor */
+	unsigned char device_type;     /* 33 SDRAM device type */
+	unsigned char res_34_59[26];   /* 34-59 Reserved, General Section */
 
 	/* Module-Specific Section: Bytes 60-116 */
 	union {
Index: u-boot-2011.06/include/dtt.h
===================================================================
--- u-boot-2011.06.orig/include/dtt.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/dtt.h	2011-09-20 17:03:31.180018148 +0200
@@ -52,7 +52,7 @@
 #endif
 #endif /* CONFIG_DTT_ADM1021 */
 
-extern int dtt_init (void);
+extern int dtt_init_one(int);
 extern int dtt_read(int sensor, int reg);
 extern int dtt_write(int sensor, int reg, int val);
 extern int dtt_get_temp(int sensor);
Index: u-boot-2011.06/include/environment.h
===================================================================
--- u-boot-2011.06.orig/include/environment.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/environment.h	2011-09-20 17:03:31.180018148 +0200
@@ -124,7 +124,9 @@
 /* The build system likes to know if the env is embedded */
 #ifdef DO_DEPS_ONLY
 # ifdef ENV_IS_EMBEDDED
-#  define CONFIG_ENV_IS_EMBEDDED
+#  ifndef CONFIG_ENV_IS_EMBEDDED
+#   define CONFIG_ENV_IS_EMBEDDED
+#  endif
 # endif
 #endif
 
@@ -160,7 +162,7 @@
 unsigned char env_get_char (int);
 
 /* Function that returns a pointer to a value from the environment */
-unsigned char *env_get_addr(int);
+const unsigned char *env_get_addr(int);
 unsigned char env_get_char_memory (int index);
 
 /* Function that updates CRC of the enironment */
Index: u-boot-2011.06/include/exports.h
===================================================================
--- u-boot-2011.06.orig/include/exports.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/exports.h	2011-09-20 17:03:31.180018148 +0200
@@ -21,8 +21,8 @@
 int vprintf(const char *, va_list);
 unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base);
 int strict_strtoul(const char *cp, unsigned int base, unsigned long *res);
-char *getenv (char *name);
-int setenv (char *varname, char *varvalue);
+char *getenv (const char *name);
+int setenv (const char *varname, const char *varvalue);
 long simple_strtol(const char *cp,char **endp,unsigned int base);
 int strcmp(const char * cs,const char * ct);
 int ustrtoul(const char *cp, char **endp, unsigned int base);
Index: u-boot-2011.06/include/fdc.h
===================================================================
--- u-boot-2011.06.orig/include/fdc.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/fdc.h	2011-09-20 17:03:31.180018148 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * St‰ubli Faverges - <www.staubli.com>
+ * St√§ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
Index: u-boot-2011.06/include/fdt_support.h
===================================================================
--- u-boot-2011.06.orig/include/fdt_support.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/fdt_support.h	2011-09-20 17:03:31.180018148 +0200
@@ -79,6 +79,7 @@
 
 void set_working_fdt_addr(void *addr);
 int fdt_resize(void *blob);
+int fdt_increase_size(void *fdt, int add_len);
 
 int fdt_fixup_nor_flash_size(void *blob);
 
@@ -88,7 +89,12 @@
 int fdt_node_offset_by_compat_reg(void *blob, const char *compat,
 					phys_addr_t compat_off);
 int fdt_alloc_phandle(void *blob);
+int fdt_create_phandle(void *fdt, int nodeoffset, uint32_t phandle);
 int fdt_add_edid(void *blob, const char *compat, unsigned char *buf);
 
+int fdt_verify_alias_address(void *fdt, int anode, const char *alias,
+			      u64 addr);
+u64 fdt_get_base_address(void *fdt, int node);
+
 #endif /* ifdef CONFIG_OF_LIBFDT */
 #endif /* ifndef __FDT_SUPPORT_H */
Index: u-boot-2011.06/include/image.h
===================================================================
--- u-boot-2011.06.orig/include/image.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/image.h	2011-09-20 17:03:31.180018148 +0200
@@ -157,6 +157,8 @@
 #define IH_TYPE_FLATDT		8	/* Binary Flat Device Tree Blob	*/
 #define IH_TYPE_KWBIMAGE	9	/* Kirkwood Boot Image		*/
 #define IH_TYPE_IMXIMAGE	10	/* Freescale IMXBoot Image	*/
+#define IH_TYPE_UBLIMAGE	11	/* Davinci UBL Image		*/
+#define IH_TYPE_OMAPIMAGE	12	/* TI OMAP Config Header Image	*/
 
 /*
  * Compression Types
Index: u-boot-2011.06/include/libfdt.h
===================================================================
--- u-boot-2011.06.orig/include/libfdt.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/libfdt.h	2011-09-20 17:03:31.180018148 +0200
@@ -343,6 +343,75 @@
 const char *fdt_get_name(const void *fdt, int nodeoffset, int *lenp);
 
 /**
+ * fdt_first_property_offset - find the offset of a node's first property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of a node
+ *
+ * fdt_first_property_offset() finds the first property of the node at
+ * the given structure block offset.
+ *
+ * returns:
+ *	structure block offset of the property (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the requested node has no properties
+ *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_BEGIN_NODE tag
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_first_property_offset(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_next_property_offset - step through a node's properties
+ * @fdt: pointer to the device tree blob
+ * @offset: structure block offset of a property
+ *
+ * fdt_next_property_offset() finds the property immediately after the
+ * one at the given structure block offset.  This will be a property
+ * of the same node as the given property.
+ *
+ * returns:
+ *	structure block offset of the next property (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the given property is the last in its node
+ *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_PROP tag
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_next_property_offset(const void *fdt, int offset);
+
+/**
+ * fdt_get_property_by_offset - retrieve the property at a given offset
+ * @fdt: pointer to the device tree blob
+ * @offset: offset of the property to retrieve
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_property_by_offset() retrieves a pointer to the
+ * fdt_property structure within the device tree blob at the given
+ * offset.  If lenp is non-NULL, the length of the property value is
+ * also returned, in the integer pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the structure representing the property
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
+						      int offset,
+						      int *lenp);
+
+/**
  * fdt_get_property_namelen - find a property based on substring
  * @fdt: pointer to the device tree blob
  * @nodeoffset: offset of the node whose property to find
@@ -396,6 +465,40 @@
 }
 
 /**
+ * fdt_getprop_by_offset - retrieve the value of a property at a given offset
+ * @fdt: pointer to the device tree blob
+ * @ffset: offset of the property to read
+ * @namep: pointer to a string variable (will be overwritten) or NULL
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_getprop_by_offset() retrieves a pointer to the value of the
+ * property at structure block offset 'offset' (this will be a pointer
+ * to within the device blob itself, not a copy of the value).  If
+ * lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by lenp.  If namep is non-NULL,
+ * the property's namne will also be returned in the char * pointed to
+ * by namep (this will be a pointer to within the device tree's string
+ * block, not a new copy of the name).
+ *
+ * returns:
+ *	pointer to the property's value
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *		if namep is non-NULL *namep contiains a pointer to the property
+ *		name.
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const void *fdt_getprop_by_offset(const void *fdt, int offset,
+				  const char **namep, int *lenp);
+
+/**
  * fdt_getprop_namelen - get property value based on substring
  * @fdt: pointer to the device tree blob
  * @nodeoffset: offset of the node whose property to find
Index: u-boot-2011.06/include/linux/mdio.h
===================================================================
--- u-boot-2011.06.orig/include/linux/mdio.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/linux/mdio.h	2011-09-20 17:03:31.180018148 +0200
@@ -120,6 +120,12 @@
 #define MDIO_DEVS_VEND1			MDIO_DEVS_PRESENT(MDIO_MMD_VEND1)
 #define MDIO_DEVS_VEND2			MDIO_DEVS_PRESENT(MDIO_MMD_VEND2)
 
+#define MDIO_DEVS_LINK			(MDIO_DEVS_PMAPMD | \
+					MDIO_DEVS_WIS | \
+					MDIO_DEVS_PCS | \
+					MDIO_DEVS_PHYXS | \
+					MDIO_DEVS_DTEXS | \
+					MDIO_DEVS_AN)
 
 /* Control register 2. */
 #define MDIO_PMA_CTRL2_TYPE		0x000f	/* PMA/PMD type selection */
Index: u-boot-2011.06/include/linux/mtd/mtd.h
===================================================================
--- u-boot-2011.06.orig/include/linux/mtd/mtd.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/linux/mtd/mtd.h	2011-09-20 17:03:31.180018148 +0200
@@ -115,7 +115,7 @@
 	u_int32_t flags;
 	uint64_t size;	 /* Total size of the MTD */
 
-	/* "Major" erase size for the device. NaÔve users may take this
+	/* "Major" erase size for the device. Na√Øve users may take this
 	 * to be the only erase size available, or may use the more detailed
 	 * information below if they desire
 	 */
Index: u-boot-2011.06/include/malloc.h
===================================================================
--- u-boot-2011.06.orig/include/malloc.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/malloc.h	2011-09-20 17:03:31.180018148 +0200
@@ -285,14 +285,6 @@
 
 */
 
-#ifdef DEBUG
-/* #include <assert.h> */
-#define assert(x) ((void)0)
-#else
-#define assert(x) ((void)0)
-#endif
-
-
 /*
   INTERNAL_SIZE_T is the word-size used for internal bookkeeping
   of chunk sizes. On a 64-bit machine, you can reduce malloc
Index: u-boot-2011.06/include/mmc.h
===================================================================
--- u-boot-2011.06.orig/include/mmc.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/mmc.h	2011-09-20 17:03:31.180018148 +0200
@@ -45,6 +45,7 @@
 #define MMC_MODE_4BIT		0x100
 #define MMC_MODE_8BIT		0x200
 #define MMC_MODE_SPI		0x400
+#define MMC_MODE_HC		0x800
 
 #define SD_DATA_4BIT	0x00040000
 
@@ -75,6 +76,9 @@
 #define MMC_CMD_READ_MULTIPLE_BLOCK	18
 #define MMC_CMD_WRITE_SINGLE_BLOCK	24
 #define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
+#define MMC_CMD_ERASE_GROUP_START	35
+#define MMC_CMD_ERASE_GROUP_END		36
+#define MMC_CMD_ERASE			38
 #define MMC_CMD_APP_CMD			55
 #define MMC_CMD_SPI_READ_OCR		58
 #define MMC_CMD_SPI_CRC_ON_OFF		59
@@ -84,6 +88,8 @@
 #define SD_CMD_SEND_IF_COND		8
 
 #define SD_CMD_APP_SET_BUS_WIDTH	6
+#define SD_CMD_ERASE_WR_BLK_START	32
+#define SD_CMD_ERASE_WR_BLK_END		33
 #define SD_CMD_APP_SEND_OP_COND		41
 #define SD_CMD_APP_SEND_SCR		51
 
@@ -99,6 +105,8 @@
 #define OCR_VOLTAGE_MASK	0x007FFF80
 #define OCR_ACCESS_MODE		0x60000000
 
+#define SECURE_ERASE		0x80000000
+
 #define MMC_STATUS_MASK		(~0x0206BF7F)
 #define MMC_STATUS_RDY_FOR_DATA (1 << 8)
 #define MMC_STATUS_CURR_STATE	(0xf << 9)
@@ -285,6 +293,7 @@
 	uint tran_speed;
 	uint read_bl_len;
 	uint write_bl_len;
+	uint erase_grp_size;
 	u64 capacity;
 	block_dev_desc_t block_dev;
 	int (*send_cmd)(struct mmc *mmc,
Index: u-boot-2011.06/include/nand.h
===================================================================
--- u-boot-2011.06.orig/include/nand.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/nand.h	2011-09-20 17:03:31.180018148 +0200
@@ -114,8 +114,14 @@
 
 int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 		       u_char *buffer);
+
+#define WITH_YAFFS_OOB	(1 << 0) /* whether write with yaffs format. This flag
+				  * is a 'mode' meaning it cannot be mixed with
+				  * other flags */
+#define WITH_DROP_FFS	(1 << 1) /* drop trailing all-0xff pages */
+
 int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
-			u_char *buffer, int withoob);
+			u_char *buffer, int flags);
 int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts);
 
 #define NAND_LOCK_STATUS_TIGHT	0x01
Index: u-boot-2011.06/include/net.h
===================================================================
--- u-boot-2011.06.orig/include/net.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/net.h	2011-09-20 17:03:31.180018148 +0200
@@ -128,7 +128,18 @@
 extern void eth_parse_enetaddr(const char *addr, uchar *enetaddr);
 extern int eth_getenv_enetaddr(char *name, uchar *enetaddr);
 extern int eth_setenv_enetaddr(char *name, const uchar *enetaddr);
-extern int eth_getenv_enetaddr_by_index(int index, uchar *enetaddr);
+
+/*
+ * Get the hardware address for an ethernet interface .
+ * Args:
+ *	base_name - base name for device (normally "eth")
+ *	index - device index number (0 for first)
+ *	enetaddr - returns 6 byte hardware address
+ * Returns:
+ *	Return true if the address is valid.
+ */
+extern int eth_getenv_enetaddr_by_index(const char *base_name, int index,
+					uchar *enetaddr);
 
 extern int usb_eth_initialize(bd_t *bi);
 extern int eth_init(bd_t *bis);			/* Initialize the device */
@@ -141,6 +152,18 @@
 extern void eth_halt(void);			/* stop SCC */
 extern char *eth_get_name(void);		/* get name of current device */
 
+/*
+ * Set the hardware address for an ethernet interface based on 'eth%daddr'
+ * environment variable (or just 'ethaddr' if eth_number is 0).
+ * Args:
+ *	base_name - base name for device (normally "eth")
+ *	eth_number - value of %d (0 for first device of this type)
+ * Returns:
+ *	0 is success, non-zero is error status from driver.
+ */
+int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
+		     int eth_number);
+
 #ifdef CONFIG_MCAST_TFTP
 int eth_mcast_join( IPaddr_t mcast_addr, u8 join);
 u32 ether_crc (size_t len, unsigned char const *p);
Index: u-boot-2011.06/include/part.h
===================================================================
--- u-boot-2011.06.orig/include/part.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/part.h	2011-09-20 17:03:31.180018148 +0200
@@ -49,6 +49,9 @@
 				       unsigned long start,
 				       lbaint_t blkcnt,
 				       const void *buffer);
+	unsigned long   (*block_erase)(int dev,
+				       unsigned long start,
+				       lbaint_t blkcnt);
 	void		*priv;		/* driver private struct pointer */
 }block_dev_desc_t;
 
@@ -93,6 +96,7 @@
 } disk_partition_t;
 
 /* Misc _get_dev functions */
+#ifdef CONFIG_PARTITIONS
 block_dev_desc_t* get_dev(char* ifname, int dev);
 block_dev_desc_t* ide_get_dev(int dev);
 block_dev_desc_t* sata_get_dev(int dev);
@@ -107,7 +111,22 @@
 void print_part (block_dev_desc_t *dev_desc);
 void  init_part (block_dev_desc_t *dev_desc);
 void dev_print(block_dev_desc_t *dev_desc);
-
+#else
+static inline block_dev_desc_t* get_dev(char* ifname, int dev) { return NULL; }
+static inline block_dev_desc_t* ide_get_dev(int dev) { return NULL; }
+static inline block_dev_desc_t* sata_get_dev(int dev) { return NULL; }
+static inline block_dev_desc_t* scsi_get_dev(int dev) { return NULL; }
+static inline block_dev_desc_t* usb_stor_get_dev(int dev) { return NULL; }
+static inline block_dev_desc_t* mmc_get_dev(int dev) { return NULL; }
+static inline block_dev_desc_t* systemace_get_dev(int dev) { return NULL; }
+static inline block_dev_desc_t* mg_disk_get_dev(int dev) { return NULL; }
+
+static inline int get_partition_info (block_dev_desc_t * dev_desc, int part,
+	disk_partition_t *info) { return -1; }
+static inline void print_part (block_dev_desc_t *dev_desc) {}
+static inline void  init_part (block_dev_desc_t *dev_desc) {}
+static inline void dev_print(block_dev_desc_t *dev_desc) {}
+#endif
 
 #ifdef CONFIG_MAC_PARTITION
 /* disk/part_mac.c */
Index: u-boot-2011.06/include/post.h
===================================================================
--- u-boot-2011.06.orig/include/post.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/post.h	2011-09-20 17:03:31.180018148 +0200
@@ -147,6 +147,7 @@
 extern struct post_test post_list[];
 extern unsigned int post_list_size;
 extern int post_hotkeys_pressed(void);
+extern int memory_post_test(int flags);
 
 /*
  *  If GCC is configured to use a version of GAS that supports
@@ -186,6 +187,7 @@
 #define CONFIG_SYS_POST_BSPEC5		0x00100000
 #define CONFIG_SYS_POST_CODEC		0x00200000
 #define CONFIG_SYS_POST_COPROC		0x00400000
+#define CONFIG_SYS_POST_FLASH		0x00800000
 
 #endif /* CONFIG_POST */
 
Index: u-boot-2011.06/include/scsi.h
===================================================================
--- u-boot-2011.06.orig/include/scsi.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/scsi.h	2011-09-20 17:03:31.180018148 +0200
@@ -185,6 +185,7 @@
  * functions residing inside cmd_scsi.c
  */
 void scsi_init(void);
+void scsi_scan(int mode);
 
 
 #define SCSI_IDENTIFY					0xC0  /* not used */
Index: u-boot-2011.06/include/search.h
===================================================================
--- u-boot-2011.06.orig/include/search.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/search.h	2011-09-20 17:03:31.180018148 +0200
@@ -39,7 +39,7 @@
 } ACTION;
 
 typedef struct entry {
-	char *key;
+	const char *key;
 	char *data;
 } ENTRY;
 
Index: u-boot-2011.06/include/ubi_uboot.h
===================================================================
--- u-boot-2011.06.orig/include/ubi_uboot.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/ubi_uboot.h	2011-09-20 17:03:31.180018148 +0200
@@ -191,9 +191,6 @@
 	return IS_ERR_VALUE((unsigned long)ptr);
 }
 
-/* Force a compilation error if condition is true */
-#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
-
 /* module */
 #define THIS_MODULE		0
 #define try_module_get(...)	1
Index: u-boot-2011.06/include/usb.h
===================================================================
--- u-boot-2011.06.orig/include/usb.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/usb.h	2011-09-20 17:03:31.180018148 +0200
@@ -46,7 +46,7 @@
  * This is the timeout to allow for submitting an urb in ms. We allow more
  * time for a BULK device to react - some are slow.
  */
-#define USB_TIMEOUT_MS(pipe) (usb_pipebulk(pipe) ? 5000 : 100)
+#define USB_TIMEOUT_MS(pipe) (usb_pipebulk(pipe) ? 5000 : 1000)
 
 /* device request (setup) */
 struct devrequest {
Index: u-boot-2011.06/include/version.h
===================================================================
--- u-boot-2011.06.orig/include/version.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/include/version.h	2011-09-20 17:03:31.180018148 +0200
@@ -24,8 +24,20 @@
 #ifndef	__VERSION_H__
 #define	__VERSION_H__
 
+#include <timestamp.h>
+
 #ifndef DO_DEPS_ONLY
 #include "version_autogenerated.h"
 #endif
 
+#ifndef CONFIG_IDENT_STRING
+#define CONFIG_IDENT_STRING ""
+#endif
+
+#define U_BOOT_VERSION_STRING U_BOOT_VERSION " (" U_BOOT_DATE " - " \
+	U_BOOT_TIME ")" CONFIG_IDENT_STRING
+
+#ifndef __ASSEMBLY__
+extern const char version_string[];
+#endif	/* __ASSEMBLY__ */
 #endif	/* __VERSION_H__ */
Index: u-boot-2011.06/lib/display_options.c
===================================================================
--- u-boot-2011.06.orig/lib/display_options.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/display_options.c	2011-09-20 17:03:31.180018148 +0200
@@ -23,13 +23,12 @@
 
 #include <config.h>
 #include <common.h>
+#include <version.h>
 #include <linux/ctype.h>
 #include <asm/io.h>
 
 int display_options (void)
 {
-	extern char version_string[];
-
 #if defined(BUILD_TAG)
 	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
 #else
Index: u-boot-2011.06/lib/hashtable.c
===================================================================
--- u-boot-2011.06.orig/lib/hashtable.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/hashtable.c	2011-09-20 17:03:31.180018148 +0200
@@ -155,7 +155,7 @@
 		if (htab->table[i].used > 0) {
 			ENTRY *ep = &htab->table[i].entry;
 
-			free(ep->key);
+			free((void *)ep->key);
 			free(ep->data);
 		}
 	}
@@ -416,7 +416,7 @@
 	/* free used ENTRY */
 	debug("hdelete: DELETING key \"%s\"\n", key);
 
-	free(ep->key);
+	free((void *)ep->key);
 	free(ep->data);
 	htab->table[idx].used = -1;
 
@@ -564,7 +564,7 @@
 	 * export sorted list of result data
 	 */
 	for (i = 0, p = res; i < n; ++i) {
-		char *s;
+		const char *s;
 
 		s = list[i]->key;
 		while (*s)
Index: u-boot-2011.06/lib/libfdt/fdt.c
===================================================================
--- u-boot-2011.06.orig/lib/libfdt/fdt.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/libfdt/fdt.c	2011-09-20 17:03:31.180018148 +0200
@@ -153,6 +153,15 @@
 	return offset;
 }
 
+int _fdt_check_prop_offset(const void *fdt, int offset)
+{
+	if ((offset < 0) || (offset % FDT_TAGSIZE)
+	    || (fdt_next_tag(fdt, offset, &offset) != FDT_PROP))
+		return -FDT_ERR_BADOFFSET;
+
+	return offset;
+}
+
 int fdt_next_node(const void *fdt, int offset, int *depth)
 {
 	int nextoffset = 0;
Index: u-boot-2011.06/lib/libfdt/fdt_ro.c
===================================================================
--- u-boot-2011.06.orig/lib/libfdt/fdt_ro.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/libfdt/fdt_ro.c	2011-09-20 17:03:31.180018148 +0200
@@ -109,6 +109,30 @@
 	return i;
 }
 
+static int _nextprop(const void *fdt, int offset)
+{
+	uint32_t tag;
+	int nextoffset;
+
+	do {
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		switch (tag) {
+		case FDT_END:
+			if (nextoffset >= 0)
+				return -FDT_ERR_BADSTRUCTURE;
+			else
+				return nextoffset;
+
+		case FDT_PROP:
+			return offset;
+		}
+		offset = nextoffset;
+	} while (tag == FDT_NOP);
+
+	return -FDT_ERR_NOTFOUND;
+}
+
 int fdt_subnode_offset_namelen(const void *fdt, int offset,
 			       const char *name, int namelen)
 {
@@ -198,52 +222,66 @@
 	return NULL;
 }
 
-const struct fdt_property *fdt_get_property_namelen(const void *fdt,
-						    int nodeoffset,
-						    const char *name,
-						    int namelen, int *lenp)
+int fdt_first_property_offset(const void *fdt, int nodeoffset)
+{
+	int offset;
+
+	if ((offset = _fdt_check_node_offset(fdt, nodeoffset)) < 0)
+		return offset;
+
+	return _nextprop(fdt, offset);
+}
+
+int fdt_next_property_offset(const void *fdt, int offset)
+{
+	if ((offset = _fdt_check_prop_offset(fdt, offset)) < 0)
+		return offset;
+
+	return _nextprop(fdt, offset);
+}
+
+const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
+						      int offset,
+						      int *lenp)
 {
-	uint32_t tag;
-	const struct fdt_property *prop;
-	int offset, nextoffset;
 	int err;
+	const struct fdt_property *prop;
 
-	if (((err = fdt_check_header(fdt)) != 0)
-	    || ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))
-			goto fail;
+	if ((err = _fdt_check_prop_offset(fdt, offset)) < 0) {
+		if (lenp)
+			*lenp = err;
+		return NULL;
+	}
 
-	nextoffset = err;
-	do {
-		offset = nextoffset;
+	prop = _fdt_offset_ptr(fdt, offset);
 
-		tag = fdt_next_tag(fdt, offset, &nextoffset);
-		switch (tag) {
-		case FDT_END:
-			if (nextoffset < 0)
-				err = nextoffset;
-			else
-				/* FDT_END tag with unclosed nodes */
-				err = -FDT_ERR_BADSTRUCTURE;
-			goto fail;
+	if (lenp)
+		*lenp = fdt32_to_cpu(prop->len);
 
-		case FDT_PROP:
-			prop = _fdt_offset_ptr(fdt, offset);
-			if (_fdt_string_eq(fdt, fdt32_to_cpu(prop->nameoff),
-					   name, namelen)) {
-				/* Found it! */
-				if (lenp)
-					*lenp = fdt32_to_cpu(prop->len);
+	return prop;
+}
 
-				return prop;
-			}
+const struct fdt_property *fdt_get_property_namelen(const void *fdt,
+						    int offset,
+						    const char *name,
+						    int namelen, int *lenp)
+{
+	for (offset = fdt_first_property_offset(fdt, offset);
+	     (offset >= 0);
+	     (offset = fdt_next_property_offset(fdt, offset))) {
+		const struct fdt_property *prop;
+
+		if (!(prop = fdt_get_property_by_offset(fdt, offset, lenp))) {
+			offset = -FDT_ERR_INTERNAL;
 			break;
 		}
-	} while ((tag != FDT_BEGIN_NODE) && (tag != FDT_END_NODE));
+		if (_fdt_string_eq(fdt, fdt32_to_cpu(prop->nameoff),
+				   name, namelen))
+			return prop;
+	}
 
-	err = -FDT_ERR_NOTFOUND;
- fail:
 	if (lenp)
-		*lenp = err;
+		*lenp = offset;
 	return NULL;
 }
 
@@ -267,6 +305,19 @@
 	return prop->data;
 }
 
+const void *fdt_getprop_by_offset(const void *fdt, int offset,
+				  const char **namep, int *lenp)
+{
+	const struct fdt_property *prop;
+
+	prop = fdt_get_property_by_offset(fdt, offset, lenp);
+	if (!prop)
+		return NULL;
+	if (namep)
+		*namep = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
+	return prop->data;
+}
+
 const void *fdt_getprop(const void *fdt, int nodeoffset,
 			const char *name, int *lenp)
 {
@@ -278,9 +329,14 @@
 	const uint32_t *php;
 	int len;
 
-	php = fdt_getprop(fdt, nodeoffset, "linux,phandle", &len);
-	if (!php || (len != sizeof(*php)))
-		return 0;
+	/* FIXME: This is a bit sub-optimal, since we potentially scan
+	 * over all the properties twice. */
+	php = fdt_getprop(fdt, nodeoffset, "phandle", &len);
+	if (!php || (len != sizeof(*php))) {
+		php = fdt_getprop(fdt, nodeoffset, "linux,phandle", &len);
+		if (!php || (len != sizeof(*php)))
+			return 0;
+	}
 
 	return fdt32_to_cpu(*php);
 }
@@ -440,11 +496,27 @@
 
 int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)
 {
+	int offset;
+
 	if ((phandle == 0) || (phandle == -1))
 		return -FDT_ERR_BADPHANDLE;
-	phandle = cpu_to_fdt32(phandle);
-	return fdt_node_offset_by_prop_value(fdt, -1, "linux,phandle",
-					     &phandle, sizeof(phandle));
+
+	FDT_CHECK_HEADER(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we
+	 * potentially scan each property of a node in
+	 * fdt_get_phandle(), then if that didn't find what
+	 * we want, we scan over them again making our way to the next
+	 * node.  Still it's the easiest to implement approach;
+	 * performance can come later. */
+	for (offset = fdt_next_node(fdt, -1, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		if (fdt_get_phandle(fdt, offset) == phandle)
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
 }
 
 static int _fdt_stringlist_contains(const char *strlist, int listlen,
Index: u-boot-2011.06/lib/libfdt/libfdt_internal.h
===================================================================
--- u-boot-2011.06.orig/lib/libfdt/libfdt_internal.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/libfdt/libfdt_internal.h	2011-09-20 17:03:31.180018148 +0200
@@ -63,6 +63,7 @@
 	}
 
 int _fdt_check_node_offset(const void *fdt, int offset);
+int _fdt_check_prop_offset(const void *fdt, int offset);
 const char *_fdt_find_string(const char *strtab, int tabsize, const char *s);
 int _fdt_node_end_offset(void *fdt, int nodeoffset);
 
Index: u-boot-2011.06/lib/lzma/history.txt
===================================================================
--- u-boot-2011.06.orig/lib/lzma/history.txt	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/lzma/history.txt	2011-09-20 17:03:31.180018148 +0200
@@ -41,7 +41,7 @@
 
 4.57           2007-12-12
 -------------------------
-- Speed optimizations in —++ LZMA Decoder.
+- Speed optimizations in √ë++ LZMA Decoder.
 - Small changes for more compatibility with some C/C++ compilers.
 
 
Index: u-boot-2011.06/lib/Makefile
===================================================================
--- u-boot-2011.06.orig/lib/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/Makefile	2011-09-20 17:03:31.180018148 +0200
@@ -25,6 +25,7 @@
 
 LIB	= $(obj)libgeneric.o
 
+ifndef CONFIG_SPL_BUILD
 COBJS-$(CONFIG_ADDR_MAP) += addr_map.o
 COBJS-$(CONFIG_BZIP2) += bzlib.o
 COBJS-$(CONFIG_BZIP2) += bzlib_crctable.o
@@ -35,9 +36,7 @@
 COBJS-y += crc7.o
 COBJS-y += crc16.o
 COBJS-y += crc32.o
-COBJS-y += ctype.o
 COBJS-y += display_options.o
-COBJS-y += div64.o
 COBJS-y += errno.o
 COBJS-$(CONFIG_GZIP) += gunzip.o
 COBJS-y += hashtable.o
@@ -48,11 +47,15 @@
 COBJS-y += qsort.o
 COBJS-$(CONFIG_SHA1) += sha1.o
 COBJS-$(CONFIG_SHA256) += sha256.o
-COBJS-y += string.o
 COBJS-y	+= strmhz.o
+COBJS-$(CONFIG_RBTREE)	+= rbtree.o
+endif
+
+COBJS-y += ctype.o
+COBJS-y += div64.o
+COBJS-y += string.o
 COBJS-y += time.o
 COBJS-y += vsprintf.o
-COBJS-$(CONFIG_RBTREE)	+= rbtree.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
Index: u-boot-2011.06/lib/qsort.c
===================================================================
--- u-boot-2011.06.orig/lib/qsort.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/qsort.c	2011-09-20 17:03:31.180018148 +0200
@@ -17,11 +17,6 @@
 
 #include <linux/types.h>
 #include <exports.h>
-#if 0
-#include <assert.h>
-#else
-#define assert(arg)
-#endif
 
 void qsort(void  *base,
 	   size_t nel,
Index: u-boot-2011.06/lib/string.c
===================================================================
--- u-boot-2011.06.orig/lib/string.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/string.c	2011-09-20 17:03:31.190018148 +0200
@@ -467,6 +467,9 @@
 	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
 	char *d8, *s8;
 
+	if (src == dest)
+		return dest;
+
 	/* while all data is aligned (common case), copy a word at a time */
 	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
 		while (count >= sizeof(*dl)) {
@@ -497,6 +500,9 @@
 {
 	char *tmp, *s;
 
+	if (src == dest)
+		return dest;
+
 	if (dest <= src) {
 		tmp = (char *) dest;
 		s = (char *) src;
Index: u-boot-2011.06/lib/vsprintf.c
===================================================================
--- u-boot-2011.06.orig/lib/vsprintf.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/lib/vsprintf.c	2011-09-20 17:03:31.190018148 +0200
@@ -727,4 +727,14 @@
 	udelay (100000);	/* allow messages to go out */
 	do_reset (NULL, 0, 0, NULL);
 #endif
+	while (1)
+		;
+}
+
+void __assert_fail(const char *assertion, const char *file, unsigned line,
+		   const char *function)
+{
+	/* This will not return */
+	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
+	      assertion);
 }
Index: u-boot-2011.06/MAINTAINERS
===================================================================
--- u-boot-2011.06.orig/MAINTAINERS	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/MAINTAINERS	2011-09-20 17:03:31.190018148 +0200
@@ -74,7 +74,7 @@
 
 	MPC837xERDB	MPC837x
 
-K·ri DavÌsson <kd@flaga.is>
+K√°ri Dav√≠√∞sson <kd@flaga.is>
 
 	FLAGADM		MPC823
 
@@ -142,6 +142,10 @@
 
 	mpq101		MPC8548
 
+Phil Edworthy <phil.edworthy@renesas.com>
+
+	rsk7264		SH7264
+
 Dirk Eibach <eibach@gdsys.de>
 
 	devconcenter	PPC460EX
@@ -193,12 +197,6 @@
 	WUH405		PPC405EP
 	CMS700		PPC405EP
 
-Niklaus Giger <niklaus.giger@netstal.com>
-
-	HCU4		PPC405GPr
-	MCU25		PPC405GPr
-	HCU5		PPC440EPx
-
 Siddarth Gore <gores@marvell.com>
 
 	guruplug	ARM926EJS (Kirkwood SoC)
@@ -451,6 +449,7 @@
 
 Andre Schwarz <andre.schwarz@matrix-vision.de>
 
+	mergerbox	MPC8377
 	mvbc_p		MPC5200
 	mvblm7		MPC8343
 	mvsmr		MPC5200
@@ -516,6 +515,7 @@
 Roy Zang <tie-fei.zang@freescale.com>
 
 	mpc7448hpc2	MPC7448
+	P1023RDS	P1023
 
 John Zhan <zhanz@sinovee.com>
 
@@ -548,6 +548,8 @@
 
 	EVB64260	MPC7xx_74xx
 
+	versatile	ARM926EJ-S
+
 
 #########################################################################
 # ARM Systems:								#
@@ -560,10 +562,6 @@
 
 	edminiv2	ARM926EJS (Orion5x SoC)
 
-Rowel Atienza <rowel@diwalabs.com>
-
-	armadillo	ARM720T
-
 Stefano Babic <sbabic@denx.de>
 
 	ea20		davinci
@@ -593,13 +591,18 @@
 	cpu9260		ARM926EJS (AT91SAM9260 SoC)
 	cpu9G20		ARM926EJS (AT91SAM9G20 SoC)
 
+Ajay Bhargav <ajay.bhargav@einfochips.com>
+
+	gplugd		ARM926EJS (ARMADA100 88AP168 SoC)
+
 Rishi Bhattacharya <rishi@ti.com>
 
 	omap5912osk	ARM926EJS
 
-Andreas Bieﬂmann <andreas.devel@gmail.com>
+Andreas Bie√ümann <andreas.devel@gmail.com>
 
 	at91rm9200ek	at91rm9200
+	grasshopper	avr32
 
 Cliff Brake <cliff.brake@gmail.com>
 
@@ -621,19 +624,10 @@
 
 	dockstar	ARM926EJS (Kirkwood SoC)
 
-George G. Davis <gdavis@mvista.com>
-
-	assabet		SA1100
-	gcplus		SA1100
-
 Wolfgang Denk <wd@denx.de>
 	imx27lite	i.MX27
 	qong		i.MX31
 
-Thomas Elste <info@elste.org>
-
-	modnet50	ARM720T (NET+50)
-
 Kristoffer Ericson <kristoffer.ericson@gmail.com>
 
 	jornada	SA1110
@@ -641,6 +635,7 @@
 Fabio Estevam <fabio.estevam@freescale.com>
 
 	mx31pdk		i.MX31
+	mx53ard		i.MX53
 	mx53smd		i.MX53
 
 Daniel Gorsulowski <daniel.gorsulowski@esd.eu>
@@ -652,10 +647,11 @@
 	at91sam9g10ek		ARM926EJS (AT91SAM9G10 SoC)
 	at91sam9m10g45ek	ARM926EJS (AT91SAM9G45 SoC)
 
-Marius Grˆger <mag@sysgo.de>
+Simon Guinot <simon.guinot@sequanux.org>
 
-	impa7		ARM720T (EP7211)
-	ep7312		ARM720T (EP7312)
+	inetspace_v2	ARM926EJS (Kirkwood SoC)
+	netspace_v2	ARM926EJS (Kirkwood SoC)
+	netspace_max_v2	ARM926EJS (Kirkwood SoC)
 
 Igor Grinberg <grinberg@compulab.co.il>
 
@@ -674,10 +670,6 @@
 
 	omap3_pandora	ARM ARMV7 (OMAP3xx SoC)
 
-Gary Jennejohn <garyj@denx.de>
-
-	smdk2400	ARM920T
-
 Matthias Kaehlcke <matthias@kaehlcke.net>
 	edb9301			ARM920T (EP9301)
 	edb9302			ARM920T (EP9302)
@@ -688,9 +680,6 @@
 	edb9315			ARM920T (EP9315)
 	edb9315a		ARM920T (EP9315)
 
-Konstantin Kletschke <kletschke@synertronixx.de>
-	scb9328		ARM920T
-
 Nishant Kamat <nskamat@ti.com>
 
 	omap1610h2	ARM926EJS
@@ -703,8 +692,12 @@
 
 Chander Kashyap <k.chander@samsung.com>
 
+	origen			ARM ARMV7 (S5PC210 SoC)
 	SMDKV310		ARM ARMV7 (S5PC210 SoC)
 
+Torsten Koschorrek <koschorrek@synertronixx.de>
+	scb9328		ARM920T (i.MXL)
+
 Frederik Kriewitz <frederik@kriewitz.eu>
 
 	devkit8000	ARM ARMV7 (OMAP3530 SoC)
@@ -730,12 +723,17 @@
 
 	afeb9260	ARM926EJS (AT91SAM9260 SoC)
 
+Valentin Longchamp <valentin.longchamp@keymile.com>
+
+	km_kirkwood	ARM926EJS (Kirkwood SoC)
+	portl2		ARM926EJS (Kirkwood SoC)
+
 Nishanth Menon <nm@ti.com>
 
 	omap3_sdp3430	ARM ARMV7 (OMAP3xx SoC)
 	omap3_zoom1	ARM ARMV7 (OMAP3xx SoC)
 
-David M¸ller <d.mueller@elsoft.ch>
+David M√ºller <d.mueller@elsoft.ch>
 
 	smdk2410	ARM920T
 	VCMA9		ARM920T
@@ -748,10 +746,6 @@
 
    am3517_crane    ARM ARMV7 (AM35x SoC)
 
-Rolf Offermanns <rof@sysgo.de>
-
-	shannon		SA1100
-
 Kyungmin Park <kyungmin.park@samsung.com>
 
 	apollon		ARM1136EJS
@@ -763,11 +757,9 @@
 	davinci_dm365evm	ARM926EJS
 	davinci_dm6467evm	ARM926EJS
 
-Peter Pearse <peter.pearse@arm.com>
-	integratorcp	All current ARM supplied & supported core modules
-			-see http://www.arm.com/products/DevTools/Hardware_Platforms.html
-	versatile	ARM926EJ-S
-	versatile	ARM926EJ-S
+Linus Walleij <linus.walleij@linaro.org>
+	integratorap	various
+	integratorcp	various
 
 Dave Peverley <dpeverley@mpc-data.co.uk>
 
@@ -779,7 +771,6 @@
 
 Stelian Pop <stelian.pop@leadtechdesign.com>
 
-	at91cap9adk	ARM926EJS (AT91CAP9 SoC)
 	at91sam9260ek	ARM926EJS (AT91SAM9260 SoC)
 	at91sam9261ek	ARM926EJS (AT91SAM9261 SoC)
 	at91sam9263ek	ARM926EJS (AT91SAM9263 SoC)
@@ -818,8 +809,6 @@
 
 	magnesium	i.MX27
 	mgcoge3un	ARM926EJS (Kirkwood SoC)
-	suen3		ARM926EJS (Kirkwood SoC)
-	suen8		ARM926EJS (Kirkwood SoC)
 
 Robert Schwebel <r.schwebel@pengutronix.de>
 
@@ -834,10 +823,6 @@
 	actux4		xscale/ixp
 	dvlhost		xscale/ixp
 
-Andrea Scian <andrea.scian@dave-tech.it>
-
-	B2		ARM7TDMI (S3C44B0X)
-
 Nick Thompson <nick.thompson@gefanuc.com>
 
 	da830evm	ARM926EJS (DA830/OMAP-L137)
@@ -892,16 +877,12 @@
 Matthias Weisser <weisserm@arcor.de>
 
 	jadecpu		ARM926EJS (MB86R01 SoC)
+	zmx25		ARM926EJS (imx25 SoC)
 
 Richard Woodruff <r-woodruff2@ti.com>
 
 	omap2420h4	ARM1136EJS
 
-Alex Z¸pke <azu@sysgo.de>
-
-	lart		SA1100
-	dnp1110		SA1110
-
 Syed Mohammed Khasim <sm.khasim@gmail.com>
 Sughosh Ganu <urwithsughosh@gmail.com>
 
Index: u-boot-2011.06/MAKEALL
===================================================================
--- u-boot-2011.06.orig/MAKEALL	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/MAKEALL	2011-09-20 17:03:31.190018148 +0200
@@ -1,58 +1,54 @@
 #!/bin/bash
-
 # Tool mainly for U-Boot Quality Assurance: build one or more board
 # configurations with minimal verbosity, showing only warnings and
 # errors.
-#
-# There are several ways to select which boards to build.
-#
-# Traditionally, architecture names (like "powerpc"), CPU family names
-# (like "mpc83xx") or board names can be specified on the command
-# line; without any arguments, MAKEALL defaults to building all Power
-# Architecture systems (i. e. same as for "MAKEALL powerpc").
-#
-# With the introduction of the board.cfg file, it has become possible
-# to provide additional selections.  We use standard command line
-# options for this:
-#
-# -a or --arch	:	Select architecture
-# -c or --cpu	:	Select CPU family
-# -s or --soc	:	Select SoC type
-# -v or --vendor:	Select board vendor
-#
-# Selections by these options are logically ANDed; if the same option
-# is used repeatedly, such selections are ORed.  So "-v FOO -v BAR"
-# will select all configurations where the vendor is either FOO or
-# BAR.  Any additional arguments specified on the command line are
-# always build additionally.
-#
-# Examples:
-#
-# - build all Power Architecture boards:
-#
-#	MAKEALL -a powerpc
-#   or
-#	MAKEALL --arch powerpc
-#   or
-#	MAKEALL powerpc
-#
-# - build all PowerPC boards manufactured by vendor "esd":
-#
-#	MAKEALL -a powerpc -v esd
-#
-# - build all PowerPC boards manufactured either by "keymile" or
-#   "siemens":
-#
-#	MAKEALL -a powerpc -v keymile -v siemens
-#
-# - build all Freescale boards with MPC83xx CPUs, plus all 4xx boards:
-#
-#	MAKEALL -c mpc83xx -v freescale 4xx
-#
-#########################################################################
 
-SHORT_OPTS="a:c:v:s:"
-LONG_OPTS="arch:,cpu:,vendor:,soc:"
+usage()
+{
+	# if exiting with 0, write to stdout, else write to stderr
+	local ret=${1:-0}
+	[ "${ret}" -eq 1 ] && exec 1>&2
+	cat <<-EOF
+	Usage: MAKEALL [options] [--] [boards-to-build]
+
+	Options:
+	  -a ARCH,   --arch ARCH       Build all boards with arch ARCH
+	  -c CPU,    --cpu CPU         Build all boards with cpu CPU
+	  -v VENDOR, --vendor VENDOR   Build all boards with vendor VENDOR
+	  -s SOC,    --soc SOC         Build all boards with soc SOC
+	  -h,        --help            This help output
+
+	Selections by these options are logically ANDed; if the same option
+	is used repeatedly, such selections are ORed.  So "-v FOO -v BAR"
+	will select all configurations where the vendor is either FOO or
+	BAR.  Any additional arguments specified on the command line are
+	always build additionally.  See the boards.cfg file for more info.
+
+	If no boards are specified, then the default is "powerpc".
+
+	Environment variables:
+	  BUILD_NCPUS      number of parallel make jobs (default: auto)
+	  CROSS_COMPILE    cross-compiler toolchain prefix (default: "")
+	  MAKEALL_LOGDIR   output all logs to here (default: ./LOG/)
+	  BUILD_DIR        output build directory (default: ./)
+
+	Examples:
+	  - build all Power Architecture boards:
+	      MAKEALL -a powerpc
+	      MAKEALL --arch powerpc
+	      MAKEALL powerpc
+	  - build all PowerPC boards manufactured by vendor "esd":
+	      MAKEALL -a powerpc -v esd
+	  - build all PowerPC boards manufactured either by "keymile" or "siemens":
+	      MAKEALL -a powerpc -v keymile -v siemens
+	  - build all Freescale boards with MPC83xx CPUs, plus all 4xx boards:
+	      MAKEALL -c mpc83xx -v freescale 4xx
+	EOF
+	exit ${ret}
+}
+
+SHORT_OPTS="ha:c:v:s:"
+LONG_OPTS="help,arch:,cpu:,vendor:,soc:"
 
 # Option processing based on util-linux-2.13/getopt-parse.bash
 
@@ -63,7 +59,7 @@
 TEMP=`getopt -o ${SHORT_OPTS} --long ${LONG_OPTS} \
      -n 'MAKEALL' -- "$@"`
 
-if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
+[ $? != 0 ] && usage 1
 
 # Note the quotes around `$TEMP': they are essential!
 eval set -- "$TEMP"
@@ -108,6 +104,8 @@
 		fi
 		SELECTED='y'
 		shift 2 ;;
+	-h|--help)
+		usage ;;
 	--)
 		shift ; break ;;
 	*)
@@ -299,165 +297,40 @@
 LIST_SA="$(boards_by_cpu sa1100)"
 
 #########################################################################
-## ARM7 Systems
-#########################################################################
-
-LIST_ARM7="		\
-	ap7		\
-	ap720t		\
-	armadillo	\
-	B2		\
-	ep7312		\
-	evb4510		\
-	impa7		\
-	integratorap	\
-	lpc2292sodimm	\
-	modnet50	\
-	SMN42		\
-"
-
-#########################################################################
 ## ARM9 Systems
 #########################################################################
 
-LIST_ARM9="			\
-	a320evb			\
-	ap920t			\
-	ap922_XA10		\
-	ap926ejs		\
-	ap946es			\
-	ap966			\
-	aspenite		\
-	cp920t			\
-	cp922_XA10		\
-	cp926ejs		\
-	cp946es			\
-	cp966			\
-	da830evm		\
-	da850evm		\
-	edb9301			\
-	edb9302			\
-	edb9302a		\
-	edb9307			\
-	edb9307a		\
-	edb9312			\
-	edb9315			\
-	edb9315a		\
-	edminiv2		\
-	guruplug		\
-	imx27lite		\
-	jadecpu			\
-	lpd7a400		\
-	magnesium		\
-	mv88f6281gtw_ge		\
-	mx1ads			\
-	mx1fs2			\
-	netstar			\
-	nhk8815			\
-	nhk8815_onenand		\
-	omap1510inn		\
+LIST_ARM9="$(boards_by_cpu arm920t)	\
+	$(boards_by_cpu arm926ejs)	\
+	$(boards_by_cpu arm925t)	\
 	omap1610h2		\
 	omap1610inn		\
-	omap5912osk		\
 	omap730p2		\
-	openrd_base		\
-	openrd_client		\
-	openrd_ultimate		\
-	rd6281a			\
-	sbc2410x		\
-	scb9328			\
-	sheevaplug		\
-	smdk2400		\
-	smdk2410		\
-	spear300		\
-	spear310		\
-	spear320		\
-	spear600		\
-	suen3			\
-	VCMA9			\
-	versatile		\
-	versatileab		\
-	versatilepb		\
-	voiceblue		\
-	davinci_dvevm		\
-	davinci_schmoogie	\
-	davinci_sffsdr		\
-	davinci_sonata		\
-	davinci_dm355evm	\
-	davinci_dm355leopard	\
-	davinci_dm365evm	\
-	davinci_dm6467evm	\
-"
-
-#########################################################################
-## ARM10 Systems
-#########################################################################
-LIST_ARM10="		\
-	integratorcp	\
-	cp1026		\
 "
 
 #########################################################################
 ## ARM11 Systems
 #########################################################################
-LIST_ARM11="			\
-	cp1136			\
-	omap2420h4		\
+LIST_ARM11="$(boards_by_cpu arm1136)	\
 	apollon			\
-	imx31_litekit		\
 	imx31_phycore		\
 	imx31_phycore_eet	\
-	mx31ads			\
 	mx31pdk			\
 	mx31pdk_nand		\
-	qong			\
 	smdk6400		\
-	tnetv107x_evm		\
 "
 
 #########################################################################
 ## ARMV7 Systems
 #########################################################################
-LIST_ARMV7="		\
-	am3517_crane		\
-	am3517_evm		\
-	ca9x4_ct_vxp		\
-	devkit8000		\
-	dig297			\
-	igep0020		\
-	igep0030		\
-	mx51evk			\
-	omap3_beagle		\
-	omap3_overo		\
-	omap3_evm		\
-	omap3_pandora		\
-	omap3_sdp3430		\
-	omap3_zoom1		\
-	omap3_zoom2		\
-	omap4_panda		\
-	omap4_sdp4430		\
-	s5p_goni		\
-	smdkc100		\
-"
+
+LIST_ARMV7="$(boards_by_cpu armv7)"
 
 #########################################################################
 ## AT91 Systems
 #########################################################################
 
-LIST_at91="$(boards_by_soc at91)\
-	$(boards_by_soc at91rm9200)\
-	at91sam9260ek		\
-	at91sam9261ek		\
-	at91sam9263ek		\
-	at91sam9g10ek		\
-	at91sam9g20ek		\
-	at91sam9m10g45ek	\
-	at91sam9rlek		\
-	pm9g45			\
-	SBC35_A9G20		\
-	TNY_A9260		\
-	TNY_A9G20		\
-"
+LIST_at91="$(boards_by_soc at91)"
 
 #########################################################################
 ## Xscale Systems
@@ -476,7 +349,6 @@
 
 LIST_arm="			\
 	${LIST_SA}		\
-	${LIST_ARM7}		\
 	${LIST_ARM9}		\
 	${LIST_ARM10}		\
 	${LIST_ARM11}		\
@@ -553,9 +425,7 @@
 ## Nios-II Systems
 #########################################################################
 
-LIST_nios2="$(boards_by_arch nios2)
-	nios2-generic	\
-"
+LIST_nios2="$(boards_by_arch nios2)"
 
 #########################################################################
 ## MicroBlaze Systems
Index: u-boot-2011.06/Makefile
===================================================================
--- u-boot-2011.06.orig/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/Makefile	2011-09-20 17:03:31.190018148 +0200
@@ -22,9 +22,9 @@
 #
 
 VERSION = 2011
-PATCHLEVEL = 06
+PATCHLEVEL = 09
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = -rc1
 ifneq "$(SUBLEVEL)" ""
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 else
@@ -104,10 +104,11 @@
 endif # ifneq ($(BUILD_DIR),)
 
 OBJTREE		:= $(if $(BUILD_DIR),$(BUILD_DIR),$(CURDIR))
+SPLTREE		:= $(OBJTREE)/spl
 SRCTREE		:= $(CURDIR)
 TOPDIR		:= $(SRCTREE)
 LNDIR		:= $(OBJTREE)
-export	TOPDIR SRCTREE OBJTREE
+export	TOPDIR SRCTREE OBJTREE SPLTREE
 
 MKCONFIG	:= $(SRCTREE)/mkconfig
 export MKCONFIG
@@ -341,22 +342,15 @@
 endif
 
 # Always append ALL so that arch config.mk's can add custom ones
-ALL += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map
+ALL-y += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map
 
-ifeq ($(CONFIG_NAND_U_BOOT),y)
-ALL += $(obj)u-boot-nand.bin
-endif
-
-ifeq ($(CONFIG_ONENAND_U_BOOT),y)
-ALL += $(obj)u-boot-onenand.bin
+ALL-$(CONFIG_NAND_U_BOOT) += $(obj)u-boot-nand.bin
+ALL-$(CONFIG_ONENAND_U_BOOT) += $(obj)u-boot-onenand.bin
 ONENAND_BIN ?= $(obj)onenand_ipl/onenand-ipl-2k.bin
-endif
-
-ifeq ($(CONFIG_MMC_U_BOOT),y)
-ALL += $(obj)mmc_spl/u-boot-mmc-spl.bin
-endif
+ALL-$(CONFIG_MMC_U_BOOT) += $(obj)mmc_spl/u-boot-mmc-spl.bin
+ALL-$(CONFIG_SPL) += $(obj)spl/u-boot-spl.bin
 
-all:		$(ALL)
+all:		$(ALL-y)
 
 $(obj)u-boot.hex:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@
@@ -381,7 +375,7 @@
 
 $(obj)u-boot.img:	$(obj)u-boot.bin
 		$(obj)tools/mkimage -A $(ARCH) -T firmware -C none \
-		-a $(CONFIG_SYS_TEXT_BASE) -e 0 \
+		-O u-boot -a $(CONFIG_SYS_TEXT_BASE) -e 0 \
 		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
 			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
 		-d $< $@
@@ -400,6 +394,10 @@
 $(obj)u-boot.dis:	$(obj)u-boot
 		$(OBJDUMP) -d $< > $@
 
+$(obj)u-boot.ubl:       $(obj)u-boot-nand.bin
+		$(obj)tools/mkimage -n $(UBL_CONFIG) -T ublimage \
+		-e $(CONFIG_SYS_TEXT_BASE) -d $< $@
+
 GEN_UBOOT = \
 		UNDEF_SYM=`$(OBJDUMP) -x $(LIBBOARD) $(LIBS) | \
 		sed  -n -e 's/.*\($(SYM_PREFIX)__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
@@ -452,6 +450,9 @@
 
 $(obj)mmc_spl/u-boot-mmc-spl.bin:	mmc_spl
 
+$(obj)spl/u-boot-spl.bin:		depend
+		$(MAKE) -C spl all
+
 $(TIMESTAMP_FILE):
 		@LC_ALL=C date +'#define U_BOOT_DATE "%b %d %C%y"' > $@
 		@LC_ALL=C date +'#define U_BOOT_TIME "%T"' >> $@
@@ -463,7 +464,8 @@
 # parallel sub-makes creating .depend files simultaneously.
 depend dep:	$(TIMESTAMP_FILE) $(VERSION_FILE) \
 		$(obj)include/autoconf.mk \
-		$(obj)include/generated/generic-asm-offsets.h
+		$(obj)include/generated/generic-asm-offsets.h \
+		$(obj)include/generated/asm-offsets.h
 		for dir in $(SUBDIRS) $(CPUDIR) $(dir $(LDSCRIPT)) ; do \
 			$(MAKE) -C $$dir _depend ; done
 
@@ -471,15 +473,19 @@
 TAG_SUBDIRS += $(dir $(__LIBS))
 TAG_SUBDIRS += include
 
+FIND := find
+FINDFLAGS := -L
+
 tags ctags:
-		ctags -w -o $(obj)ctags `find $(TAG_SUBDIRS) \
+		ctags -w -o $(obj)ctags `$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) \
 						-name '*.[chS]' -print`
 
 etags:
-		etags -a -o $(obj)etags `find $(TAG_SUBDIRS) \
+		etags -a -o $(obj)etags `$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) \
 						-name '*.[chS]' -print`
 cscope:
-		find $(TAG_SUBDIRS) -name '*.[chS]' -print > cscope.files
+		$(FIND) $(FINDFLAGS) $(TAG_SUBDIRS) -name '*.[chS]' -print > \
+						cscope.files
 		cscope -b -q -k
 
 SYSTEM_MAP = \
@@ -522,6 +528,21 @@
 		$(CFLAGS) $(CFLAGS_$(BCURDIR)/$(@F)) $(CFLAGS_$(BCURDIR)) \
 		-o $@ $(src)lib/asm-offsets.c -c -S
 
+$(obj)include/generated/asm-offsets.h:	$(obj)include/autoconf.mk.dep \
+	$(obj)$(CPUDIR)/$(SOC)/asm-offsets.s
+	@echo Generating $@
+	tools/scripts/make-asm-offsets $(obj)$(CPUDIR)/$(SOC)/asm-offsets.s $@
+
+$(obj)$(CPUDIR)/$(SOC)/asm-offsets.s:	$(obj)include/autoconf.mk.dep
+	@mkdir -p $(obj)$(CPUDIR)/$(SOC)
+	if [ -f $(src)$(CPUDIR)/$(SOC)/asm-offsets.c ];then \
+		$(CC) -DDO_DEPS_ONLY \
+		$(CFLAGS) $(CFLAGS_$(BCURDIR)/$(@F)) $(CFLAGS_$(BCURDIR)) \
+			-o $@ $(src)$(CPUDIR)/$(SOC)/asm-offsets.c -c -S; \
+	else \
+		touch $@; \
+	fi
+
 #########################################################################
 else	# !config.mk
 all $(obj)u-boot.hex $(obj)u-boot.srec $(obj)u-boot.bin \
@@ -536,6 +557,7 @@
 endif	# config.mk
 
 $(VERSION_FILE):
+		@mkdir -p $(dir $(VERSION_FILE))
 		@( localvers='$(shell $(TOPDIR)/tools/setlocalversion $(TOPDIR))' ; \
 		   printf '#define PLAIN_VERSION "%s%s"\n' \
 			"$(U_BOOT_VERSION)" "$${localvers}" ; \
@@ -718,6 +740,7 @@
 		cp $(obj)board/freescale/m54455evb/u-boot.stm $(obj)board/freescale/m54455evb/u-boot.lds ; \
 	fi; \
 	echo "#define CONFIG_SYS_INPUT_CLKSRC $${FREQ}" >> $(obj)include/config.h ; \
+	$(XECHO) "... with $${FREQ}Hz input clock"
 	@$(MKCONFIG) -n $@ -a M54455EVB m68k mcf5445x m54455evb freescale
 
 M5475AFE_config \
@@ -792,132 +815,6 @@
 # ARM
 #========================================================================
 
-#########################################################################
-## ARM926EJ-S Systems
-#########################################################################
-
-at91sam9261ek_nandflash_config \
-at91sam9261ek_dataflash_cs0_config \
-at91sam9261ek_dataflash_cs3_config \
-at91sam9261ek_config \
-at91sam9g10ek_nandflash_config \
-at91sam9g10ek_dataflash_cs0_config \
-at91sam9g10ek_dataflash_cs3_config \
-at91sam9g10ek_config	:	unconfig
-	@mkdir -p $(obj)include
-	@if [ "$(findstring 9g10,$@)" ] ; then \
-		echo "#define CONFIG_AT91SAM9G10EK 1"	>>$(obj)include/config.h ; \
-	else \
-		echo "#define CONFIG_AT91SAM9261EK 1"	>>$(obj)include/config.h ; \
-	fi;
-	@if [ "$(findstring _nandflash,$@)" ] ; then \
-		echo "#define CONFIG_SYS_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
-	elif [ "$(findstring dataflash_cs0,$@)" ] ; then \
-		echo "#define CONFIG_SYS_USE_DATAFLASH_CS3 1"	>>$(obj)include/config.h ; \
-	else \
-		echo "#define CONFIG_SYS_USE_DATAFLASH_CS0 1"	>>$(obj)include/config.h ; \
-	fi;
-	@$(MKCONFIG) -n $@ -a at91sam9261ek arm arm926ejs at91sam9261ek atmel at91
-
-at91sam9263ek_norflash_config \
-at91sam9263ek_norflash_boot_config \
-at91sam9263ek_nandflash_config \
-at91sam9263ek_dataflash_config \
-at91sam9263ek_dataflash_cs0_config \
-at91sam9263ek_config	:	unconfig
-	@mkdir -p $(obj)include
-	@if [ "$(findstring _nandflash,$@)" ] ; then \
-		echo "#define CONFIG_SYS_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
-	elif [ "$(findstring norflash,$@)" ] ; then \
-		echo "#define CONFIG_SYS_USE_NORFLASH 1"	>>$(obj)include/config.h ; \
-	else \
-		echo "#define CONFIG_SYS_USE_DATAFLASH 1"	>>$(obj)include/config.h ; \
-	fi;
-	@if [ "$(findstring norflash_boot,$@)" ] ; then \
-		echo "#define CONFIG_SYS_USE_BOOT_NORFLASH 1"	>>$(obj)include/config.h ; \
-	fi;
-	@$(MKCONFIG) -n $@ -a at91sam9263ek arm arm926ejs at91sam9263ek atmel at91
-
-at91sam9rlek_nandflash_config \
-at91sam9rlek_dataflash_config \
-at91sam9rlek_dataflash_cs0_config \
-at91sam9rlek_config	:	unconfig
-	@mkdir -p $(obj)include
-	@if [ "$(findstring _nandflash,$@)" ] ; then \
-		echo "#define CONFIG_SYS_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
-	else \
-		echo "#define CONFIG_SYS_USE_DATAFLASH 1"	>>$(obj)include/config.h ; \
-	fi;
-	@$(MKCONFIG) -n $@ -a at91sam9rlek arm arm926ejs at91sam9rlek atmel at91
-
-at91sam9m10g45ek_nandflash_config \
-at91sam9m10g45ek_dataflash_config \
-at91sam9m10g45ek_dataflash_cs0_config \
-at91sam9m10g45ek_config \
-at91sam9g45ekes_nandflash_config \
-at91sam9g45ekes_dataflash_config \
-at91sam9g45ekes_dataflash_cs0_config \
-at91sam9g45ekes_config	:	unconfig
-	@mkdir -p $(obj)include
-		@if [ "$(findstring 9m10,$@)" ] ; then \
-		echo "#define CONFIG_AT91SAM9M10G45EK 1"	>>$(obj)include/config.h ; \
-	else \
-		echo "#define CONFIG_AT91SAM9G45EKES 1"	>>$(obj)include/config.h ; \
-	fi;
-	@if [ "$(findstring _nandflash,$@)" ] ; then \
-		echo "#define CONFIG_SYS_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
-	else \
-		echo "#define CONFIG_ATMEL_SPI 1"	>>$(obj)include/config.h ; \
-	fi;
-	@$(MKCONFIG) -n $@ -a at91sam9m10g45ek arm arm926ejs at91sam9m10g45ek atmel at91
-
-pm9g45_config	:	unconfig
-	@mkdir -p $(obj)include
-	@$(MKCONFIG) -a pm9g45 arm arm926ejs pm9g45 ronetix at91
-
-SBC35_A9G20_NANDFLASH_config \
-SBC35_A9G20_EEPROM_config \
-SBC35_A9G20_config	:	unconfig
-	@mkdir -p $(obj)include
-	@echo "#define CONFIG_$(@:_config=) 1" >$(obj)include/config.h
-	@$(MKCONFIG) -n $@ -a sbc35_a9g20 arm arm926ejs sbc35_a9g20 calao at91
-
-TNY_A9G20_NANDFLASH_config \
-TNY_A9G20_EEPROM_config \
-TNY_A9G20_config \
-TNY_A9260_NANDFLASH_config \
-TNY_A9260_EEPROM_config \
-TNY_A9260_config	:	unconfig
-	@mkdir -p $(obj)include
-	@echo "#define CONFIG_$(@:_config=) 1" >$(obj)include/config.h
-	@$(MKCONFIG) -n $@ -a tny_a9260 arm arm926ejs tny_a9260 calao at91
-
-########################################################################
-## ARM Integrator boards - see doc/README-integrator for more info.
-integratorap_config	\
-ap_config		\
-ap966_config		\
-ap922_config		\
-ap922_XA10_config	\
-ap7_config		\
-ap720t_config		\
-ap920t_config		\
-ap926ejs_config		\
-ap946es_config: unconfig
-	@board/armltd/integrator/split_by_variant.sh ap $@
-
-integratorcp_config	\
-cp_config		\
-cp920t_config		\
-cp926ejs_config		\
-cp946es_config		\
-cp1136_config		\
-cp966_config		\
-cp922_config		\
-cp922_XA10_config	\
-cp1026_config: unconfig
-	@board/armltd/integrator/split_by_variant.sh cp $@
-
 xtract_omap1610xxx = $(subst _cs0boot,,$(subst _cs3boot,,$(subst _cs_autoboot,,$(subst _config,,$1))))
 
 omap1610inn_config \
@@ -971,25 +868,6 @@
 	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
 	@$(MKCONFIG) $@ arm arm926ejs tx25 karo mx25
 
-edb9301_config \
-edb9302_config \
-edb9302a_config \
-edb9307_config \
-edb9307a_config \
-edb9312_config \
-edb9315_config \
-edb9315a_config: unconfig
-	@$(MKCONFIG) -n $@ -t $(@:_config=) edb93xx arm arm920t edb93xx - ep93xx
-
-#########################################################################
-# ARM supplied Versatile development boards
-#########################################################################
-
-versatile_config	\
-versatileab_config	\
-versatilepb_config :	unconfig
-	@board/armltd/versatile/split_by_variant.sh $@
-
 #########################################################################
 ## XScale Systems
 #########################################################################
@@ -1047,20 +925,6 @@
 	@$(MKCONFIG) smdk6400 arm arm1176 smdk6400 samsung s3c64xx
 	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
 
-#========================================================================
-# Nios
-#========================================================================
-
-#########################################################################
-## Nios-II
-#########################################################################
-
-# nios2 generic boards
-NIOS2_GENERIC = nios2-generic
-
-$(NIOS2_GENERIC:%=%_config) : unconfig
-	@$(MKCONFIG) $@ nios2 nios2 nios2-generic altera
-
 #########################################################################
 #########################################################################
 
@@ -1085,18 +949,20 @@
 	       $(obj)tools/ncb		   $(obj)tools/ubsha1
 	@rm -f $(obj)board/cray/L1/{bootscript.c,bootscript.image}	  \
 	       $(obj)board/matrix_vision/*/bootscript.img		  \
-	       $(obj)board/netstar/{eeprom,crcek,crcit,*.srec,*.bin}	  \
 	       $(obj)board/voiceblue/eeprom 				  \
-	       $(obj)board/armltd/{integratorap,integratorcp}/u-boot.lds  \
 	       $(obj)u-boot.lds						  \
-	       $(obj)arch/blackfin/cpu/bootrom-asm-offsets.[chs]
+	       $(obj)arch/blackfin/cpu/bootrom-asm-offsets.[chs]	  \
+	       $(obj)arch/blackfin/cpu/init.{lds,elf}
 	@rm -f $(obj)include/bmp_logo.h
 	@rm -f $(obj)lib/asm-offsets.s
-	@rm -f $(obj)nand_spl/{u-boot.lds,u-boot-spl,u-boot-spl.map,System.map}
+	@rm -f $(obj)include/generated/asm-offsets.h
+	@rm -f $(obj)$(CPUDIR)/$(SOC)/asm-offsets.s
+	@rm -f $(obj)nand_spl/{u-boot.lds,u-boot-nand_spl.lds,u-boot-spl,u-boot-spl.map,System.map}
 	@rm -f $(obj)onenand_ipl/onenand-{ipl,ipl.bin,ipl.map}
 	@rm -f $(obj)mmc_spl/{u-boot.lds,u-boot-spl,u-boot-spl.map,u-boot-spl.bin,u-boot-mmc-spl.bin}
 	@rm -f $(ONENAND_BIN)
 	@rm -f $(obj)onenand_ipl/u-boot.lds
+	@rm -f $(obj)spl/{u-boot-spl,u-boot-spl.bin,u-boot-spl.lds,u-boot-spl.map}
 	@rm -f $(TIMESTAMP_FILE) $(VERSION_FILE)
 	@find $(OBJTREE) -type f \
 		\( -name 'core' -o -name '*.bak' -o -name '*~' \
@@ -1110,9 +976,10 @@
 		| xargs -0 rm -f
 	@rm -f $(OBJS) $(obj)*.bak $(obj)ctags $(obj)etags $(obj)TAGS \
 		$(obj)cscope.* $(obj)*.*~
-	@rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL)
+	@rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL-y)
 	@rm -f $(obj)u-boot.kwb
 	@rm -f $(obj)u-boot.imx
+	@rm -f $(obj)u-boot.ubl
 	@rm -f $(obj)tools/{env/crc32.c,inca-swap-bytes}
 	@rm -f $(obj)arch/powerpc/cpu/mpc824x/bedbug_603e.c
 	@rm -fr $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
@@ -1121,12 +988,9 @@
 	@[ ! -d $(obj)onenand_ipl ] || find $(obj)onenand_ipl -name "*" -type l -print | xargs rm -f
 	@[ ! -d $(obj)mmc_spl ] || find $(obj)mmc_spl -name "*" -type l -print | xargs rm -f
 
-ifeq ($(OBJTREE),$(SRCTREE))
-mrproper \
-distclean:	clobber unconfig
-else
 mrproper \
 distclean:	clobber unconfig
+ifneq ($(OBJTREE),$(SRCTREE))
 	rm -rf $(obj)*
 endif
 
Index: u-boot-2011.06/mkconfig
===================================================================
--- u-boot-2011.06.orig/mkconfig	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/mkconfig	2011-09-20 17:03:31.190018148 +0200
@@ -148,7 +148,7 @@
 echo "/* Automatically generated - do not edit */" >>config.h
 
 for i in ${TARGETS} ; do
-	i="`echo ${i} | sed '/=/ {s/=/\t/;q } ; { s/$/\t1/ }'`"
+	i="`echo ${i} | sed '/=/ {s/=/	/;q; } ; { s/$/	1/; }'`"
 	echo "#define CONFIG_${i}" >>config.h ;
 done
 
Index: u-boot-2011.06/nand_spl/nand_boot.c
===================================================================
--- u-boot-2011.06.orig/nand_spl/nand_boot.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/nand_spl/nand_boot.c	2011-09-20 17:03:31.190018148 +0200
@@ -122,10 +122,15 @@
 	nand_command(mtd, block, 0, CONFIG_SYS_NAND_BAD_BLOCK_POS, NAND_CMD_READOOB);
 
 	/*
-	 * Read one byte
+	 * Read one byte (or two if it's a 16 bit chip).
 	 */
-	if (readb(this->IO_ADDR_R) != 0xff)
-		return 1;
+	if (this->options & NAND_BUSWIDTH_16) {
+		if (readw(this->IO_ADDR_R) != 0xffff)
+			return 1;
+	} else {
+		if (readb(this->IO_ADDR_R) != 0xff)
+			return 1;
+	}
 
 	return 0;
 }
Index: u-boot-2011.06/net/bootp.c
===================================================================
--- u-boot-2011.06.orig/net/bootp.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/net/bootp.c	2011-09-20 17:03:31.190018148 +0200
@@ -138,6 +138,36 @@
 	return (curlen);
 }
 
+/*
+ * Check if autoload is enabled. If so, use either NFS or TFTP to download
+ * the boot file.
+ */
+static void auto_load(void)
+{
+	const char *s = getenv("autoload");
+
+	if (s != NULL) {
+		if (*s == 'n') {
+			/*
+			 * Just use BOOTP to configure system;
+			 * Do not use TFTP to load the bootfile.
+			 */
+			NetState = NETLOOP_SUCCESS;
+			return;
+		}
+#if defined(CONFIG_CMD_NFS)
+		if (strcmp(s, "NFS") == 0) {
+			/*
+			 * Use NFS to load the bootfile.
+			 */
+			NfsStart();
+			return;
+		}
+#endif
+	}
+	TftpStart();
+}
+
 #if !defined(CONFIG_CMD_DHCP)
 
 static void BootpVendorFieldProcess (u8 * ext)
@@ -228,6 +258,11 @@
 			NetOurNISDomain[size] = 0;
 		}
 		break;
+#if defined(CONFIG_CMD_SNTP) && defined(CONFIG_BOOTP_NTPSERVER)
+	case 42:	/* NTP server IP */
+		NetCopyIP(&NetNtpServerIP, (IPaddr_t *) (ext + 2));
+		break;
+#endif
 		/* Application layer fields */
 	case 43:		/* Vendor specific info - Not yet supported	*/
 		/*
@@ -278,7 +313,13 @@
 
 	if (NetBootFileSize)
 		debug("NetBootFileSize: %d\n", NetBootFileSize);
+
+#if defined(CONFIG_CMD_SNTP) && defined(CONFIG_BOOTP_NTPSERVER)
+	if (NetNtpServerIP)
+		debug("NetNtpServerIP : %pI4\n", &NetNtpServerIP);
+#endif
 }
+
 /*
  *	Handle a BOOTP received packet.
  */
@@ -287,7 +328,6 @@
 	     unsigned len)
 {
 	Bootp_t *bp;
-	char	*s;
 
 	debug("got BOOTP packet (src=%d, dst=%d, len=%d want_len=%zu)\n",
 		src, dest, len, sizeof (Bootp_t));
@@ -314,26 +354,7 @@
 
 	debug("Got good BOOTP\n");
 
-	if ((s = getenv("autoload")) != NULL) {
-		if (*s == 'n') {
-			/*
-			 * Just use BOOTP to configure system;
-			 * Do not use TFTP to load the bootfile.
-			 */
-			NetState = NETLOOP_SUCCESS;
-			return;
-#if defined(CONFIG_CMD_NFS)
-		} else if (strcmp(s, "NFS") == 0) {
-			/*
-			 * Use NFS to load the bootfile.
-			 */
-			NfsStart();
-			return;
-#endif
-		}
-	}
-
-	TftpStart();
+	auto_load();
 }
 #endif
 
@@ -538,6 +559,11 @@
 	*e++ = 32;
 	e   += 32;
 #endif
+#if defined(CONFIG_BOOTP_NTPSERVER)
+	*e++ = 42;
+	*e++ = 4;
+	e   += 4;
+#endif
 
 	*e++ = 255;		/* End of the list */
 
@@ -907,34 +933,13 @@
 		debug("DHCP State: REQUESTING\n");
 
 		if ( DhcpMessageType((u8 *)bp->bp_vend) == DHCP_ACK ) {
-			char *s;
-
 			if (NetReadLong((ulong*)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
 				DhcpOptionsProcess((u8 *)&bp->bp_vend[4], bp);
 			BootpCopyNetParams(bp); /* Store net params from reply */
 			dhcp_state = BOUND;
 			printf ("DHCP client bound to address %pI4\n", &NetOurIP);
 
-			/* Obey the 'autoload' setting */
-			if ((s = getenv("autoload")) != NULL) {
-				if (*s == 'n') {
-					/*
-					 * Just use BOOTP to configure system;
-					 * Do not use TFTP to load the bootfile.
-					 */
-					NetState = NETLOOP_SUCCESS;
-					return;
-#if defined(CONFIG_CMD_NFS)
-				} else if (strcmp(s, "NFS") == 0) {
-					/*
-					 * Use NFS to load the bootfile.
-					 */
-					NfsStart();
-					return;
-#endif
-				}
-			}
-			TftpStart();
+			auto_load();
 			return;
 		}
 		break;
Index: u-boot-2011.06/net/eth.c
===================================================================
--- u-boot-2011.06.orig/net/eth.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/net/eth.c	2011-09-20 17:03:31.190018148 +0200
@@ -54,10 +54,11 @@
 	return setenv(name, buf);
 }
 
-int eth_getenv_enetaddr_by_index(int index, uchar *enetaddr)
+int eth_getenv_enetaddr_by_index(const char *base_name, int index,
+				 uchar *enetaddr)
 {
 	char enetvar[32];
-	sprintf(enetvar, index ? "eth%daddr" : "ethaddr", index);
+	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
 	return eth_getenv_enetaddr(enetvar, enetaddr);
 }
 
@@ -107,6 +108,8 @@
 {
 	struct eth_device *dev, *target_dev;
 
+	BUG_ON(devname == NULL);
+
 	if (!eth_devices)
 		return NULL;
 
@@ -188,9 +191,49 @@
 #endif
 }
 
+int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
+		   int eth_number)
+{
+	unsigned char env_enetaddr[6];
+	int ret = 0;
+
+	if (!eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr))
+		return -1;
+
+	if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6)) {
+		if (memcmp(dev->enetaddr, "\0\0\0\0\0\0", 6) &&
+			memcmp(dev->enetaddr, env_enetaddr, 6)) {
+			printf("\nWarning: %s MAC addresses don't match:\n",
+				dev->name);
+			printf("Address in SROM is         %pM\n",
+				dev->enetaddr);
+			printf("Address in environment is  %pM\n",
+				env_enetaddr);
+		}
+
+		memcpy(dev->enetaddr, env_enetaddr, 6);
+	}
+
+	if (dev->write_hwaddr &&
+		!eth_mac_skip(eth_number) &&
+		is_valid_ether_addr(dev->enetaddr)) {
+		ret = dev->write_hwaddr(dev);
+	}
+
+	return ret;
+}
+
 int eth_register(struct eth_device *dev)
 {
 	struct eth_device *d;
+
+	size_t len = strlen(dev->name);
+	if (len >= NAMESIZE) {
+		printf("Network driver name is too long (%zu >= %zu): %s\n",
+						len, NAMESIZE, dev->name);
+		return -1;
+	}
+
 	if (!eth_devices) {
 		eth_current = eth_devices = dev;
 		eth_current_changed();
@@ -208,7 +251,6 @@
 
 int eth_initialize(bd_t *bis)
 {
-	unsigned char env_enetaddr[6];
 	int eth_number = 0;
 
 	eth_devices = NULL;
@@ -264,27 +306,8 @@
 			if (strchr(dev->name, ' '))
 				puts("\nWarning: eth device name has a space!\n");
 
-			eth_getenv_enetaddr_by_index(eth_number, env_enetaddr);
-
-			if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6)) {
-				if (memcmp(dev->enetaddr, "\0\0\0\0\0\0", 6) &&
-				    memcmp(dev->enetaddr, env_enetaddr, 6))
-				{
-					printf ("\nWarning: %s MAC addresses don't match:\n",
-						dev->name);
-					printf ("Address in SROM is         %pM\n",
-						dev->enetaddr);
-					printf ("Address in environment is  %pM\n",
-						env_enetaddr);
-				}
-
-				memcpy(dev->enetaddr, env_enetaddr, 6);
-			}
-			if (dev->write_hwaddr &&
-				!eth_mac_skip(eth_number) &&
-				is_valid_ether_addr(dev->enetaddr)) {
-				dev->write_hwaddr(dev);
-			}
+			if (eth_write_hwaddr(dev, "eth", eth_number))
+				puts("Warning: failed to set MAC address\n");
 
 			eth_number++;
 			dev = dev->next;
@@ -359,7 +382,8 @@
 	do {
 		uchar env_enetaddr[6];
 
-		if (eth_getenv_enetaddr_by_index(eth_number, env_enetaddr))
+		if (eth_getenv_enetaddr_by_index("eth", eth_number,
+						 env_enetaddr))
 			memcpy(dev->enetaddr, env_enetaddr, 6);
 
 		++eth_number;
@@ -521,7 +545,6 @@
 
 #warning Ethernet driver is deprecated.  Please update to use CONFIG_NET_MULTI
 
-extern int at91rm9200_miiphy_initialize(bd_t *bis);
 extern int mcf52x2_miiphy_initialize(bd_t *bis);
 extern int ns7520_miiphy_initialize(bd_t *bis);
 
@@ -532,9 +555,6 @@
 	miiphy_init();
 #endif
 
-#if defined(CONFIG_AT91RM9200)
-	at91rm9200_miiphy_initialize(bis);
-#endif
 #if defined(CONFIG_MCF52x2)
 	mcf52x2_miiphy_initialize(bis);
 #endif
Index: u-boot-2011.06/post/post.c
===================================================================
--- u-boot-2011.06.orig/post/post.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/post/post.c	2011-09-20 17:03:31.190018148 +0200
@@ -26,6 +26,10 @@
 #include <watchdog.h>
 #include <post.h>
 
+#ifdef CONFIG_SYS_POST_HOTKEYS_GPIO
+#include <asm/gpio.h>
+#endif
+
 #ifdef CONFIG_LOGBUFFER
 #include <logbuff.h>
 #endif
@@ -68,6 +72,23 @@
  */
 int __post_hotkeys_pressed(void)
 {
+#ifdef CONFIG_SYS_POST_HOTKEYS_GPIO
+	int ret;
+	unsigned gpio = CONFIG_SYS_POST_HOTKEYS_GPIO;
+
+	ret = gpio_request(gpio, "hotkeys");
+	if (ret) {
+		printf("POST: gpio hotkey request failed\n");
+		return 0;
+	}
+
+	gpio_direction_input(gpio);
+	ret = gpio_get_value(gpio);
+	gpio_free(gpio);
+
+	return ret;
+#endif
+
 	return 0;	/* No hotkeys supported */
 }
 int post_hotkeys_pressed(void)
@@ -175,7 +196,7 @@
 			 POST_CRITICAL };
 	char *var[] = { "post_poweron", "post_normal", "post_slowtest",
 			"post_critical" };
-	int varnum = sizeof (var) / sizeof (var[0]);
+	int varnum = ARRAY_SIZE(var);
 	char list[128];			/* long enough for POST list */
 	char *name;
 	char *s;
@@ -272,18 +293,18 @@
 					gd->flags |= GD_FLG_POSTSTOP;
 			}
 		} else {
-		if ((*test->test) (flags) != 0) {
-			post_log ("FAILED\n");
-			show_boot_progress (-32);
-			show_post_progress(i, POST_AFTER, POST_FAILED);
-			if (test_flags & POST_CRITICAL)
-				gd->flags |= GD_FLG_POSTFAIL;
-			if (test_flags & POST_STOP)
-				gd->flags |= GD_FLG_POSTSTOP;
-		}
-		else
-			post_log ("PASSED\n");
-			show_post_progress(i, POST_AFTER, POST_PASSED);
+			if ((*test->test)(flags) != 0) {
+				post_log("FAILED\n");
+				show_boot_progress(-32);
+				show_post_progress(i, POST_AFTER, POST_FAILED);
+				if (test_flags & POST_CRITICAL)
+					gd->flags |= GD_FLG_POSTFAIL;
+				if (test_flags & POST_STOP)
+					gd->flags |= GD_FLG_POSTSTOP;
+			} else {
+				post_log("PASSED\n");
+				show_post_progress(i, POST_AFTER, POST_PASSED);
+			}
 		}
 
 		if ((test_flags & POST_REBOOT) && !(flags & POST_MANUAL)) {
Index: u-boot-2011.06/post/tests.c
===================================================================
--- u-boot-2011.06.orig/post/tests.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/post/tests.c	2011-09-20 17:03:31.190018148 +0200
@@ -46,6 +46,7 @@
 extern int dsp_post_test (int flags);
 extern int codec_post_test (int flags);
 extern int ecc_post_test (int flags);
+extern int flash_post_test(int flags);
 
 extern int dspic_init_post_test (int flags);
 extern int dspic_post_test (int flags);
@@ -301,8 +302,20 @@
 	NULL,
 	NULL,
 	CONFIG_SYS_POST_COPROC
-    }
+    },
+#endif
+#if CONFIG_POST & CONFIG_SYS_POST_FLASH
+    {
+	"Parallel NOR flash test",
+	"flash",
+	"This test verifies parallel flash operations.",
+	POST_RAM | POST_SLOWTEST | POST_MANUAL,
+	&flash_post_test,
+	NULL,
+	NULL,
+	CONFIG_SYS_POST_FLASH
+    },
 #endif
 };
 
-unsigned int post_list_size = sizeof (post_list) / sizeof (struct post_test);
+unsigned int post_list_size = ARRAY_SIZE(post_list);
Index: u-boot-2011.06/README
===================================================================
--- u-boot-2011.06.orig/README	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/README	2011-09-20 17:03:31.190018148 +0200
@@ -147,7 +147,7 @@
     /cpu		CPU specific files
       /arm720t		Files specific to ARM 720 CPUs
       /arm920t		Files specific to ARM 920 CPUs
-	/at91rm9200	Files specific to Atmel AT91RM9200 CPU
+	/at91		Files specific to Atmel AT91RM9200 CPU
 	/imx		Files specific to Freescale MC9328 i.MX CPUs
 	/s3c24x0	Files specific to Samsung S3C24X0 CPUs
       /arm925t		Files specific to ARM 925 CPUs
@@ -180,6 +180,7 @@
     /lib		Architecture specific library files
   /mips			Files generic to MIPS architecture
     /cpu		CPU specific files
+      /mips32		Files specific to MIPS32 CPUs
     /lib		Architecture specific library files
   /nios2		Files generic to Altera NIOS2 architecture
     /cpu		CPU specific files
@@ -382,6 +383,38 @@
 		2. The core frequency as calculated above is multiplied
 		by this value.
 
+- MIPS CPU options:
+		CONFIG_SYS_INIT_SP_OFFSET
+
+		Offset relative to CONFIG_SYS_SDRAM_BASE for initial stack
+		pointer. This is needed for the temporary stack before
+		relocation.
+
+		CONFIG_SYS_MIPS_CACHE_MODE
+
+		Cache operation mode for the MIPS CPU.
+		See also arch/mips/include/asm/mipsregs.h.
+		Possible values are:
+			CONF_CM_CACHABLE_NO_WA
+			CONF_CM_CACHABLE_WA
+			CONF_CM_UNCACHED
+			CONF_CM_CACHABLE_NONCOHERENT
+			CONF_CM_CACHABLE_CE
+			CONF_CM_CACHABLE_COW
+			CONF_CM_CACHABLE_CUW
+			CONF_CM_CACHABLE_ACCELERATED
+
+		CONFIG_SYS_XWAY_EBU_BOOTCFG
+
+		Special option for Lantiq XWAY SoCs for booting from NOR flash.
+		See also arch/mips/cpu/mips32/start.S.
+
+		CONFIG_XWAY_SWAP_BYTES
+
+		Enable compilation of tools/xway-swap-bytes needed for Lantiq
+		XWAY SoCs for booting from NOR flash. The U-Boot image needs to
+		be swapped if a flash programmer is used.
+
 - Linux Kernel Interface:
 		CONFIG_CLOCKS_IN_MHZ
 
@@ -442,6 +475,16 @@
 		crash. This is needed for buggy hardware (uc101) where
 		no pull down resistor is connected to the signal IDE5V_DD7.
 
+		CONFIG_MACH_TYPE	[relevant for ARM only][mandatory]
+
+		This setting is mandatory for all boards that have only one
+		machine type and must be used to specify the machine type
+		number as it appears in the ARM machine registry
+		(see http://www.arm.linux.org.uk/developer/machines/).
+		Only boards that have multiple machine types supported
+		in a single configuration file and the machine type is
+		runtime discoverable, do not have to use this setting.
+
 - vxWorks boot parameters:
 
 		bootvx constructs a valid bootline using the following
@@ -460,6 +503,17 @@
 		Note: If a "bootargs" environment is defined, it will overwride
 		the defaults discussed just above.
 
+- Cache Configuration:
+		CONFIG_SYS_ICACHE_OFF - Do not enable instruction cache in U-Boot
+		CONFIG_SYS_DCACHE_OFF - Do not enable data cache in U-Boot
+		CONFIG_SYS_L2CACHE_OFF- Do not enable L2 cache in U-Boot
+
+- Cache Configuration for ARM:
+		CONFIG_SYS_L2_PL310 - Enable support for ARM PL310 L2 cache
+				      controller
+		CONFIG_SYS_PL310_BASE - Physical base address of PL310
+					controller register space
+
 - Serial Ports:
 		CONFIG_PL010_SERIAL
 
@@ -1043,6 +1097,15 @@
 		enabled with CONFIG_CMD_MMC. The MMC driver also works with
 		the FAT fs. This is enabled with CONFIG_CMD_FAT.
 
+		CONFIG_SH_MMCIF
+		Support for Renesas on-chip MMCIF controller
+
+			CONFIG_SH_MMCIF_ADDR
+			Define the base address of MMCIF registers
+
+			CONFIG_SH_MMCIF_CLK
+			Define the clock frequency for MMCIF
+
 - Journaling Flash filesystem support:
 		CONFIG_JFFS2_NAND, CONFIG_JFFS2_NAND_OFF, CONFIG_JFFS2_NAND_SIZE,
 		CONFIG_JFFS2_NAND_DEV
@@ -1114,7 +1177,7 @@
 		or CONFIG_VIDEO_SED13806_16BPP
 
 		CONFIG_FSL_DIU_FB
-		Enable the Freescale DIU video driver.  Reference boards for
+		Enable the Freescale DIU video driver.	Reference boards for
 		SOCs that have a DIU should define this macro to enable DIU
 		support, and should also define these other macros:
 
@@ -1693,12 +1756,12 @@
 		=>
 
 		If you now switch to the new I2C Bus 3 with "i2c dev 3"
-		u-boot sends First the Commando to the mux@70 to enable
-		channel 6, and then the Commando to the mux@71 to enable
+		u-boot first sends the command to the mux@70 to enable
+		channel 6, and then the command to the mux@71 to enable
 		the channel 4.
 
 		After that, you can use the "normal" i2c commands as
-		usual, to communicate with your I2C devices behind
+		usual to communicate with your I2C devices behind
 		the 2 muxes.
 
 		This option is actually implemented for the bitbanging
@@ -2225,6 +2288,45 @@
 		Adds the MTD partitioning infrastructure from the Linux
 		kernel. Needed for UBI support.
 
+- SPL framework
+		CONFIG_SPL
+		Enable building of SPL globally.
+
+		CONFIG_SPL_TEXT_BASE
+		TEXT_BASE for linking the SPL binary.
+
+		CONFIG_SPL_LDSCRIPT
+		LDSCRIPT for linking the SPL binary.
+
+		CONFIG_SPL_LIBCOMMON_SUPPORT
+		Support for common/libcommon.o in SPL binary
+
+		CONFIG_SPL_LIBDISK_SUPPORT
+		Support for disk/libdisk.o in SPL binary
+
+		CONFIG_SPL_I2C_SUPPORT
+		Support for drivers/i2c/libi2c.o in SPL binary
+
+		CONFIG_SPL_GPIO_SUPPORT
+		Support for drivers/gpio/libgpio.o in SPL binary
+
+		CONFIG_SPL_MMC_SUPPORT
+		Support for drivers/mmc/libmmc.o in SPL binary
+
+		CONFIG_SPL_SERIAL_SUPPORT
+		Support for drivers/serial/libserial.o in SPL binary
+
+		CONFIG_SPL_SPI_FLASH_SUPPORT
+		Support for drivers/mtd/spi/libspi_flash.o in SPL binary
+
+		CONFIG_SPL_SPI_SUPPORT
+		Support for drivers/spi/libspi.o in SPL binary
+
+		CONFIG_SPL_FAT_SUPPORT
+		Support for fs/fat/libfat.o in SPL binary
+
+		CONFIG_SPL_LIBGENERIC_SUPPORT
+		Support for lib/libgeneric.o in SPL binary
 
 Modem Support:
 --------------
@@ -2494,6 +2596,11 @@
 of environment data (variable area); in general, we support the
 following configurations:
 
+- CONFIG_BUILD_ENVCRC:
+
+	Builds up envcrc with the target environment so that external utils
+	may easily extract it and embed it in final U-Boot images.
+
 - CONFIG_ENV_IS_IN_FLASH:
 
 	Define this if the environment is in flash memory.
@@ -2917,6 +3024,14 @@
 - CONFIG_SYS_SRIOn_MEM_SIZE:
 		Size of SRIO port 'n' memory region
 
+- CONFIG_SYS_NDFC_16
+		Defined to tell the NDFC that the NAND chip is using a
+		16 bit bus.
+
+- CONFIG_SYS_NDFC_EBC0_CFG
+		Sets the EBC0_CFG register for the NDFC. If not defined
+		a default value will be used.
+
 - CONFIG_SPD_EEPROM
 		Get DDR timing information from an I2C EEPROM. Common
 		with pluggable memory modules such as SODIMMs
@@ -2929,6 +3044,12 @@
 		one, specify here. Note that the value must resolve
 		to something your driver can deal with.
 
+- CONFIG_SYS_DDR_RAW_TIMING
+		Get DDR timing information from other than SPD. Common with
+		soldered DDR chips onboard without SPD. DDR raw timing
+		parameters are extracted from datasheet and hard-coded into
+		header files or board specific files.
+
 - CONFIG_SYS_83XX_DDR_USES_CS0
 		Only for 83xx systems. If specified, then DDR should
 		be configured using CS0 and CS1 instead of CS2 and CS3.
@@ -2982,7 +3103,7 @@
 		globally (CONFIG_CMD_MEM).
 
 - CONFIG_SKIP_LOWLEVEL_INIT
-		[ARM only] If this variable is defined, then certain
+		[ARM, MIPS only] If this variable is defined, then certain
 		low level initializations (like setting up the memory
 		controller) are omitted and/or U-Boot does not
 		relocate itself into RAM.
@@ -2992,7 +3113,7 @@
 		other boot loader or by a debugger which performs
 		these initializations itself.
 
-- CONFIG_PRELOADER
+- CONFIG_SPL_BUILD
 		Modifies the behaviour of start.S when compiling a loader
 		that is executed before the actual U-Boot. E.g. when
 		compiling a NAND SPL.
@@ -3280,6 +3401,15 @@
 		  This can be used to load and uncompress arbitrary
 		  data.
 
+  fdt_high	- if set this restricts the maximum address that the
+		  flattened device tree will be copied into upon boot.
+		  If this is set to the special value 0xFFFFFFFF then
+		  the fdt will not be copied at all on boot.  For this
+		  to work it must reside in writable memory, have
+		  sufficient padding on the end of it for u-boot to
+		  add the information it needs into it, and the memory
+		  must be accessible by the kernel.
+
   i2cfast	- (PPC405GP|PPC405EP only)
 		  if set to 'y' configures Linux I2C driver for fast
 		  mode (400kHZ). This environment variable is used in
@@ -4382,9 +4512,7 @@
 
 All contributions to U-Boot should conform to the Linux kernel
 coding style; see the file "Documentation/CodingStyle" and the script
-"scripts/Lindent" in your Linux kernel source directory.  In sources
-originating from U-Boot a style corresponding to "Lindent -pcs" (adding
-spaces before parameters to function calls) is actually used.
+"scripts/Lindent" in your Linux kernel source directory.
 
 Source files originating from a different project (for example the
 MTD subsystem) are generally exempt from these guidelines and are not
@@ -4397,9 +4525,9 @@
 
 Please also stick to the following formatting rules:
 - remove any trailing white space
-- use TAB characters for indentation, not spaces
+- use TAB characters for indentation and vertical alignment, not spaces
 - make sure NOT to use DOS '\r\n' line feeds
-- do not add more than 2 empty lines to source files
+- do not add more than 2 consecutive empty lines to source files
 - do not add trailing empty lines to source files
 
 Submissions which do not conform to the standards may be returned
@@ -4433,14 +4561,14 @@
 * For major contributions, your entry to the CREDITS file
 
 * When you add support for a new board, don't forget to add this
-  board to the MAKEALL script, too.
+  board to the MAINTAINERS file, too.
 
 * If your patch adds new configuration options, don't forget to
   document these in the README file.
 
 * The patch itself. If you are using git (which is *strongly*
   recommended) you can easily generate the patch using the
-  "git-format-patch". If you then use "git-send-email" to send it to
+  "git format-patch". If you then use "git send-email" to send it to
   the U-Boot mailing list, you will avoid most of the common problems
   with some other mail clients.
 
Index: u-boot-2011.06/rules.mk
===================================================================
--- u-boot-2011.06.orig/rules.mk	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/rules.mk	2011-09-20 17:03:31.190018148 +0200
@@ -29,11 +29,11 @@
 		@rm -f $@
 		@touch $@
 		@for f in $(SRCS); do \
-			g=`basename $$f | sed -e 's/\(.*\)\.\w/\1.o/'`; \
+			g=`basename $$f | sed -e 's/\(.*\)\.[[:alnum:]_]/\1.o/'`; \
 			$(CC) -M $(CPPFLAGS) -MQ $(obj)$$g $$f >> $@ ; \
 		done
 		@for f in $(HOSTSRCS); do \
-			g=`basename $$f | sed -e 's/\(.*\)\.\w/\1.o/'`; \
+			g=`basename $$f | sed -e 's/\(.*\)\.[[:alnum:]_]/\1.o/'`; \
 			$(HOSTCC) -M $(HOSTCPPFLAGS) -MQ $(obj)$$g $$f >> $@ ; \
 		done
 
Index: u-boot-2011.06/spl/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/spl/Makefile	2011-09-20 17:03:31.190018148 +0200
@@ -0,0 +1,134 @@
+#
+# (C) Copyright 2000-2011
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2011
+# Daniel Schwierzeck, daniel.schwierzeck@googlemail.com.
+#
+# (C) Copyright 2011
+# Texas Instruments Incorporated - http://www.ti.com/
+# Aneesh V <aneesh@ti.com>
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Based on top-level Makefile.
+#
+
+CONFIG_SPL_BUILD := y
+export CONFIG_SPL_BUILD
+
+include $(TOPDIR)/config.mk
+
+# We want the final binaries in this directory
+obj := $(OBJTREE)/spl/
+
+HAVE_VENDOR_COMMON_LIB := $(shell [ -f $(SRCTREE)/board/$(VENDOR)/common/Makefile ] \
+			&& echo y || echo n)
+
+START := $(CPUDIR)/start.o
+
+LIBS-y += arch/$(ARCH)/lib/lib$(ARCH).o
+LIBS-y += $(CPUDIR)/lib$(CPU).o
+ifdef SOC
+LIBS-y += $(CPUDIR)/$(SOC)/lib$(SOC).o
+endif
+LIBS-y += board/$(BOARDDIR)/lib$(BOARD).o
+LIBS-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/lib$(VENDOR).o
+
+LIBS-$(CONFIG_SPL_LIBCOMMON_SUPPORT) += common/libcommon.o
+LIBS-$(CONFIG_SPL_LIBDISK_SUPPORT) += disk/libdisk.o
+LIBS-$(CONFIG_SPL_I2C_SUPPORT) += drivers/i2c/libi2c.o
+LIBS-$(CONFIG_SPL_GPIO_SUPPORT) += drivers/gpio/libgpio.o
+LIBS-$(CONFIG_SPL_MMC_SUPPORT) += drivers/mmc/libmmc.o
+LIBS-$(CONFIG_SPL_SERIAL_SUPPORT) += drivers/serial/libserial.o
+LIBS-$(CONFIG_SPL_SPI_FLASH_SUPPORT) += drivers/mtd/spi/libspi_flash.o
+LIBS-$(CONFIG_SPL_SPI_SUPPORT) += drivers/spi/libspi.o
+LIBS-$(CONFIG_SPL_FAT_SUPPORT) += fs/fat/libfat.o
+LIBS-$(CONFIG_SPL_LIBGENERIC_SUPPORT) += lib/libgeneric.o
+
+ifeq ($(SOC),omap3)
+LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
+endif
+ifeq ($(SOC),omap4)
+LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
+endif
+
+START := $(addprefix $(SPLTREE)/,$(START))
+LIBS := $(addprefix $(SPLTREE)/,$(sort $(LIBS-y)))
+
+__START := $(subst $(obj),,$(START))
+__LIBS := $(subst $(obj),,$(LIBS))
+
+# Linker Script
+ifdef CONFIG_SPL_LDSCRIPT
+# need to strip off double quotes
+LDSCRIPT := $(addprefix $(SRCTREE)/,$(subst ",,$(CONFIG_SPL_LDSCRIPT)))
+endif
+
+ifeq ($(wildcard $(LDSCRIPT)),)
+	LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot-spl.lds
+endif
+ifeq ($(wildcard $(LDSCRIPT)),)
+	LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot-spl.lds
+endif
+ifeq ($(wildcard $(LDSCRIPT)),)
+$(error could not find linker script)
+endif
+
+# Special flags for CPP when processing the linker script.
+# Pass the version down so we can handle backwards compatibility
+# on the fly.
+LDPPFLAGS += \
+	-include $(TOPDIR)/include/u-boot/u-boot.lds.h \
+	-include $(OBJTREE)/include/config.h \
+	$(shell $(LD) --version | \
+	  sed -ne 's/GNU ld version \([0-9][0-9]*\)\.\([0-9][0-9]*\).*/-DLD_MAJOR=\1 -DLD_MINOR=\2/p')
+
+ifdef CONFIG_OMAP
+$(OBJTREE)/MLO:	$(obj)u-boot-spl.bin
+	$(OBJTREE)/tools/mkimage -T omapimage \
+		-a $(CONFIG_SPL_TEXT_BASE) -d $< $@
+endif
+
+ALL-y	+= $(obj)u-boot-spl.bin
+
+ifdef CONFIG_SAMSUNG
+ALL-y	+= $(obj)$(BOARD)-spl.bin
+endif
+
+all:	$(ALL-y)
+
+ifdef CONFIG_SAMSUNG
+$(obj)$(BOARD)-spl.bin: $(obj)u-boot-spl.bin
+	$(TOPDIR)/board/$(BOARDDIR)/tools/mk$(BOARD)spl.exe \
+		$(obj)u-boot-spl.bin $(obj)$(BOARD)-spl.bin
+endif
+
+$(obj)u-boot-spl.bin:	$(obj)u-boot-spl
+	$(OBJCOPY) $(OBJCFLAGS) -O binary $< $@
+
+GEN_UBOOT = \
+	UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) | \
+	sed  -n -e 's/.*\($(SYM_PREFIX)__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+	cd $(obj) && $(LD) $(LDFLAGS) $(LDFLAGS_$(@F)) $$UNDEF_SYM $(__START) \
+		--start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \
+		-Map u-boot-spl.map -o u-boot-spl
+
+$(obj)u-boot-spl:	depend $(START) $(LIBS) $(obj)u-boot-spl.lds
+	$(GEN_UBOOT)
+
+$(START):	depend
+	$(MAKE) -C $(SRCTREE)/$(CPUDIR) $@
+
+$(LIBS):	depend
+	$(MAKE) -C $(SRCTREE)$(dir $(subst $(SPLTREE),,$@))
+
+$(obj)u-boot-spl.lds: $(LDSCRIPT) depend
+	$(CPP) $(CPPFLAGS) $(LDPPFLAGS) -ansi -D__ASSEMBLY__ -P - < $< > $@
+
+depend:	$(obj).depend
+.PHONY: depend
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
Index: u-boot-2011.06/tools/envcrc.c
===================================================================
--- u-boot-2011.06.orig/tools/envcrc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/tools/envcrc.c	2011-09-20 17:03:31.190018148 +0200
@@ -60,6 +60,10 @@
 # endif
 #endif	/* CONFIG_ENV_IS_IN_FLASH */
 
+#if defined(ENV_IS_EMBEDDED) && !defined(CONFIG_BUILD_ENVCRC)
+# define CONFIG_BUILD_ENVCRC 1
+#endif
+
 #ifdef CONFIG_SYS_REDUNDAND_ENVIRONMENT
 # define ENV_HEADER_SIZE	(sizeof(uint32_t) + 1)
 #else
@@ -71,14 +75,14 @@
 
 extern uint32_t crc32 (uint32_t, const unsigned char *, unsigned int);
 
-#ifdef	ENV_IS_EMBEDDED
+#ifdef CONFIG_BUILD_ENVCRC
 extern unsigned int env_size;
 extern unsigned char environment;
-#endif	/* ENV_IS_EMBEDDED */
+#endif	/* CONFIG_BUILD_ENVCRC */
 
 int main (int argc, char **argv)
 {
-#ifdef	ENV_IS_EMBEDDED
+#ifdef CONFIG_BUILD_ENVCRC
 	unsigned char pad = 0x00;
 	uint32_t crc;
 	unsigned char *envptr = &environment,
Index: u-boot-2011.06/tools/inca-swap-bytes.c
===================================================================
--- u-boot-2011.06.orig/tools/inca-swap-bytes.c	2011-06-27 22:22:42.000000000 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,38 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#ifndef BUFSIZ
-# define BUFSIZ 4096
-#endif
-
-#undef BUFSIZ
-# define BUFSIZ 64
-int main (void)
-{
-	short ibuff[BUFSIZ], obuff[BUFSIZ];
-	int rc, i, len;
-
-	while ((rc = read (0, ibuff, sizeof (ibuff))) > 0) {
-		memset (obuff, 0, sizeof (obuff));
-		for (i = 0; i < (rc + 1) / 2; i++) {
-			obuff[i] = ibuff[i ^ 1];
-		}
-
-		len = (rc + 1) & ~1;
-
-		if (write (1, obuff, len) != len) {
-			perror ("read error");
-			return (EXIT_FAILURE);
-		}
-
-		memset (ibuff, 0, sizeof (ibuff));
-	}
-
-	if (rc < 0) {
-		perror ("read error");
-		return (EXIT_FAILURE);
-	}
-	return (EXIT_SUCCESS);
-}
Index: u-boot-2011.06/tools/Makefile
===================================================================
--- u-boot-2011.06.orig/tools/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/tools/Makefile	2011-09-20 17:04:59.230018182 +0200
@@ -43,7 +43,7 @@
 CONFIG_LCD_LOGO = y
 CONFIG_CMD_LOADS = y
 CONFIG_CMD_NET = y
-CONFIG_INCA_IP = y
+CONFIG_XWAY_SWAP_BYTES = y
 CONFIG_NETCONSOLE = y
 CONFIG_SHA1_CHECK_UB_IMG = y
 endif
@@ -65,7 +65,7 @@
 BIN_FILES-$(CONFIG_BUILD_ENVCRC) += envcrc$(SFX)
 BIN_FILES-$(CONFIG_CMD_NET) += gen_eth_addr$(SFX)
 BIN_FILES-$(CONFIG_CMD_LOADS) += img2srec$(SFX)
-BIN_FILES-$(CONFIG_INCA_IP) += inca-swap-bytes$(SFX)
+BIN_FILES-$(CONFIG_XWAY_SWAP_BYTES) += xway-swap-bytes$(SFX)
 BIN_FILES-y += mkimage$(SFX)
 BIN_FILES-$(CONFIG_NETCONSOLE) += ncb$(SFX)
 BIN_FILES-$(CONFIG_SHA1_CHECK_UB_IMG) += ubsha1$(SFX)
@@ -85,13 +85,15 @@
 NOPED_OBJ_FILES-y += fit_image.o
 OBJ_FILES-$(CONFIG_CMD_NET) += gen_eth_addr.o
 OBJ_FILES-$(CONFIG_CMD_LOADS) += img2srec.o
-OBJ_FILES-$(CONFIG_INCA_IP) += inca-swap-bytes.o
+OBJ_FILES-$(CONFIG_XWAY_SWAP_BYTES) += xway-swap-bytes.o
 NOPED_OBJ_FILES-y += kwbimage.o
 NOPED_OBJ_FILES-y += imximage.o
+NOPED_OBJ_FILES-y += omapimage.o
 NOPED_OBJ_FILES-y += mkimage.o
 OBJ_FILES-$(CONFIG_NETCONSOLE) += ncb.o
 NOPED_OBJ_FILES-y += os_support.o
 OBJ_FILES-$(CONFIG_SHA1_CHECK_UB_IMG) += ubsha1.o
+NOPED_OBJ_FILES-y += ublimage.o
 
 # Don't build by default
 #ifeq ($(ARCH),ppc)
@@ -129,6 +131,9 @@
 ifeq ($(VENDOR),syteco)
 LOGO_BMP= logos/syteco.bmp
 endif
+ifeq ($(VENDOR),intercontrol)
+LOGO_BMP= logos/intercontrol.bmp
+endif
 
 # now $(obj) is defined
 HOSTSRCS += $(addprefix $(SRCTREE)/,$(EXT_OBJ_FILES-y:.o=.c))
@@ -175,7 +180,7 @@
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
 
-$(obj)inca-swap-bytes$(SFX):	$(obj)inca-swap-bytes.o
+$(obj)xway-swap-bytes$(SFX):	$(obj)xway-swap-bytes.o
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
 
@@ -188,7 +193,9 @@
 			$(obj)md5.o \
 			$(obj)mkimage.o \
 			$(obj)os_support.o \
+			$(obj)omapimage.o \
 			$(obj)sha1.o \
+			$(obj)ublimage.o \
 			$(LIBFDT_OBJS)
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
Index: u-boot-2011.06/tools/mkimage.c
===================================================================
--- u-boot-2011.06.orig/tools/mkimage.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/tools/mkimage.c	2011-09-20 17:03:31.190018148 +0200
@@ -156,8 +156,12 @@
 	init_imx_image_type ();
 	/* Init FIT image generation/list support */
 	init_fit_image_type ();
+	/* Init TI OMAP Boot image generation/list support */
+	init_omap_image_type();
 	/* Init Default image generation/list support */
 	init_default_image_type ();
+	/* Init Davinci UBL support */
+	init_ubl_image_type();
 
 	params.cmdname = *argv;
 	params.addr = params.ep = 0;
Index: u-boot-2011.06/tools/mkimage.h
===================================================================
--- u-boot-2011.06.orig/tools/mkimage.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-2011.06/tools/mkimage.h	2011-09-20 17:03:31.190018148 +0200
@@ -143,5 +143,7 @@
 void init_imx_image_type (void);
 void init_default_image_type (void);
 void init_fit_image_type (void);
+void init_ubl_image_type(void);
+void init_omap_image_type(void);
 
 #endif /* _MKIIMAGE_H_ */
Index: u-boot-2011.06/tools/ublimage.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/tools/ublimage.c	2011-09-20 17:03:31.190018148 +0200
@@ -0,0 +1,275 @@
+/*
+ * (C) Copyright 2011
+ * Heiko Schocher, DENX Software Engineering, hs@denx.de.
+ *
+ * Based on:
+ * (C) Copyright 2009
+ * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
+ *
+ * (C) Copyright 2008
+ * Marvell Semiconductor <www.marvell.com>
+ * Written-by: Prafulla Wadaskar <prafulla@marvell.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Required to obtain the getline prototype from stdio.h */
+#define _GNU_SOURCE
+
+#include "mkimage.h"
+#include <image.h>
+#include "ublimage.h"
+
+/*
+ * Supported commands for configuration file
+ */
+static table_entry_t ublimage_cmds[] = {
+	{CMD_BOOT_MODE,	"MODE",		"UBL special modes", },
+	{CMD_ENTRY,	"ENTRY",	"Entry point addr for bootloader", },
+	{CMD_PAGE,	"PAGES",
+		"number of pages (size of bootloader)", },
+	{CMD_ST_BLOCK,	"START_BLOCK",
+		"block number where bootloader is present", },
+	{CMD_ST_PAGE,	"START_PAGE",
+		"page number where bootloader is present", },
+	{CMD_LD_ADDR,	"LD_ADDR",
+		"load addr", },
+	{-1,		"",		"", },
+};
+
+/*
+ * Supported Boot options for configuration file
+ * this is needed to set the correct flash offset
+ */
+static table_entry_t ublimage_bootops[] = {
+	{UBL_MAGIC_SAFE,	"safe",	"Safe boot mode",	},
+	{-1,			"",	"Invalid",		},
+};
+
+static struct ubl_header ublimage_header;
+
+static uint32_t get_cfg_value(char *token, char *name,  int linenr)
+{
+	char *endptr;
+	uint32_t value;
+
+	errno = 0;
+	value = strtoul(token, &endptr, 16);
+	if (errno || (token == endptr)) {
+		fprintf(stderr, "Error: %s[%d] - Invalid hex data(%s)\n",
+			name,  linenr, token);
+		exit(EXIT_FAILURE);
+	}
+	return value;
+}
+
+static void print_hdr(struct ubl_header *ubl_hdr)
+{
+	printf("Image Type : Davinci UBL Boot Image\n");
+	printf("UBL magic  : %08x\n", ubl_hdr->magic);
+	printf("Entry Point: %08x\n", ubl_hdr->entry);
+	printf("nr of pages: %08x\n", ubl_hdr->pages);
+	printf("start block: %08x\n", ubl_hdr->block);
+	printf("start page : %08x\n", ubl_hdr->page);
+}
+
+static void parse_cfg_cmd(struct ubl_header *ublhdr, int32_t cmd, char *token,
+				char *name, int lineno, int fld, int dcd_len)
+{
+	static int cmd_ver_first = ~0;
+
+	switch (cmd) {
+	case CMD_BOOT_MODE:
+		ublhdr->magic = get_table_entry_id(ublimage_bootops,
+					"ublimage special boot mode", token);
+		if (ublhdr->magic == -1) {
+			fprintf(stderr, "Error: %s[%d] -Invalid boot mode"
+				"(%s)\n", name, lineno, token);
+			exit(EXIT_FAILURE);
+		}
+		ublhdr->magic += UBL_MAGIC_BASE;
+		if (unlikely(cmd_ver_first != 1))
+			cmd_ver_first = 0;
+		break;
+	case CMD_ENTRY:
+		ublhdr->entry = get_cfg_value(token, name, lineno);
+		break;
+	case CMD_PAGE:
+		ublhdr->pages = get_cfg_value(token, name, lineno);
+		break;
+	case CMD_ST_BLOCK:
+		ublhdr->block = get_cfg_value(token, name, lineno);
+		break;
+	case CMD_ST_PAGE:
+		ublhdr->page = get_cfg_value(token, name, lineno);
+		break;
+	case CMD_LD_ADDR:
+		ublhdr->pll_m = get_cfg_value(token, name, lineno);
+		break;
+	}
+}
+
+static void parse_cfg_fld(struct ubl_header *ublhdr, int32_t *cmd,
+		char *token, char *name, int lineno, int fld, int *dcd_len)
+{
+
+	switch (fld) {
+	case CFG_COMMAND:
+		*cmd = get_table_entry_id(ublimage_cmds,
+			"ublimage commands", token);
+		if (*cmd < 0) {
+			fprintf(stderr, "Error: %s[%d] - Invalid command"
+			"(%s)\n", name, lineno, token);
+			exit(EXIT_FAILURE);
+		}
+		break;
+	case CFG_REG_VALUE:
+		parse_cfg_cmd(ublhdr, *cmd, token, name, lineno, fld, *dcd_len);
+		break;
+	default:
+		break;
+	}
+}
+static uint32_t parse_cfg_file(struct ubl_header *ublhdr, char *name)
+{
+	FILE *fd = NULL;
+	char *line = NULL;
+	char *token, *saveptr1, *saveptr2;
+	int lineno = 0;
+	int	i;
+	char *ptr = (char *)ublhdr;
+	int fld;
+	size_t len;
+	int dcd_len = 0;
+	int32_t cmd;
+	int ublhdrlen = sizeof(struct ubl_header);
+
+	fd = fopen(name, "r");
+	if (fd == 0) {
+		fprintf(stderr, "Error: %s - Can't open DCD file\n", name);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Fill header with 0xff */
+	for (i = 0; i < ublhdrlen; i++) {
+		*ptr = 0xff;
+		ptr++;
+	}
+
+	/*
+	 * Very simple parsing, line starting with # are comments
+	 * and are dropped
+	 */
+	while ((getline(&line, &len, fd)) > 0) {
+		lineno++;
+
+		token = strtok_r(line, "\r\n", &saveptr1);
+		if (token == NULL)
+			continue;
+
+		/* Check inside the single line */
+		for (fld = CFG_COMMAND, cmd = CMD_INVALID,
+				line = token; ; line = NULL, fld++) {
+			token = strtok_r(line, " \t", &saveptr2);
+			if (token == NULL)
+				break;
+
+			/* Drop all text starting with '#' as comments */
+			if (token[0] == '#')
+				break;
+
+			parse_cfg_fld(ublhdr, &cmd, token, name,
+					lineno, fld, &dcd_len);
+		}
+	}
+	fclose(fd);
+
+	return dcd_len;
+}
+
+static int ublimage_check_image_types(uint8_t type)
+{
+	if (type == IH_TYPE_UBLIMAGE)
+		return EXIT_SUCCESS;
+	else
+		return EXIT_FAILURE;
+}
+
+static int ublimage_verify_header(unsigned char *ptr, int image_size,
+			struct mkimage_params *params)
+{
+	return 0;
+}
+
+static void ublimage_print_header(const void *ptr)
+{
+	struct ubl_header *ubl_hdr = (struct ubl_header *) ptr;
+
+	print_hdr(ubl_hdr);
+}
+
+static void ublimage_set_header(void *ptr, struct stat *sbuf, int ifd,
+				struct mkimage_params *params)
+{
+	struct ubl_header *ublhdr = (struct ubl_header *)ptr;
+
+	/* Parse configuration file */
+	parse_cfg_file(ublhdr, params->imagename);
+}
+
+int ublimage_check_params(struct mkimage_params *params)
+{
+	if (!params)
+		return CFG_INVALID;
+	if (!strlen(params->imagename)) {
+		fprintf(stderr, "Error: %s - Configuration file not"
+			"specified, it is needed for ublimage generation\n",
+			params->cmdname);
+		return CFG_INVALID;
+	}
+	/*
+	 * Check parameters:
+	 * XIP is not allowed and verify that incompatible
+	 * parameters are not sent at the same time
+	 * For example, if list is required a data image must not be provided
+	 */
+	return	(params->dflag && (params->fflag || params->lflag)) ||
+		(params->fflag && (params->dflag || params->lflag)) ||
+		(params->lflag && (params->dflag || params->fflag)) ||
+		(params->xflag) || !(strlen(params->imagename));
+}
+
+/*
+ * ublimage parameters
+ */
+static struct image_type_params ublimage_params = {
+	.name		= "Davinci UBL boot support",
+	.header_size	= sizeof(struct ubl_header),
+	.hdr		= (void *)&ublimage_header,
+	.check_image_type = ublimage_check_image_types,
+	.verify_header	= ublimage_verify_header,
+	.print_header	= ublimage_print_header,
+	.set_header	= ublimage_set_header,
+	.check_params	= ublimage_check_params,
+};
+
+void init_ubl_image_type(void)
+{
+	mkimage_register(&ublimage_params);
+}
Index: u-boot-2011.06/tools/ublimage.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/tools/ublimage.h	2011-09-20 17:03:31.190018148 +0200
@@ -0,0 +1,103 @@
+/*
+ * (C) Copyright 2011
+ * Heiko Schocher, DENX Software Engineering, hs@denx.de.
+ *
+ * Vased on:
+ * (C) Copyright 2009
+ * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _UBLIMAGE_H_
+#define _UBLIMAGE_H_
+
+#include <config.h>
+
+#if !defined(CONFIG_SYS_UBL_BLOCK)
+#define CONFIG_SYS_UBL_BLOCK 512
+#endif
+
+enum ublimage_cmd {
+	CMD_INVALID,
+	CMD_BOOT_MODE,
+	CMD_ENTRY,
+	CMD_PAGE,
+	CMD_ST_BLOCK,
+	CMD_ST_PAGE,
+	CMD_LD_ADDR
+};
+
+enum ublimage_fld_types {
+	CFG_INVALID = -1,
+	CFG_COMMAND,
+	CFG_REG_VALUE
+};
+
+/*
+ * from sprufg5a.pdf Table 110
+ * Used by RBL when doing NAND boot
+ */
+#define UBL_MAGIC_BASE              (0xA1ACED00)
+/* Safe boot mode */
+#define UBL_MAGIC_SAFE              (0x00)
+/* DMA boot mode */
+#define UBL_MAGIC_DMA               (0x11)
+/* I Cache boot mode */
+#define UBL_MAGIC_IC                (0x22)
+/* Fast EMIF boot mode */
+#define UBL_MAGIC_FAST              (0x33)
+/* DMA + ICache boot mode */
+#define UBL_MAGIC_DMA_IC            (0x44)
+/* DMA + ICache + Fast EMIF boot mode */
+#define UBL_MAGIC_DMA_IC_FAST       (0x55)
+
+/* Define max UBL image size */
+#define UBL_IMAGE_SIZE              (0x00003800u)
+
+/* from sprufg5a.pdf Table 109 */
+struct ubl_header {
+	uint32_t	magic;	/* Magic Number, see UBL_* defines */
+	uint32_t	entry;	/* entry point address for bootloader */
+	uint32_t	pages;	/* number of pages (size of bootloader) */
+	uint32_t	block;	/*
+				 * blocknumber where user bootloader is
+				 * present
+				 */
+	uint32_t	page;	/*
+				 * page number where user bootloader is
+				 * present.
+				 */
+	uint32_t	pll_m;	/*
+				 * PLL setting -Multiplier (only valid if
+				 * Magic Number indicates PLL enable).
+				 */
+	uint32_t	pll_n;	/*
+				 * PLL setting -Divider (only valid if
+				 * Magic Number indicates PLL enable).
+				 */
+	uint32_t	emif;	/*
+				 * fast EMIF setting (only valid if
+				 * Magic Number indicates fast EMIF boot).
+				 */
+	/* to fit in one nand block */
+	unsigned char	res[CONFIG_SYS_UBL_BLOCK - 8 * 4];
+};
+
+#endif /* _UBLIMAGE_H_ */
Index: u-boot-2011.06/tools/xway-swap-bytes.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/tools/xway-swap-bytes.c	2011-09-20 17:03:31.190018148 +0200
@@ -0,0 +1,38 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#ifndef BUFSIZ
+# define BUFSIZ 4096
+#endif
+
+#undef BUFSIZ
+# define BUFSIZ 64
+int main (void)
+{
+	short ibuff[BUFSIZ], obuff[BUFSIZ];
+	int rc, i, len;
+
+	while ((rc = read (0, ibuff, sizeof (ibuff))) > 0) {
+		memset (obuff, 0, sizeof (obuff));
+		for (i = 0; i < (rc + 1) / 2; i++) {
+			obuff[i] = ibuff[i ^ 1];
+		}
+
+		len = (rc + 1) & ~1;
+
+		if (write (1, obuff, len) != len) {
+			perror ("read error");
+			return (EXIT_FAILURE);
+		}
+
+		memset (ibuff, 0, sizeof (ibuff));
+	}
+
+	if (rc < 0) {
+		perror ("read error");
+		return (EXIT_FAILURE);
+	}
+	return (EXIT_SUCCESS);
+}
Index: u-boot-2011.06/tools/omapimage.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/tools/omapimage.c	2011-09-20 17:06:19.970018212 +0200
@@ -0,0 +1,223 @@
+/*
+ * (C) Copyright 2010
+ * Linaro LTD, www.linaro.org
+ * Author: John Rigby <john.rigby@linaro.org>
+ * Based on TI's signGP.c
+ *
+ * (C) Copyright 2009
+ * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
+ *
+ * (C) Copyright 2008
+ * Marvell Semiconductor <www.marvell.com>
+ * Written-by: Prafulla Wadaskar <prafulla@marvell.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Required to obtain the getline prototype from stdio.h */
+#define _GNU_SOURCE
+
+#include "mkimage.h"
+#include <image.h>
+#include "omapimage.h"
+
+/* Header size is CH header rounded up to 512 bytes plus GP header */
+#define OMAP_CH_HDR_SIZE 512
+#define OMAP_GP_HDR_SIZE (sizeof(struct gp_header))
+#define OMAP_FILE_HDR_SIZE (OMAP_CH_HDR_SIZE+OMAP_GP_HDR_SIZE)
+
+static uint8_t omapimage_header[OMAP_FILE_HDR_SIZE];
+
+static int omapimage_check_image_types(uint8_t type)
+{
+	if (type == IH_TYPE_OMAPIMAGE)
+		return EXIT_SUCCESS;
+	else {
+		return EXIT_FAILURE;
+	}
+}
+
+/*
+ * Only the simplest image type is currently supported:
+ * TOC pointing to CHSETTINGS
+ * TOC terminator
+ * CHSETTINGS
+ *
+ * padding to OMAP_CH_HDR_SIZE bytes
+ *
+ * gp header
+ *   size
+ *   load_addr
+ */
+static int valid_gph_size(uint32_t size)
+{
+	return size;
+}
+
+static int valid_gph_load_addr(uint32_t load_addr)
+{
+	return load_addr;
+}
+
+static int omapimage_verify_header(unsigned char *ptr, int image_size,
+			struct mkimage_params *params)
+{
+	struct ch_toc *toc = (struct ch_toc *)ptr;
+	struct gp_header *gph = (struct gp_header *)(ptr+OMAP_CH_HDR_SIZE);
+	uint32_t offset, size;
+
+	while (toc->section_offset != 0xffffffff
+			&& toc->section_size != 0xffffffff) {
+		offset = toc->section_offset;
+		size = toc->section_size;
+		if (!offset || !size)
+			return -1;
+		if (offset >= OMAP_CH_HDR_SIZE ||
+		    offset+size >= OMAP_CH_HDR_SIZE)
+			return -1;
+		toc++;
+	}
+	if (!valid_gph_size(gph->size))
+		return -1;
+	if (!valid_gph_load_addr(gph->load_addr))
+		return -1;
+
+	return 0;
+}
+
+static void omapimage_print_section(struct ch_settings *chs)
+{
+	const char *section_name;
+
+	if (chs->section_key)
+		section_name = "CHSETTINGS";
+	else
+		section_name = "UNKNOWNKEY";
+
+	printf("%s (%x) "
+		"valid:%x "
+		"version:%x "
+		"reserved:%x "
+		"flags:%x\n",
+		section_name,
+		chs->section_key,
+		chs->valid,
+		chs->version,
+		chs->reserved,
+		chs->flags);
+}
+
+static void omapimage_print_header(const void *ptr)
+{
+	const struct ch_toc *toc = (struct ch_toc *)ptr;
+	const struct gp_header *gph =
+			(struct gp_header *)(ptr+OMAP_CH_HDR_SIZE);
+	uint32_t offset, size;
+
+	while (toc->section_offset != 0xffffffff
+			&& toc->section_size != 0xffffffff) {
+		offset = toc->section_offset;
+		size = toc->section_size;
+
+		if (offset >= OMAP_CH_HDR_SIZE ||
+		    offset+size >= OMAP_CH_HDR_SIZE)
+			exit(EXIT_FAILURE);
+
+		printf("Section %s offset %x length %x\n",
+			toc->section_name,
+			toc->section_offset,
+			toc->section_size);
+
+		omapimage_print_section((struct ch_settings *)(ptr+offset));
+		toc++;
+	}
+
+	if (!valid_gph_size(gph->size)) {
+		fprintf(stderr,
+			"Error: invalid image size %x\n",
+			gph->size);
+		exit(EXIT_FAILURE);
+	}
+
+	if (!valid_gph_load_addr(gph->load_addr)) {
+		fprintf(stderr,
+			"Error: invalid image load address %x\n",
+			gph->size);
+		exit(EXIT_FAILURE);
+	}
+
+	printf("GP Header: Size %x LoadAddr %x\n",
+		gph->size, gph->load_addr);
+}
+
+static int toc_offset(void *hdr, void *member)
+{
+	return member - hdr;
+}
+
+static void omapimage_set_header(void *ptr, struct stat *sbuf, int ifd,
+				struct mkimage_params *params)
+{
+	struct ch_toc *toc = (struct ch_toc *)ptr;
+	struct ch_settings *chs = (struct ch_settings *)
+					(ptr + 2 * sizeof(*toc));
+	struct gp_header *gph = (struct gp_header *)(ptr + OMAP_CH_HDR_SIZE);
+
+	toc->section_offset = toc_offset(ptr, chs);
+	toc->section_size = sizeof(struct ch_settings);
+	strcpy((char *)toc->section_name, "CHSETTINGS");
+
+	chs->section_key = KEY_CHSETTINGS;
+	chs->valid = 0;
+	chs->version = 1;
+	chs->reserved = 0;
+	chs->flags = 0;
+
+	toc++;
+	memset(toc, 0xff, sizeof(*toc));
+
+	gph->size = sbuf->st_size - OMAP_FILE_HDR_SIZE;
+	gph->load_addr = params->addr;
+}
+
+int omapimage_check_params(struct mkimage_params *params)
+{
+	return	(params->dflag && (params->fflag || params->lflag)) ||
+		(params->fflag && (params->dflag || params->lflag)) ||
+		(params->lflag && (params->dflag || params->fflag));
+}
+
+/*
+ * omapimage parameters
+ */
+static struct image_type_params omapimage_params = {
+	.name		= "TI OMAP CH/GP Boot Image support",
+	.header_size	= OMAP_FILE_HDR_SIZE,
+	.hdr		= (void *)&omapimage_header,
+	.check_image_type = omapimage_check_image_types,
+	.verify_header	= omapimage_verify_header,
+	.print_header	= omapimage_print_header,
+	.set_header	= omapimage_set_header,
+	.check_params	= omapimage_check_params,
+};
+
+void init_omap_image_type(void)
+{
+	mkimage_register(&omapimage_params);
+}
Index: u-boot-2011.06/tools/omapimage.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2011.06/tools/omapimage.h	2011-09-20 17:06:19.970018212 +0200
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2010
+ * Linaro LTD, www.linaro.org
+ * Author John Rigby <john.rigby@linaro.org>
+ * Based on TI's signGP.c
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _OMAPIMAGE_H_
+#define _OMAPIMAGE_H_
+
+struct ch_toc {
+	uint32_t section_offset;
+	uint32_t section_size;
+	uint8_t unused[12];
+	uint8_t section_name[12];
+};
+
+struct ch_settings {
+	uint32_t section_key;
+	uint8_t valid;
+	uint8_t version;
+	uint16_t reserved;
+	uint32_t flags;
+};
+
+struct gp_header {
+	uint32_t size;
+	uint32_t load_addr;
+};
+
+#define KEY_CHSETTINGS 0xC0C0C0C1
+#endif /* _OMAPIMAGE_H_ */
