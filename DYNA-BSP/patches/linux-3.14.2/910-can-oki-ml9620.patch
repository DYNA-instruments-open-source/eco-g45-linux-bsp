--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -133,6 +133,8 @@ source "drivers/net/can/c_can/Kconfig"
 
 source "drivers/net/can/cc770/Kconfig"
 
+source "drivers/net/can/oki9620/Kconfig"
+
 source "drivers/net/can/usb/Kconfig"
 
 source "drivers/net/can/softing/Kconfig"
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
 obj-$(CONFIG_CAN_MSCAN)		+= mscan/
 obj-$(CONFIG_CAN_C_CAN)		+= c_can/
 obj-$(CONFIG_CAN_CC770)		+= cc770/
+obj-$(CONFIG_CAN_OKI9620)	+= oki9620/
 obj-$(CONFIG_CAN_AT91)		+= at91_can.o
 obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
 obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
--- /dev/null
+++ b/drivers/net/can/oki9620/Kconfig
@@ -0,0 +1,14 @@
+menuconfig CAN_OKI9620
+	tristate "OKI ML9620 devices"
+	depends on HAS_IOMEM
+
+if CAN_OKI9620
+
+config CAN_OKI9620_PLATFORM
+	tristate "Generic Platform Bus based OKI ML9620 driver"
+	---help---
+	  This driver adds support for the OKI ML9620 chips connected to
+	  the "platform bus" (Linux abstraction for directly to the
+	  processor attached devices).
+
+endif
--- /dev/null
+++ b/drivers/net/can/oki9620/Makefile
@@ -0,0 +1,8 @@
+#
+#  Makefile for the OKI ML9620 CAN controller drivers.
+#
+
+obj-$(CONFIG_CAN_OKI9620) += oki9620.o
+obj-$(CONFIG_CAN_OKI9620_PLATFORM) += oki9620_platform.o
+
+ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
--- /dev/null
+++ b/drivers/net/can/oki9620/oki9620.c
@@ -0,0 +1,1350 @@
+/*
+ * CAN bus driver for OKI ML9620 controller
+ *
+ * Copyright (c) 2014 Hans-Joachim Ricklefs, Drägerkoppel 7,
+ * 23684 Scharbeutz, Germany
+ *
+ * Copyright (c) 2014 DYNA Instruments GmbH, Tempowerkring 7,
+ * 21076 Hamburg, Germany
+ * All rights reserved.
+ *
+ * Borrowed heavily from the C_CAN driver written by:
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * Borrowed heavily from the C_CAN driver originally written by:
+ * Copyright (C) 2007
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix <s.hauer@pengutronix.de>
+ * - Simon Kallweit, intefo AG <simon.kallweit@intefo.ch>
+ *
+ * TX and RX NAPI implementation has been borrowed from at91 CAN driver
+ * written by:
+ * Copyright
+ * (C) 2007 by Hans J. Koch <hjk@hansjkoch.de>
+ * (C) 2008, 2009 by Marc Kleine-Budde <kernel@pengutronix.de>
+ *
+ * Bosch C_CAN controller is compliant to CAN protocol version 2.0 part A and B.
+ * Bosch C_CAN user manual can be obtained from:
+ * http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/
+ * users_manual_c_can.pdf
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/list.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <linux/gpio.h>
+
+#include <linux/can.h>
+#include <linux/can/dev.h>
+#include <linux/can/error.h>
+#include <linux/can/led.h>
+
+#include "oki9620.h"
+
+#define DRV_NAME "oki9620"
+
+/* Number of interface registers */
+#define IF_ENUM_REG_LEN		11
+#define C_CAN_IFACE(reg, iface)	(C_CAN_IF1_##reg + (iface) * IF_ENUM_REG_LEN)
+
+/* control extension register D_CAN specific */
+#define CONTROL_EX_PDR		BIT(8)
+
+/* control register */
+#define CONTROL_TEST		BIT(7)
+#define CONTROL_CCE		BIT(6)
+#define CONTROL_DISABLE_AR	BIT(5)
+#define CONTROL_ENABLE_AR	(0 << 5)
+#define CONTROL_EIE		BIT(3)
+#define CONTROL_SIE		BIT(2)
+#define CONTROL_IE		BIT(1)
+#define CONTROL_INIT		BIT(0)
+
+/* test register */
+#define TEST_RX			BIT(7)
+#define TEST_TX1		BIT(6)
+#define TEST_TX2		BIT(5)
+#define TEST_LBACK		BIT(4)
+#define TEST_SILENT		BIT(3)
+#define TEST_BASIC		BIT(2)
+
+/* status register */
+#define STATUS_PDA		BIT(10)
+#define STATUS_BOFF		BIT(7)
+#define STATUS_EWARN		BIT(6)
+#define STATUS_EPASS		BIT(5)
+#define STATUS_RXOK		BIT(4)
+#define STATUS_TXOK		BIT(3)
+
+/* error counter register */
+#define ERR_CNT_TEC_MASK	0xff
+#define ERR_CNT_TEC_SHIFT	0
+#define ERR_CNT_REC_SHIFT	8
+#define ERR_CNT_REC_MASK	(0x7f << ERR_CNT_REC_SHIFT)
+#define ERR_CNT_RP_SHIFT	15
+#define ERR_CNT_RP_MASK		(0x1 << ERR_CNT_RP_SHIFT)
+
+/* bit-timing register */
+#define BTR_BRP_MASK		0x3f
+#define BTR_BRP_SHIFT		0
+#define BTR_SJW_SHIFT		6
+#define BTR_SJW_MASK		(0x3 << BTR_SJW_SHIFT)
+#define BTR_TSEG1_SHIFT		8
+#define BTR_TSEG1_MASK		(0xf << BTR_TSEG1_SHIFT)
+#define BTR_TSEG2_SHIFT		12
+#define BTR_TSEG2_MASK		(0x7 << BTR_TSEG2_SHIFT)
+
+/* brp extension register */
+#define BRP_EXT_BRPE_MASK	0x0f
+#define BRP_EXT_BRPE_SHIFT	0
+
+/* IFx command request */
+#define IF_COMR_BUSY		BIT(15)
+
+/* IFx command mask */
+#define IF_COMM_WR		BIT(7)
+#define IF_COMM_MASK		BIT(6)
+#define IF_COMM_ARB		BIT(5)
+#define IF_COMM_CONTROL		BIT(4)
+#define IF_COMM_CLR_INT_PND	BIT(3)
+#define IF_COMM_TXRQST		BIT(2)
+#define IF_COMM_DATAA		BIT(1)
+#define IF_COMM_DATAB		BIT(0)
+#define IF_COMM_ALL		(IF_COMM_MASK | IF_COMM_ARB | \
+IF_COMM_CONTROL | IF_COMM_TXRQST | \
+IF_COMM_DATAA | IF_COMM_DATAB)
+
+/* IFx arbitration */
+#define IF_ARB_MSGVAL		BIT(15)
+#define IF_ARB_MSGXTD		BIT(14)
+#define IF_ARB_TRANSMIT		BIT(13)
+
+/* IFx message control */
+#define IF_MCONT_NEWDAT		BIT(15)
+#define IF_MCONT_MSGLST		BIT(14)
+#define IF_MCONT_CLR_MSGLST	(0 << 14)
+#define IF_MCONT_INTPND		BIT(13)
+#define IF_MCONT_UMASK		BIT(12)
+#define IF_MCONT_TXIE		BIT(11)
+#define IF_MCONT_RXIE		BIT(10)
+#define IF_MCONT_RMTEN		BIT(9)
+#define IF_MCONT_TXRQST		BIT(8)
+#define IF_MCONT_EOB		BIT(7)
+#define IF_MCONT_DLC_MASK	0xf
+
+/*
+ * IFx register masks:
+ * allow easy operation on 16-bit registers when the
+ * argument is 32-bit instead
+ */
+#define IFX_WRITE_LOW_16BIT(x)	((x) & 0xFFFF)
+#define IFX_WRITE_HIGH_16BIT(x)	(((x) & 0xFFFF0000) >> 16)
+
+/* message object split */
+#define C_CAN_NO_OF_OBJECTS	32
+#define C_CAN_MSG_OBJ_RX_NUM	16
+#define C_CAN_MSG_OBJ_TX_NUM	16
+
+#define C_CAN_MSG_OBJ_RX_FIRST	1
+#define C_CAN_MSG_OBJ_RX_LAST	(C_CAN_MSG_OBJ_RX_FIRST + \
+C_CAN_MSG_OBJ_RX_NUM - 1)
+
+#define C_CAN_MSG_OBJ_TX_FIRST	(C_CAN_MSG_OBJ_RX_LAST + 1)
+#define C_CAN_MSG_OBJ_TX_LAST	(C_CAN_MSG_OBJ_TX_FIRST + \
+C_CAN_MSG_OBJ_TX_NUM - 1)
+
+#define C_CAN_MSG_OBJ_RX_SPLIT	9
+#define C_CAN_MSG_RX_LOW_LAST	(C_CAN_MSG_OBJ_RX_SPLIT - 1)
+
+#define C_CAN_NEXT_MSG_OBJ_MASK	(C_CAN_MSG_OBJ_TX_NUM - 1)
+#define RECEIVE_OBJECT_BITS	0x0000ffff
+
+/* status interrupt */
+#define STATUS_INTERRUPT	0x8000
+
+/* global interrupt masks */
+#define ENABLE_ALL_INTERRUPTS	1
+#define DISABLE_ALL_INTERRUPTS	0
+
+/* minimum timeout for checking BUSY status */
+#define MIN_TIMEOUT_VALUE	6
+
+/* Wait for ~1 sec for INIT bit */
+#define INIT_WAIT_MS		1000
+
+/* napi related */
+#define C_CAN_NAPI_WEIGHT	C_CAN_MSG_OBJ_RX_NUM
+
+/* c_can lec values */
+enum c_can_lec_type {
+  LEC_NO_ERROR = 0,
+  LEC_STUFF_ERROR,
+  LEC_FORM_ERROR,
+  LEC_ACK_ERROR,
+  LEC_BIT1_ERROR,
+  LEC_BIT0_ERROR,
+  LEC_CRC_ERROR,
+  LEC_UNUSED,
+};
+
+/*
+ * c_can error types:
+ * Bus errors (BUS_OFF, ERROR_WARNING, ERROR_PASSIVE) are supported
+ */
+enum c_can_bus_error_types {
+  C_CAN_NO_ERROR = 0,
+  C_CAN_BUS_OFF,
+  C_CAN_ERROR_WARNING,
+  C_CAN_ERROR_PASSIVE,
+};
+
+static const struct can_bittiming_const c_can_bittiming_const = {
+  .name = DRV_NAME,
+  .tseg1_min = 2,		/* Time segment 1 = prop_seg + phase_seg1 */
+  .tseg1_max = 16,
+  .tseg2_min = 1,		/* Time segment 2 = phase_seg2 */
+  .tseg2_max = 8,
+  .sjw_max = 4,
+  .brp_min = 1,
+  .brp_max = 1024,	/* 6-bit BRP field + 4-bit BRPE field*/
+  .brp_inc = 1,
+};
+
+static inline void c_can_pm_runtime_enable(const struct c_can_priv *priv)
+{
+  if (priv->device)
+    pm_runtime_enable(priv->device);
+}
+
+static inline void c_can_pm_runtime_disable(const struct c_can_priv *priv)
+{
+  if (priv->device)
+    pm_runtime_disable(priv->device);
+}
+
+static inline void c_can_pm_runtime_get_sync(const struct c_can_priv *priv)
+{
+  if (priv->device)
+    pm_runtime_get_sync(priv->device);
+}
+
+static inline void c_can_pm_runtime_put_sync(const struct c_can_priv *priv)
+{
+  if (priv->device)
+    pm_runtime_put_sync(priv->device);
+}
+
+static inline void c_can_reset_ram(const struct c_can_priv *priv, bool enable)
+{
+  if (priv->raminit)
+    priv->raminit(priv, enable);
+}
+
+static inline int get_tx_next_msg_obj(const struct c_can_priv *priv)
+{
+  return (priv->tx_next & C_CAN_NEXT_MSG_OBJ_MASK) +
+  C_CAN_MSG_OBJ_TX_FIRST;
+}
+
+static inline int get_tx_echo_msg_obj(const struct c_can_priv *priv)
+{
+  return (priv->tx_echo & C_CAN_NEXT_MSG_OBJ_MASK) +
+  C_CAN_MSG_OBJ_TX_FIRST;
+}
+
+static u32 c_can_read_reg32(struct c_can_priv *priv, enum reg index)
+{
+  u32 val = priv->read_reg(priv, index);
+  val |= ((u32) priv->read_reg(priv, index + 1)) << 16;
+  return val;
+}
+
+static void c_can_enable_all_interrupts(struct c_can_priv *priv,
+					int enable)
+{
+  unsigned int cntrl_save = priv->read_reg(priv,
+					   C_CAN_CTRL_REG);
+
+  if (enable)
+    cntrl_save |= (CONTROL_SIE | CONTROL_EIE | CONTROL_IE);
+  else
+    cntrl_save &= ~(CONTROL_EIE | CONTROL_IE | CONTROL_SIE);
+
+  priv->write_reg(priv, C_CAN_CTRL_REG, cntrl_save);
+}
+
+static inline int c_can_msg_obj_is_busy(struct c_can_priv *priv, int iface)
+{
+  int count = MIN_TIMEOUT_VALUE;
+
+  while (count && priv->read_reg(priv, C_CAN_IFACE(COMREQ_REG, iface)) & IF_COMR_BUSY) {
+    count--;
+    udelay(1);
+  }
+
+  if (!count)
+    return 1;
+
+  return 0;
+}
+
+// static inline int c_can_msg_obj_is_busy(struct c_can_priv *priv, int iface)
+// {
+//   int count = MIN_TIMEOUT_VALUE;
+//
+//   do {
+//     count--;
+//     udelay(10);
+//   } while (count && (priv->read_reg(priv, C_CAN_IFACE(COMREQ_REG, iface)) & IF_COMR_BUSY));
+//
+//   if (!count)
+//     return 1;
+//
+//   return 0;
+// }
+
+static inline void c_can_object_get(struct net_device *dev,
+				    int iface, int objno, int mask)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  /*
+   * As per specs, after writting the message object number in the
+   * IF command request register the transfer b/w interface
+   * register and message RAM must be complete in 6 CAN-CLK
+   * period.
+   */
+  priv->write_reg(priv, C_CAN_IFACE(COMMSK_REG, iface),
+		  IFX_WRITE_LOW_16BIT(mask));
+  priv->write_reg(priv, C_CAN_IFACE(COMREQ_REG, iface),
+		  IFX_WRITE_LOW_16BIT(objno));
+
+  if (c_can_msg_obj_is_busy(priv, iface))
+    netdev_err(dev, "timed out in object get\n");
+}
+
+static inline void c_can_object_put(struct net_device *dev,
+				    int iface, int objno, int mask)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  /*
+   * As per specs, after writting the message object number in the
+   * IF command request register the transfer b/w interface
+   * register and message RAM must be complete in 6 CAN-CLK
+   * period.
+   */
+//   netdev_dbg(dev, "put to msgobject %u\n", objno);
+  priv->write_reg(priv, C_CAN_IFACE(COMMSK_REG, iface),
+		  (IF_COMM_WR | IFX_WRITE_LOW_16BIT(mask)));
+  priv->write_reg(priv, C_CAN_IFACE(COMREQ_REG, iface),
+		  IFX_WRITE_LOW_16BIT(objno));
+
+  if (c_can_msg_obj_is_busy(priv, iface))
+    netdev_err(dev, "timed out in object put\n");
+}
+
+static void c_can_write_msg_object(struct net_device *dev,
+				   int iface, struct can_frame *frame, int objno)
+{
+  int i;
+  u16 flags = 0;
+  unsigned int id;
+  struct c_can_priv *priv = netdev_priv(dev);
+
+//   netdev_dbg(dev, "write msgobject %u\n", objno);
+//   netdev_dbg(dev, "id: 0x%x, dlc: %u\n", frame->can_id, frame->can_dlc);
+  if (!(frame->can_id & CAN_RTR_FLAG))
+    flags |= IF_ARB_TRANSMIT;
+
+  if (frame->can_id & CAN_EFF_FLAG) {
+    id = frame->can_id & CAN_EFF_MASK;
+    flags |= IF_ARB_MSGXTD;
+  } else
+    id = ((frame->can_id & CAN_SFF_MASK) << 18);
+
+  flags |= IF_ARB_MSGVAL;
+
+  priv->write_reg(priv, C_CAN_IFACE(ARB1_REG, iface),
+		  IFX_WRITE_LOW_16BIT(id));
+  priv->write_reg(priv, C_CAN_IFACE(ARB2_REG, iface), flags |
+  IFX_WRITE_HIGH_16BIT(id));
+
+  for (i = 0; i < frame->can_dlc; i += 2) {
+    priv->write_reg(priv, C_CAN_IFACE(DATA1_REG, iface) + i / 2,
+		    frame->data[i] | (frame->data[i + 1] << 8));
+  }
+
+  /* enable interrupt for this message object */
+  priv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),
+		  IF_MCONT_TXIE | IF_MCONT_TXRQST | IF_MCONT_EOB |
+		  frame->can_dlc);
+  c_can_object_put(dev, iface, objno, IF_COMM_ALL);
+}
+
+static inline void c_can_mark_rx_msg_obj(struct net_device *dev,
+					 int iface, int ctrl_mask,
+					 int obj)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  priv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),
+		  ctrl_mask & ~(IF_MCONT_MSGLST | IF_MCONT_INTPND));
+  c_can_object_put(dev, iface, obj, IF_COMM_CONTROL);
+
+}
+
+static inline void c_can_activate_all_lower_rx_msg_obj(struct net_device *dev,
+						       int iface,
+						       int ctrl_mask)
+{
+  int i;
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  for (i = C_CAN_MSG_OBJ_RX_FIRST; i <= C_CAN_MSG_RX_LOW_LAST; i++) {
+    priv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),
+		    ctrl_mask & ~(IF_MCONT_MSGLST |
+		    IF_MCONT_INTPND | IF_MCONT_NEWDAT));
+    c_can_object_put(dev, iface, i, IF_COMM_CONTROL);
+  }
+}
+
+static inline void c_can_activate_rx_msg_obj(struct net_device *dev,
+					     int iface, int ctrl_mask,
+					     int obj)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  priv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),
+		  ctrl_mask & ~(IF_MCONT_MSGLST |
+		  IF_MCONT_INTPND | IF_MCONT_NEWDAT));
+  c_can_object_put(dev, iface, obj, IF_COMM_CONTROL);
+}
+
+static void c_can_handle_lost_msg_obj(struct net_device *dev,
+				      int iface, int objno)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+  struct net_device_stats *stats = &dev->stats;
+  struct sk_buff *skb;
+  struct can_frame *frame;
+
+  netdev_err(dev, "msg lost in buffer %d\n", objno);
+
+  c_can_object_get(dev, iface, objno, IF_COMM_ALL & ~IF_COMM_TXRQST);
+
+  priv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),
+		  IF_MCONT_CLR_MSGLST);
+
+  c_can_object_put(dev, 0, objno, IF_COMM_CONTROL);
+
+  /* create an error msg */
+  skb = alloc_can_err_skb(dev, &frame);
+  if (unlikely(!skb))
+    return;
+
+  frame->can_id |= CAN_ERR_CRTL;
+  frame->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+  stats->rx_errors++;
+  stats->rx_over_errors++;
+
+  netif_receive_skb(skb);
+}
+
+static int c_can_read_msg_object(struct net_device *dev, int iface, int ctrl)
+{
+  u16 flags, data;
+  int i;
+  unsigned int val;
+  struct c_can_priv *priv = netdev_priv(dev);
+  struct net_device_stats *stats = &dev->stats;
+  struct sk_buff *skb;
+  struct can_frame *frame;
+
+  skb = alloc_can_skb(dev, &frame);
+  if (!skb) {
+    stats->rx_dropped++;
+    return -ENOMEM;
+  }
+
+  frame->can_dlc = get_can_dlc(ctrl & 0x0F);
+
+  flags =	priv->read_reg(priv, C_CAN_IFACE(ARB2_REG, iface));
+  val = priv->read_reg(priv, C_CAN_IFACE(ARB1_REG, iface)) |
+  (flags << 16);
+
+  if (flags & IF_ARB_MSGXTD)
+    frame->can_id = (val & CAN_EFF_MASK) | CAN_EFF_FLAG;
+  else
+    frame->can_id = (val >> 18) & CAN_SFF_MASK;
+
+  if (flags & IF_ARB_TRANSMIT)
+    frame->can_id |= CAN_RTR_FLAG;
+  else {
+    for (i = 0; i < frame->can_dlc; i += 2) {
+      data = priv->read_reg(priv,
+			    C_CAN_IFACE(DATA1_REG, iface) + i / 2);
+      frame->data[i] = data;
+      frame->data[i + 1] = data >> 8;
+    }
+  }
+
+  netif_receive_skb(skb);
+
+  stats->rx_packets++;
+  stats->rx_bytes += frame->can_dlc;
+
+  can_led_event(dev, CAN_LED_EVENT_RX);
+
+  return 0;
+}
+
+static void c_can_setup_receive_object(struct net_device *dev, int iface,
+				       int objno, unsigned int mask,
+				       unsigned int id, unsigned int mcont)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  priv->write_reg(priv, C_CAN_IFACE(MASK1_REG, iface),
+		  IFX_WRITE_LOW_16BIT(mask));
+
+  /* According to C_CAN documentation, the reserved bit
+   * in IFx_MASK2 register is fixed 1
+   */
+  priv->write_reg(priv, C_CAN_IFACE(MASK2_REG, iface),
+		  IFX_WRITE_HIGH_16BIT(mask) | BIT(13));
+
+  priv->write_reg(priv, C_CAN_IFACE(ARB1_REG, iface),
+		  IFX_WRITE_LOW_16BIT(id));
+  priv->write_reg(priv, C_CAN_IFACE(ARB2_REG, iface),
+		  (IF_ARB_MSGVAL | IFX_WRITE_HIGH_16BIT(id)));
+
+  priv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), mcont);
+  c_can_object_put(dev, iface, objno, IF_COMM_ALL & ~IF_COMM_TXRQST);
+
+  netdev_dbg(dev, "obj no:%d, msgval:0x%08x\n", objno,
+	     c_can_read_reg32(priv, C_CAN_MSGVAL1_REG));
+}
+
+static void c_can_inval_msg_object(struct net_device *dev, int iface, int objno)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  priv->write_reg(priv, C_CAN_IFACE(ARB1_REG, iface), 0);
+  priv->write_reg(priv, C_CAN_IFACE(ARB2_REG, iface), 0);
+  priv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), 0);
+
+  c_can_object_put(dev, iface, objno, IF_COMM_ARB | IF_COMM_CONTROL);
+
+  netdev_dbg(dev, "obj no:%d, msgval:0x%08x\n", objno,
+	     c_can_read_reg32(priv, C_CAN_MSGVAL1_REG));
+}
+
+static inline int c_can_is_next_tx_obj_busy(struct c_can_priv *priv, int objno)
+{
+  int val = c_can_read_reg32(priv, C_CAN_TXRQST1_REG);
+
+  /*
+   * as transmission request register's bit n-1 corresponds to
+   * message object n, we need to handle the same properly.
+   */
+  if (val & (1 << (objno - 1)))
+    return 1;
+
+  return 0;
+}
+
+static netdev_tx_t c_can_start_xmit(struct sk_buff *skb,
+				    struct net_device *dev)
+{
+  u32 msg_obj_no;
+  struct c_can_priv *priv = netdev_priv(dev);
+  struct can_frame *frame = (struct can_frame *)skb->data;
+
+//   netdev_dbg(dev, "start transmission\n");
+  if (can_dropped_invalid_skb(dev, skb))
+    return NETDEV_TX_OK;
+
+  msg_obj_no = get_tx_next_msg_obj(priv);
+
+  /* prepare message object for transmission */
+  c_can_write_msg_object(dev, 0, frame, msg_obj_no);
+  can_put_echo_skb(skb, dev, msg_obj_no - C_CAN_MSG_OBJ_TX_FIRST);
+
+  /*
+   * we have to stop the queue in case of a wrap around or
+   * if the next TX message object is still in use
+   */
+  priv->tx_next++;
+  if (c_can_is_next_tx_obj_busy(priv, get_tx_next_msg_obj(priv)) || (priv->tx_next & C_CAN_NEXT_MSG_OBJ_MASK) == 0){
+    netif_stop_queue(dev);
+//     netdev_dbg(dev, "queue stoped\n");
+  }
+
+  return NETDEV_TX_OK;
+}
+
+static int c_can_set_bittiming(struct net_device *dev)
+{
+  unsigned int reg_btr, reg_brpe, ctrl_save;
+  u8 brp, brpe, sjw, tseg1, tseg2;
+  u32 ten_bit_brp;
+  struct c_can_priv *priv = netdev_priv(dev);
+  const struct can_bittiming *bt = &priv->can.bittiming;
+
+  /* c_can provides a 6-bit brp and 4-bit brpe fields */
+  ten_bit_brp = bt->brp - 1;
+  brp = ten_bit_brp & BTR_BRP_MASK;
+  brpe = ten_bit_brp >> 6;
+
+  sjw = bt->sjw - 1;
+  tseg1 = bt->prop_seg + bt->phase_seg1 - 1;
+  tseg2 = bt->phase_seg2 - 1;
+  reg_btr = brp | (sjw << BTR_SJW_SHIFT) | (tseg1 << BTR_TSEG1_SHIFT) |
+  (tseg2 << BTR_TSEG2_SHIFT);
+  reg_brpe = brpe & BRP_EXT_BRPE_MASK;
+
+  netdev_info(dev,
+	      "setting BTR=%04x BRPE=%04x\n", reg_btr, reg_brpe);
+
+  ctrl_save = priv->read_reg(priv, C_CAN_CTRL_REG);
+  priv->write_reg(priv, C_CAN_CTRL_REG,
+		  ctrl_save | CONTROL_CCE | CONTROL_INIT);
+  priv->write_reg(priv, C_CAN_BTR_REG, reg_btr);
+  priv->write_reg(priv, C_CAN_BRPEXT_REG, reg_brpe);
+  priv->write_reg(priv, C_CAN_CTRL_REG, ctrl_save);
+
+  return 0;
+}
+
+/*
+ * Configure C_CAN message objects for Tx and Rx purposes:
+ * C_CAN provides a total of 32 message objects that can be configured
+ * either for Tx or Rx purposes. Here the first 16 message objects are used as
+ * a reception FIFO. The end of reception FIFO is signified by the EoB bit
+ * being SET. The remaining 16 message objects are kept aside for Tx purposes.
+ * See user guide document for further details on configuring message
+ * objects.
+ */
+static void c_can_configure_msg_objects(struct net_device *dev)
+{
+  int i;
+
+  /* first invalidate all message objects */
+  for (i = C_CAN_MSG_OBJ_RX_FIRST; i <= C_CAN_NO_OF_OBJECTS; i++)
+    c_can_inval_msg_object(dev, 0, i);
+
+  /* setup receive message objects */
+  for (i = C_CAN_MSG_OBJ_RX_FIRST; i < C_CAN_MSG_OBJ_RX_LAST; i++)
+    c_can_setup_receive_object(dev, 0, i, 0, 0,
+			       (IF_MCONT_RXIE | IF_MCONT_UMASK) & ~IF_MCONT_EOB);
+
+    c_can_setup_receive_object(dev, 0, C_CAN_MSG_OBJ_RX_LAST, 0, 0,
+			       IF_MCONT_EOB | IF_MCONT_RXIE | IF_MCONT_UMASK);
+}
+
+/*
+ * Configure C_CAN chip:
+ * - enable/disable auto-retransmission
+ * - set operating mode
+ * - configure message objects
+ */
+static void c_can_chip_config(struct net_device *dev)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+  u16 status;
+
+//   netdev_dbg(dev, "configure chip/n");
+
+  /* set to init mode */
+  status = priv->read_reg(priv, C_CAN_CTRL_REG);
+  priv->write_reg(priv, C_CAN_CTRL_REG, status | CONTROL_INIT);
+
+  /* configure message objects */
+  c_can_configure_msg_objects(dev);
+
+  /* set a `lec` value so that we can check for updates later */
+  priv->write_reg(priv, C_CAN_STS_REG, LEC_UNUSED);
+
+  /* set bittiming params */
+  c_can_set_bittiming(dev);
+
+  /* enable automatic retransmission */
+  priv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_ENABLE_AR);
+
+  if ((priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) && (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)) {
+    /* loopback + silent mode : useful for hot self-test */
+    priv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_EIE | CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
+    priv->write_reg(priv, C_CAN_TEST_REG, TEST_LBACK | TEST_SILENT);
+  } else if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {
+    /* loopback mode : useful for self-test function */
+    priv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_EIE | CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
+    priv->write_reg(priv, C_CAN_TEST_REG, TEST_LBACK);
+  } else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {
+    /* silent mode : bus-monitoring mode */
+    priv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_EIE | CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
+    priv->write_reg(priv, C_CAN_TEST_REG, TEST_SILENT);
+  } else{
+    /* normal mode*/
+    priv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_EIE | CONTROL_SIE | CONTROL_IE);
+  }
+}
+
+static void c_can_start(struct net_device *dev)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  /* basic c_can configuration */
+  c_can_chip_config(dev);
+
+  priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+  /* reset tx helper pointers */
+  priv->tx_next = priv->tx_echo = 0;
+
+  /* enable status change, error and module interrupts */
+  c_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);
+}
+
+static void c_can_stop(struct net_device *dev)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  /* disable all interrupts */
+  c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
+
+  /* set the state as STOPPED */
+  priv->can.state = CAN_STATE_STOPPED;
+}
+
+static int c_can_set_mode(struct net_device *dev, enum can_mode mode)
+{
+  switch (mode) {
+    case CAN_MODE_START:
+      c_can_start(dev);
+      netif_wake_queue(dev);
+      break;
+    default:
+      return -EOPNOTSUPP;
+  }
+
+  return 0;
+}
+
+static int __c_can_get_berr_counter(const struct net_device *dev,
+				    struct can_berr_counter *bec)
+{
+  unsigned int reg_err_counter;
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  reg_err_counter = priv->read_reg(priv, C_CAN_ERR_CNT_REG);
+  bec->rxerr = (reg_err_counter & ERR_CNT_REC_MASK) >>
+  ERR_CNT_REC_SHIFT;
+  bec->txerr = reg_err_counter & ERR_CNT_TEC_MASK;
+
+  return 0;
+}
+
+static int c_can_get_berr_counter(const struct net_device *dev,
+				  struct can_berr_counter *bec)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+  int err;
+
+  c_can_pm_runtime_get_sync(priv);
+  err = __c_can_get_berr_counter(dev, bec);
+  c_can_pm_runtime_put_sync(priv);
+
+  return err;
+}
+
+/*
+ * theory of operation:
+ *
+ * priv->tx_echo holds the number of the oldest can_frame put for
+ * transmission into the hardware, but not yet ACKed by the CAN tx
+ * complete IRQ.
+ *
+ * We iterate from priv->tx_echo to priv->tx_next and check if the
+ * packet has been transmitted, echo it back to the CAN framework.
+ * If we discover a not yet transmitted packet, stop looking for more.
+ */
+static void c_can_do_tx(struct net_device *dev)
+{
+  u32 val;
+  u32 msg_obj_no;
+  struct c_can_priv *priv = netdev_priv(dev);
+  struct net_device_stats *stats = &dev->stats;
+
+  for (/* nix */; (priv->tx_next - priv->tx_echo) > 0; priv->tx_echo++) {
+    msg_obj_no = get_tx_echo_msg_obj(priv);
+    val = c_can_read_reg32(priv, C_CAN_TXRQST1_REG);
+    if (!(val & (1 << (msg_obj_no - 1)))) {
+      can_get_echo_skb(dev,
+		       msg_obj_no - C_CAN_MSG_OBJ_TX_FIRST);
+      c_can_object_get(dev, 0, msg_obj_no, IF_COMM_ALL);
+      stats->tx_bytes += priv->read_reg(priv,
+					C_CAN_IFACE(MSGCTRL_REG, 0))
+      & IF_MCONT_DLC_MASK;
+      stats->tx_packets++;
+      can_led_event(dev, CAN_LED_EVENT_TX);
+      c_can_inval_msg_object(dev, 0, msg_obj_no);
+    } else {
+      break;
+    }
+  }
+
+  /* restart queue if wrap-up or if queue stalled on last pkt */
+  if (((priv->tx_next & C_CAN_NEXT_MSG_OBJ_MASK) != 0) ||
+    ((priv->tx_echo & C_CAN_NEXT_MSG_OBJ_MASK) == 0))
+    netif_wake_queue(dev);
+}
+
+/*
+ * theory of operation:
+ *
+ * c_can core saves a received CAN message into the first free message
+ * object it finds free (starting with the lowest). Bits NEWDAT and
+ * INTPND are set for this message object indicating that a new message
+ * has arrived. To work-around this issue, we keep two groups of message
+ * objects whose partitioning is defined by C_CAN_MSG_OBJ_RX_SPLIT.
+ *
+ * To ensure in-order frame reception we use the following
+ * approach while re-activating a message object to receive further
+ * frames:
+ * - if the current message object number is lower than
+ *   C_CAN_MSG_RX_LOW_LAST, do not clear the NEWDAT bit while clearing
+ *   the INTPND bit.
+ * - if the current message object number is equal to
+ *   C_CAN_MSG_RX_LOW_LAST then clear the NEWDAT bit of all lower
+ *   receive message objects.
+ * - if the current message object number is greater than
+ *   C_CAN_MSG_RX_LOW_LAST then clear the NEWDAT bit of
+ *   only this message object.
+ */
+static int c_can_do_rx_poll(struct net_device *dev, int quota)
+{
+  u32 num_rx_pkts = 0;
+  unsigned int msg_obj, msg_ctrl_save;
+  struct c_can_priv *priv = netdev_priv(dev);
+  u16 val;
+
+  /*
+   * It is faster to read only one 16bit register. This is only possible
+   * for a maximum number of 16 objects.
+   */
+  BUILD_BUG_ON_MSG(C_CAN_MSG_OBJ_RX_LAST > 16,
+		   "Implementation does not support more message objects than 16");
+
+  while (quota > 0 && (val = priv->read_reg(priv, C_CAN_INTPND1_REG))) {
+    while ((msg_obj = ffs(val)) && quota > 0) {
+      val &= ~BIT(msg_obj - 1);
+
+      c_can_object_get(dev, 0, msg_obj, IF_COMM_ALL &
+      ~IF_COMM_TXRQST);
+      msg_ctrl_save = priv->read_reg(priv,
+				     C_CAN_IFACE(MSGCTRL_REG, 0));
+
+      if (msg_ctrl_save & IF_MCONT_MSGLST) {
+	c_can_handle_lost_msg_obj(dev, 0, msg_obj);
+	num_rx_pkts++;
+	quota--;
+	continue;
+      }
+
+      if (msg_ctrl_save & IF_MCONT_EOB)
+	return num_rx_pkts;
+
+      if (!(msg_ctrl_save & IF_MCONT_NEWDAT))
+	continue;
+
+      /* read the data from the message object */
+      c_can_read_msg_object(dev, 0, msg_ctrl_save);
+
+      if (msg_obj < C_CAN_MSG_RX_LOW_LAST)
+	c_can_mark_rx_msg_obj(dev, 0,
+			      msg_ctrl_save, msg_obj);
+	else if (msg_obj > C_CAN_MSG_RX_LOW_LAST)
+	  /* activate this msg obj */
+	  c_can_activate_rx_msg_obj(dev, 0,
+				    msg_ctrl_save, msg_obj);
+	  else if (msg_obj == C_CAN_MSG_RX_LOW_LAST)
+	    /* activate all lower message objects */
+	    c_can_activate_all_lower_rx_msg_obj(dev,
+						0, msg_ctrl_save);
+
+	    num_rx_pkts++;
+	  quota--;
+    }
+  }
+
+  return num_rx_pkts;
+}
+
+static inline int c_can_has_and_handle_berr(struct c_can_priv *priv)
+{
+  return (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&
+  (priv->current_status & LEC_UNUSED);
+}
+
+static int c_can_handle_state_change(struct net_device *dev,
+				     enum c_can_bus_error_types error_type)
+{
+  unsigned int reg_err_counter;
+  unsigned int rx_err_passive;
+  struct c_can_priv *priv = netdev_priv(dev);
+  struct net_device_stats *stats = &dev->stats;
+  struct can_frame *cf;
+  struct sk_buff *skb;
+  struct can_berr_counter bec;
+
+  /* propagate the error condition to the CAN stack */
+  skb = alloc_can_err_skb(dev, &cf);
+  if (unlikely(!skb))
+    return 0;
+
+  __c_can_get_berr_counter(dev, &bec);
+  reg_err_counter = priv->read_reg(priv, C_CAN_ERR_CNT_REG);
+  rx_err_passive = (reg_err_counter & ERR_CNT_RP_MASK) >>
+  ERR_CNT_RP_SHIFT;
+
+  switch (error_type) {
+    case C_CAN_ERROR_WARNING:
+      /* error warning state */
+      priv->can.can_stats.error_warning++;
+      priv->can.state = CAN_STATE_ERROR_WARNING;
+      cf->can_id |= CAN_ERR_CRTL;
+      cf->data[1] = (bec.txerr > bec.rxerr) ?
+      CAN_ERR_CRTL_TX_WARNING :
+      CAN_ERR_CRTL_RX_WARNING;
+      cf->data[6] = bec.txerr;
+      cf->data[7] = bec.rxerr;
+
+      break;
+    case C_CAN_ERROR_PASSIVE:
+      /* error passive state */
+      priv->can.can_stats.error_passive++;
+      priv->can.state = CAN_STATE_ERROR_PASSIVE;
+      cf->can_id |= CAN_ERR_CRTL;
+      if (rx_err_passive)
+	cf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+      if (bec.txerr > 127)
+	cf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+
+      cf->data[6] = bec.txerr;
+      cf->data[7] = bec.rxerr;
+      break;
+    case C_CAN_BUS_OFF:
+      /* bus-off state */
+      priv->can.state = CAN_STATE_BUS_OFF;
+      cf->can_id |= CAN_ERR_BUSOFF;
+      /*
+       * disable all interrupts in bus-off mode to ensure that
+       * the CPU is not hogged down
+       */
+      c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
+      can_bus_off(dev);
+      break;
+    default:
+      break;
+  }
+
+  netif_receive_skb(skb);
+  stats->rx_packets++;
+  stats->rx_bytes += cf->can_dlc;
+
+  return 1;
+}
+
+static int c_can_handle_bus_err(struct net_device *dev,
+				enum c_can_lec_type lec_type)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+  struct net_device_stats *stats = &dev->stats;
+  struct can_frame *cf;
+  struct sk_buff *skb;
+
+  /*
+   * early exit if no lec update or no error.
+   * no lec update means that no CAN bus event has been detected
+   * since CPU wrote 0x7 value to status reg.
+   */
+  if (lec_type == LEC_UNUSED || lec_type == LEC_NO_ERROR)
+    return 0;
+
+  /* propagate the error condition to the CAN stack */
+  skb = alloc_can_err_skb(dev, &cf);
+  if (unlikely(!skb))
+    return 0;
+
+  /*
+   * check for 'last error code' which tells us the
+   * type of the last error to occur on the CAN bus
+   */
+
+  /* common for all type of bus errors */
+  priv->can.can_stats.bus_error++;
+  stats->rx_errors++;
+  cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+  cf->data[2] |= CAN_ERR_PROT_UNSPEC;
+
+  switch (lec_type) {
+    case LEC_STUFF_ERROR:
+      netdev_dbg(dev, "stuff error\n");
+      cf->data[2] |= CAN_ERR_PROT_STUFF;
+      break;
+    case LEC_FORM_ERROR:
+      netdev_dbg(dev, "form error\n");
+      cf->data[2] |= CAN_ERR_PROT_FORM;
+      break;
+    case LEC_ACK_ERROR:
+      netdev_dbg(dev, "ack error\n");
+      cf->data[3] |= (CAN_ERR_PROT_LOC_ACK |
+      CAN_ERR_PROT_LOC_ACK_DEL);
+      break;
+    case LEC_BIT1_ERROR:
+      netdev_dbg(dev, "bit1 error\n");
+      cf->data[2] |= CAN_ERR_PROT_BIT1;
+      break;
+    case LEC_BIT0_ERROR:
+      netdev_dbg(dev, "bit0 error\n");
+      cf->data[2] |= CAN_ERR_PROT_BIT0;
+      break;
+    case LEC_CRC_ERROR:
+      netdev_dbg(dev, "CRC error\n");
+      cf->data[3] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
+      CAN_ERR_PROT_LOC_CRC_DEL);
+      break;
+    default:
+      break;
+  }
+
+  /* set a `lec` value so that we can check for updates later */
+  priv->write_reg(priv, C_CAN_STS_REG, LEC_UNUSED);
+
+  netif_receive_skb(skb);
+  stats->rx_packets++;
+  stats->rx_bytes += cf->can_dlc;
+
+  return 1;
+}
+
+static int c_can_poll(struct napi_struct *napi, int quota)
+{
+  u16 irqstatus;
+  int lec_type = 0;
+  int work_done = 0;
+  struct net_device *dev = napi->dev;
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  irqstatus = priv->irqstatus;
+  if (!irqstatus)
+    goto end;
+
+  /* status events have the highest priority */
+  if (irqstatus == STATUS_INTERRUPT) {
+    priv->current_status = priv->read_reg(priv,
+					  C_CAN_STS_REG);
+
+    /* handle Tx/Rx events */
+    if (priv->current_status & STATUS_TXOK){
+//       netdev_dbg(dev, "Transmitted a Message successfully\n");
+      priv->write_reg(priv, C_CAN_STS_REG,
+		      priv->current_status & ~STATUS_TXOK);
+    }
+    if (priv->current_status & STATUS_RXOK){
+//       netdev_dbg(dev, "Received a Message successfully\n");
+      priv->write_reg(priv, C_CAN_STS_REG,
+		      priv->current_status & ~STATUS_RXOK);
+    }
+    /* handle state changes */
+    if ((priv->current_status & STATUS_EWARN) &&
+      (!(priv->last_status & STATUS_EWARN))) {
+      netdev_dbg(dev, "entered error warning state\n");
+      work_done += c_can_handle_state_change(dev, C_CAN_ERROR_WARNING);
+    }
+    if ((priv->current_status & STATUS_EPASS) &&
+      (!(priv->last_status & STATUS_EPASS))) {
+      netdev_dbg(dev, "entered error passive state\n");
+      work_done += c_can_handle_state_change(dev, C_CAN_ERROR_PASSIVE);
+    }
+    if ((priv->current_status & STATUS_BOFF) &&
+      (!(priv->last_status & STATUS_BOFF))) {
+      netdev_dbg(dev, "entered bus off state\n");
+      work_done += c_can_handle_state_change(dev, C_CAN_BUS_OFF);
+    }
+
+    /* handle bus recovery events */
+    if ((!(priv->current_status & STATUS_BOFF)) &&
+      (priv->last_status & STATUS_BOFF)) {
+      netdev_dbg(dev, "left bus off state\n");
+      priv->can.state = CAN_STATE_ERROR_ACTIVE;
+    }
+    if ((!(priv->current_status & STATUS_EPASS)) &&
+      (priv->last_status & STATUS_EPASS)) {
+      netdev_dbg(dev, "left error passive state\n");
+      priv->can.state = CAN_STATE_ERROR_ACTIVE;
+    }
+
+    priv->last_status = priv->current_status;
+
+    /* handle lec errors on the bus */
+    lec_type = c_can_has_and_handle_berr(priv);
+    if (lec_type)
+      work_done += c_can_handle_bus_err(dev, lec_type);
+  } else if ((irqstatus >= C_CAN_MSG_OBJ_RX_FIRST) && (irqstatus <= C_CAN_MSG_OBJ_RX_LAST)) {
+    /* handle events corresponding to receive message objects */
+    work_done += c_can_do_rx_poll(dev, (quota - work_done));
+  } else if ((irqstatus >= C_CAN_MSG_OBJ_TX_FIRST) && (irqstatus <= C_CAN_MSG_OBJ_TX_LAST)) {
+    /* handle events corresponding to transmit message objects */
+    c_can_do_tx(dev);
+  }
+
+end:
+  if (work_done < quota) {
+    napi_complete(napi);
+    /* enable all IRQs */
+    c_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);
+  }
+
+  return work_done;
+}
+
+static irqreturn_t c_can_isr(int irq, void *dev_id)
+{
+  struct net_device *dev = (struct net_device *)dev_id;
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  #ifdef CONFIG_ARCH_AT91
+  /* We get an interrupt at each edge */
+  if (at91_get_gpio_value(priv->irq_pin) != 0) {
+//     netdev_dbg(dev, "irq_pin is high\n");
+    return IRQ_HANDLED;
+  }
+  #endif
+
+  priv->irqstatus = priv->read_reg(priv, C_CAN_INT_REG);
+//   netdev_dbg(dev, "irqstatus: 0x%04x\n", priv->irqstatus);
+  if (!priv->irqstatus)
+    return IRQ_NONE;
+
+  /* disable all interrupts and schedule the NAPI */
+  c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
+  napi_schedule(&priv->napi);
+
+  return IRQ_HANDLED;
+}
+
+static int c_can_open(struct net_device *dev)
+{
+  int err;
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  c_can_pm_runtime_get_sync(priv);
+  c_can_reset_ram(priv, true);
+
+  /* open the can device */
+  err = open_candev(dev);
+  if (err) {
+    netdev_err(dev, "failed to open can device\n");
+    goto exit_open_fail;
+  }
+
+  /* register interrupt handler */
+  err = request_irq(dev->irq, &c_can_isr, IRQF_SHARED, dev->name,
+		    dev);
+  if (err < 0) {
+    netdev_err(dev, "failed to request interrupt\n");
+    goto exit_irq_fail;
+  }
+
+  napi_enable(&priv->napi);
+
+  can_led_event(dev, CAN_LED_EVENT_OPEN);
+
+  /* start the c_can controller */
+  c_can_start(dev);
+
+  netif_start_queue(dev);
+
+  return 0;
+
+  exit_irq_fail:
+  close_candev(dev);
+  exit_open_fail:
+  c_can_reset_ram(priv, false);
+  c_can_pm_runtime_put_sync(priv);
+  return err;
+}
+
+static int c_can_close(struct net_device *dev)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  netif_stop_queue(dev);
+  napi_disable(&priv->napi);
+  c_can_stop(dev);
+  free_irq(dev->irq, dev);
+  close_candev(dev);
+
+  c_can_reset_ram(priv, false);
+  c_can_pm_runtime_put_sync(priv);
+
+  can_led_event(dev, CAN_LED_EVENT_STOP);
+
+  return 0;
+}
+
+struct net_device *alloc_c_can_dev(void)
+{
+  struct net_device *dev;
+  struct c_can_priv *priv;
+
+  dev = alloc_candev(sizeof(struct c_can_priv), C_CAN_MSG_OBJ_TX_NUM);
+  if (!dev)
+    return NULL;
+
+  priv = netdev_priv(dev);
+  netif_napi_add(dev, &priv->napi, c_can_poll, C_CAN_NAPI_WEIGHT);
+
+  priv->dev = dev;
+  priv->can.bittiming_const = &c_can_bittiming_const;
+  priv->can.do_set_mode = c_can_set_mode;
+  priv->can.do_get_berr_counter = c_can_get_berr_counter;
+  priv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
+  CAN_CTRLMODE_LISTENONLY |
+  CAN_CTRLMODE_BERR_REPORTING;
+
+  return dev;
+}
+EXPORT_SYMBOL_GPL(alloc_c_can_dev);
+
+#ifdef CONFIG_PM
+int c_can_power_down(struct net_device *dev)
+{
+  u32 val;
+  unsigned long time_out;
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  if (!(dev->flags & IFF_UP))
+    return 0;
+
+  WARN_ON(priv->type != BOSCH_D_CAN);
+
+  /* set PDR value so the device goes to power down mode */
+  val = priv->read_reg(priv, C_CAN_CTRL_EX_REG);
+  val |= CONTROL_EX_PDR;
+  priv->write_reg(priv, C_CAN_CTRL_EX_REG, val);
+
+  /* Wait for the PDA bit to get set */
+  time_out = jiffies + msecs_to_jiffies(INIT_WAIT_MS);
+  while (!(priv->read_reg(priv, C_CAN_STS_REG) & STATUS_PDA) &&
+    time_after(time_out, jiffies))
+    cpu_relax();
+
+  if (time_after(jiffies, time_out))
+    return -ETIMEDOUT;
+
+  c_can_stop(dev);
+
+  c_can_reset_ram(priv, false);
+  c_can_pm_runtime_put_sync(priv);
+
+  return 0;
+}
+EXPORT_SYMBOL_GPL(c_can_power_down);
+
+int c_can_power_up(struct net_device *dev)
+{
+  u32 val;
+  unsigned long time_out;
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  if (!(dev->flags & IFF_UP))
+    return 0;
+
+  WARN_ON(priv->type != BOSCH_D_CAN);
+
+  c_can_pm_runtime_get_sync(priv);
+  c_can_reset_ram(priv, true);
+
+  /* Clear PDR and INIT bits */
+  val = priv->read_reg(priv, C_CAN_CTRL_EX_REG);
+  val &= ~CONTROL_EX_PDR;
+  priv->write_reg(priv, C_CAN_CTRL_EX_REG, val);
+  val = priv->read_reg(priv, C_CAN_CTRL_REG);
+  val &= ~CONTROL_INIT;
+  priv->write_reg(priv, C_CAN_CTRL_REG, val);
+
+  /* Wait for the PDA bit to get clear */
+  time_out = jiffies + msecs_to_jiffies(INIT_WAIT_MS);
+  while ((priv->read_reg(priv, C_CAN_STS_REG) & STATUS_PDA) &&
+    time_after(time_out, jiffies))
+    cpu_relax();
+
+  if (time_after(jiffies, time_out))
+    return -ETIMEDOUT;
+
+  c_can_start(dev);
+
+  return 0;
+}
+EXPORT_SYMBOL_GPL(c_can_power_up);
+#endif
+
+void free_c_can_dev(struct net_device *dev)
+{
+  free_candev(dev);
+}
+EXPORT_SYMBOL_GPL(free_c_can_dev);
+
+static const struct net_device_ops c_can_netdev_ops = {
+  .ndo_open = c_can_open,
+  .ndo_stop = c_can_close,
+  .ndo_start_xmit = c_can_start_xmit,
+};
+
+int register_c_can_dev(struct net_device *dev)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+  int err;
+
+  c_can_pm_runtime_enable(priv);
+
+  dev->flags |= IFF_ECHO;	/* we support local echo */
+  dev->netdev_ops = &c_can_netdev_ops;
+
+  err = register_candev(dev);
+  if (err)
+    c_can_pm_runtime_disable(priv);
+  else
+    devm_can_led_init(dev);
+
+  return err;
+}
+EXPORT_SYMBOL_GPL(register_c_can_dev);
+
+void unregister_c_can_dev(struct net_device *dev)
+{
+  struct c_can_priv *priv = netdev_priv(dev);
+
+  unregister_candev(dev);
+
+  c_can_pm_runtime_disable(priv);
+}
+EXPORT_SYMBOL_GPL(unregister_c_can_dev);
+
+MODULE_AUTHOR("Hans-Joachim Ricklefs <hri@ing-ricklefs.de>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN bus driver for OKI ML9620 controller");
--- /dev/null
+++ b/drivers/net/can/oki9620/oki9620.h
@@ -0,0 +1,197 @@
+/*
+ * CAN bus driver for Bosch C_CAN controller
+ *
+ * Copyright (c) 2014 Hans-Joachim Ricklefs, Drägerkoppel 7,
+ * 23684 Scharbeutz, Germany
+ *
+ * Copyright (c) 2014 DYNA Instruments GmbH, Tempowerkring 7,
+ * 21076 Hamburg, Germany
+ * All rights reserved.
+ *
+ * Borrowed heavily from the C_CAN driver written by:
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * Borrowed heavily from the C_CAN driver originally written by:
+ * Copyright (C) 2007
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix <s.hauer@pengutronix.de>
+ * - Simon Kallweit, intefo AG <simon.kallweit@intefo.ch>
+ *
+ * Bosch C_CAN controller is compliant to CAN protocol version 2.0 part A and B.
+ * Bosch C_CAN user manual can be obtained from:
+ * http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/
+ * users_manual_c_can.pdf
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef C_CAN_H
+#define C_CAN_H
+
+enum reg {
+	C_CAN_CTRL_REG = 0,
+	C_CAN_CTRL_EX_REG,
+	C_CAN_STS_REG,
+	C_CAN_ERR_CNT_REG,
+	C_CAN_BTR_REG,
+	C_CAN_INT_REG,
+	C_CAN_TEST_REG,
+	C_CAN_BRPEXT_REG,
+	C_CAN_IF1_COMREQ_REG,
+	C_CAN_IF1_COMMSK_REG,
+	C_CAN_IF1_MASK1_REG,
+	C_CAN_IF1_MASK2_REG,
+	C_CAN_IF1_ARB1_REG,
+	C_CAN_IF1_ARB2_REG,
+	C_CAN_IF1_MSGCTRL_REG,
+	C_CAN_IF1_DATA1_REG,
+	C_CAN_IF1_DATA2_REG,
+	C_CAN_IF1_DATA3_REG,
+	C_CAN_IF1_DATA4_REG,
+	C_CAN_IF2_COMREQ_REG,
+	C_CAN_IF2_COMMSK_REG,
+	C_CAN_IF2_MASK1_REG,
+	C_CAN_IF2_MASK2_REG,
+	C_CAN_IF2_ARB1_REG,
+	C_CAN_IF2_ARB2_REG,
+	C_CAN_IF2_MSGCTRL_REG,
+	C_CAN_IF2_DATA1_REG,
+	C_CAN_IF2_DATA2_REG,
+	C_CAN_IF2_DATA3_REG,
+	C_CAN_IF2_DATA4_REG,
+	C_CAN_TXRQST1_REG,
+	C_CAN_TXRQST2_REG,
+	C_CAN_NEWDAT1_REG,
+	C_CAN_NEWDAT2_REG,
+	C_CAN_INTPND1_REG,
+	C_CAN_INTPND2_REG,
+	C_CAN_MSGVAL1_REG,
+	C_CAN_MSGVAL2_REG,
+};
+
+static const u16 reg_map_c_can[] = {
+	[C_CAN_CTRL_REG]	= 0x00,
+	[C_CAN_STS_REG]		= 0x02,
+	[C_CAN_ERR_CNT_REG]	= 0x04,
+	[C_CAN_BTR_REG]		= 0x06,
+	[C_CAN_INT_REG]		= 0x08,
+	[C_CAN_TEST_REG]	= 0x0A,
+	[C_CAN_BRPEXT_REG]	= 0x0C,
+	[C_CAN_IF1_COMREQ_REG]	= 0x10,
+	[C_CAN_IF1_COMMSK_REG]	= 0x12,
+	[C_CAN_IF1_MASK1_REG]	= 0x14,
+	[C_CAN_IF1_MASK2_REG]	= 0x16,
+	[C_CAN_IF1_ARB1_REG]	= 0x18,
+	[C_CAN_IF1_ARB2_REG]	= 0x1A,
+	[C_CAN_IF1_MSGCTRL_REG]	= 0x1C,
+	[C_CAN_IF1_DATA1_REG]	= 0x1E,
+	[C_CAN_IF1_DATA2_REG]	= 0x20,
+	[C_CAN_IF1_DATA3_REG]	= 0x22,
+	[C_CAN_IF1_DATA4_REG]	= 0x24,
+	[C_CAN_IF2_COMREQ_REG]	= 0x40,
+	[C_CAN_IF2_COMMSK_REG]	= 0x42,
+	[C_CAN_IF2_MASK1_REG]	= 0x44,
+	[C_CAN_IF2_MASK2_REG]	= 0x46,
+	[C_CAN_IF2_ARB1_REG]	= 0x48,
+	[C_CAN_IF2_ARB2_REG]	= 0x4A,
+	[C_CAN_IF2_MSGCTRL_REG]	= 0x4C,
+	[C_CAN_IF2_DATA1_REG]	= 0x4E,
+	[C_CAN_IF2_DATA2_REG]	= 0x50,
+	[C_CAN_IF2_DATA3_REG]	= 0x52,
+	[C_CAN_IF2_DATA4_REG]	= 0x54,
+	[C_CAN_TXRQST1_REG]	= 0x80,
+	[C_CAN_TXRQST2_REG]	= 0x82,
+	[C_CAN_NEWDAT1_REG]	= 0x90,
+	[C_CAN_NEWDAT2_REG]	= 0x92,
+	[C_CAN_INTPND1_REG]	= 0xA0,
+	[C_CAN_INTPND2_REG]	= 0xA2,
+	[C_CAN_MSGVAL1_REG]	= 0xB0,
+	[C_CAN_MSGVAL2_REG]	= 0xB2,
+};
+
+static const u16 reg_map_d_can[] = {
+	[C_CAN_CTRL_REG]	= 0x00,
+	[C_CAN_CTRL_EX_REG]	= 0x02,
+	[C_CAN_STS_REG]		= 0x04,
+	[C_CAN_ERR_CNT_REG]	= 0x08,
+	[C_CAN_BTR_REG]		= 0x0C,
+	[C_CAN_BRPEXT_REG]	= 0x0E,
+	[C_CAN_INT_REG]		= 0x10,
+	[C_CAN_TEST_REG]	= 0x14,
+	[C_CAN_TXRQST1_REG]	= 0x88,
+	[C_CAN_TXRQST2_REG]	= 0x8A,
+	[C_CAN_NEWDAT1_REG]	= 0x9C,
+	[C_CAN_NEWDAT2_REG]	= 0x9E,
+	[C_CAN_INTPND1_REG]	= 0xB0,
+	[C_CAN_INTPND2_REG]	= 0xB2,
+	[C_CAN_MSGVAL1_REG]	= 0xC4,
+	[C_CAN_MSGVAL2_REG]	= 0xC6,
+	[C_CAN_IF1_COMREQ_REG]	= 0x100,
+	[C_CAN_IF1_COMMSK_REG]	= 0x102,
+	[C_CAN_IF1_MASK1_REG]	= 0x104,
+	[C_CAN_IF1_MASK2_REG]	= 0x106,
+	[C_CAN_IF1_ARB1_REG]	= 0x108,
+	[C_CAN_IF1_ARB2_REG]	= 0x10A,
+	[C_CAN_IF1_MSGCTRL_REG]	= 0x10C,
+	[C_CAN_IF1_DATA1_REG]	= 0x110,
+	[C_CAN_IF1_DATA2_REG]	= 0x112,
+	[C_CAN_IF1_DATA3_REG]	= 0x114,
+	[C_CAN_IF1_DATA4_REG]	= 0x116,
+	[C_CAN_IF2_COMREQ_REG]	= 0x120,
+	[C_CAN_IF2_COMMSK_REG]	= 0x122,
+	[C_CAN_IF2_MASK1_REG]	= 0x124,
+	[C_CAN_IF2_MASK2_REG]	= 0x126,
+	[C_CAN_IF2_ARB1_REG]	= 0x128,
+	[C_CAN_IF2_ARB2_REG]	= 0x12A,
+	[C_CAN_IF2_MSGCTRL_REG]	= 0x12C,
+	[C_CAN_IF2_DATA1_REG]	= 0x130,
+	[C_CAN_IF2_DATA2_REG]	= 0x132,
+	[C_CAN_IF2_DATA3_REG]	= 0x134,
+	[C_CAN_IF2_DATA4_REG]	= 0x136,
+};
+
+enum c_can_dev_id {
+	BOSCH_C_CAN_PLATFORM,
+	BOSCH_C_CAN,
+	BOSCH_D_CAN,
+};
+
+/* c_can private data structure */
+struct c_can_priv {
+	struct can_priv can;	/* must be the first member */
+	struct napi_struct napi;
+	struct net_device *dev;
+	struct device *device;
+	int tx_object;
+	int current_status;
+	int last_status;
+	u16 (*read_reg) (struct c_can_priv *priv, enum reg index);
+	void (*write_reg) (struct c_can_priv *priv, enum reg index, u16 val);
+	void __iomem *base;
+	const u16 *regs;
+	unsigned long irq_flags; /* for request_irq() */
+	unsigned int tx_next;
+	unsigned int tx_echo;
+	void *priv;		/* for board-specific data */
+	u16 irqstatus;
+	enum c_can_dev_id type;
+	u32 __iomem *raminit_ctrlreg;
+	unsigned int instance;
+	void (*raminit) (const struct c_can_priv *priv, bool enable);
+	u32 irq_pin;
+	u32 rdy_pin;
+};
+
+struct net_device *alloc_c_can_dev(void);
+void free_c_can_dev(struct net_device *dev);
+int register_c_can_dev(struct net_device *dev);
+void unregister_c_can_dev(struct net_device *dev);
+
+#ifdef CONFIG_PM
+int c_can_power_up(struct net_device *dev);
+int c_can_power_down(struct net_device *dev);
+#endif
+
+#endif /* C_CAN_H */
--- /dev/null
+++ b/drivers/net/can/oki9620/oki9620_platform.c
@@ -0,0 +1,287 @@
+/*
+ * Platform CAN bus driver for Bosch C_CAN controller
+ *
+ * Copyright (c) 2014 Hans-Joachim Ricklefs, Drägerkoppel 7,
+ * 23684 Scharbeutz, Germany
+ *
+ * Copyright (c) 2014 DYNA Instruments GmbH, Tempowerkring 7,
+ * 21076 Hamburg, Germany
+ * All rights reserved.
+ *
+ * Borrowed heavily from the C_CAN driver written by:
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * Borrowed heavily from the C_CAN driver originally written by:
+ * Copyright (C) 2007
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix <s.hauer@pengutronix.de>
+ * - Simon Kallweit, intefo AG <simon.kallweit@intefo.ch>
+ *
+ * Bosch C_CAN controller is compliant to CAN protocol version 2.0 part A and B.
+ * Bosch C_CAN user manual can be obtained from:
+ * http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/
+ * users_manual_c_can.pdf
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/list.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/gpio.h>
+
+#include <linux/can/dev.h>
+#include <linux/can/platform/oki9620.h>
+
+#include "oki9620.h"
+
+#define DRV_NAME "oki9620_platform"
+
+#define CAN_RAMINIT_START_MASK(i)	(1 << (i))
+
+#define SLEEPLOOP			17
+/*
+ * 16-bit c_can registers can be arranged differently in the memory
+ * architecture of different implementations. For example: 16-bit
+ * registers can be aligned to a 16-bit boundary or 32-bit boundary etc.
+ * Handle the same by providing a common read/write interface.
+ */
+static u16 __maybe_unused c_can_plat_read_reg_aligned_to_8bit(struct c_can_priv *priv,
+						enum reg index)
+{
+  int i;
+  u16 val = (readb(priv->base + priv->regs[index] + 1) << 8);
+  for (i = 0; i < SLEEPLOOP; i++)
+    ;
+  val    |= readb(priv->base + priv->regs[index]);
+  for (i = 0; i < SLEEPLOOP; i++)
+    ;
+//   printk(KERN_DEBUG "read @ 0x%p, val: Ox%04x,\n", priv->base + priv->regs[index], val);
+  return val;
+}
+
+static void __maybe_unused c_can_plat_write_reg_aligned_to_8bit(struct c_can_priv *priv,
+						  enum reg index, u16 val)
+{
+  int i;
+//   printk(KERN_DEBUG "write @ 0x%p, Ox%04x\n", priv->base + priv->regs[index], val);
+  writeb((val >> 8) & 0xff, priv->base + priv->regs[index] + 1);
+  for (i = 0; i < SLEEPLOOP; i++)
+    ;
+  writeb(val & 0xff, priv->base + priv->regs[index]);
+  for (i = 0; i < SLEEPLOOP; i++)
+    ;
+}
+
+static u16 __maybe_unused c_can_plat_read_reg_aligned_to_16bit(struct c_can_priv *priv,
+						enum reg index)
+{
+  return readw(priv->base + priv->regs[index]);
+}
+
+static void __maybe_unused c_can_plat_write_reg_aligned_to_16bit(struct c_can_priv *priv,
+						  enum reg index, u16 val)
+{
+  writew(val, priv->base + priv->regs[index]);
+}
+
+static u16 __maybe_unused c_can_plat_read_reg_aligned_to_32bit(struct c_can_priv *priv,
+						enum reg index)
+{
+  return readw(priv->base + 2 * priv->regs[index]);
+}
+
+static void __maybe_unused c_can_plat_write_reg_aligned_to_32bit(struct c_can_priv *priv,
+						  enum reg index, u16 val)
+{
+  writew(val, priv->base + 2 * priv->regs[index]);
+}
+
+static void __maybe_unused c_can_hw_raminit(const struct c_can_priv *priv, bool enable)
+{
+  u32 val;
+
+  val = readl(priv->raminit_ctrlreg);
+  if (enable)
+    val |= CAN_RAMINIT_START_MASK(priv->instance);
+  else
+    val &= ~CAN_RAMINIT_START_MASK(priv->instance);
+  writel(val, priv->raminit_ctrlreg);
+}
+
+static int c_can_plat_probe(struct platform_device *pdev)
+{
+  int ret;
+  void __iomem *addr;
+  struct net_device *dev;
+  struct c_can_priv *priv;
+  struct resource *mem, *irq;
+  struct oki9620_platform_data *pdata;
+
+  pdata = dev_get_platdata(&pdev->dev);
+  if (!pdata) {
+    dev_err(&pdev->dev, "No platform data provided!\n");
+    ret = -ENODEV;
+    goto exit;
+  }
+
+  /* get the platform data */
+  mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+  if (!mem || irq <= 0) {
+    ret = -ENODEV;
+    goto exit;
+  }
+
+  if (!request_mem_region(mem->start, resource_size(mem), DRV_NAME)) {
+    dev_err(&pdev->dev, "resource unavailable\n");
+    ret = -ENODEV;
+    goto exit;
+  }
+
+  addr = ioremap(mem->start, resource_size(mem));
+  if (!addr) {
+    dev_err(&pdev->dev, "failed to map can port\n");
+    ret = -ENOMEM;
+    goto exit_release_mem;
+  }
+
+  /* allocate the c_can device */
+  dev = alloc_c_can_dev();
+  if (!dev) {
+    ret = -ENOMEM;
+    goto exit_iounmap;
+  }
+
+  priv = netdev_priv(dev);
+
+  dev->irq = gpio_to_irq(irq->start);
+  priv->base = addr;
+  priv->device = &pdev->dev;
+  priv->can.clock.freq = pdata->osc_freq;
+  priv->irq_pin = pdata->irq_pin;
+  priv->rdy_pin = pdata->rdy_pin;
+  priv->regs = reg_map_c_can;
+  priv->read_reg = c_can_plat_read_reg_aligned_to_8bit;
+  priv->write_reg = c_can_plat_write_reg_aligned_to_8bit;
+
+  platform_set_drvdata(pdev, dev);
+  SET_NETDEV_DEV(dev, &pdev->dev);
+
+  ret = register_c_can_dev(dev);
+  if (ret) {
+    dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
+	    DRV_NAME, ret);
+    goto exit_free_device;
+  }
+
+  dev_info(&pdev->dev, "%s device registered (regs=%p, irq=%d)\n",
+	   DRV_NAME, priv->base, dev->irq);
+  return 0;
+
+exit_free_device:
+  free_c_can_dev(dev);
+exit_iounmap:
+  iounmap(addr);
+exit_release_mem:
+  release_mem_region(mem->start, resource_size(mem));
+exit:
+  dev_err(&pdev->dev, "probe failed\n");
+
+  return ret;
+}
+
+static int c_can_plat_remove(struct platform_device *pdev)
+{
+  struct net_device *dev = platform_get_drvdata(pdev);
+  struct c_can_priv *priv = netdev_priv(dev);
+  struct resource *mem;
+
+  unregister_c_can_dev(dev);
+
+  free_c_can_dev(dev);
+  iounmap(priv->base);
+
+  mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  release_mem_region(mem->start, resource_size(mem));
+
+  return 0;
+}
+
+#ifdef CONFIG_PM
+static int c_can_suspend(struct platform_device *pdev, pm_message_t state)
+{
+  int ret;
+  struct net_device *ndev = platform_get_drvdata(pdev);
+  struct c_can_priv *priv = netdev_priv(ndev);
+
+  if (netif_running(ndev)) {
+    netif_stop_queue(ndev);
+    netif_device_detach(ndev);
+  }
+
+  ret = c_can_power_down(ndev);
+  if (ret) {
+    netdev_err(ndev, "failed to enter power down mode\n");
+    return ret;
+  }
+
+  priv->can.state = CAN_STATE_SLEEPING;
+
+  return 0;
+}
+
+static int c_can_resume(struct platform_device *pdev)
+{
+  int ret;
+  struct net_device *ndev = platform_get_drvdata(pdev);
+  struct c_can_priv *priv = netdev_priv(ndev);
+
+  ret = c_can_power_up(ndev);
+  if (ret) {
+    netdev_err(ndev, "Still in power down mode\n");
+    return ret;
+  }
+
+  priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+  if (netif_running(ndev)) {
+    netif_device_attach(ndev);
+    netif_start_queue(ndev);
+  }
+
+  return 0;
+}
+#else
+#define c_can_suspend NULL
+#define c_can_resume NULL
+#endif
+
+static struct platform_driver c_can_plat_driver = {
+  .driver = {
+    .name = DRV_NAME,
+    .owner = THIS_MODULE,
+  },
+  .probe = c_can_plat_probe,
+  .remove = c_can_plat_remove,
+  .suspend = c_can_suspend,
+  .resume = c_can_resume,
+};
+
+module_platform_driver(c_can_plat_driver);
+
+MODULE_AUTHOR("Hans-Joachim Ricklefs <hri@ing-ricklefs.de>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Platform CAN bus driver for OKI ML9620 controller");
--- /dev/null
+++ b/include/linux/can/platform/oki9620.h
@@ -0,0 +1,24 @@
+/*
+ * include/linux/can/platform/oki9620.h -  OKI ML9620 network device driver
+ *
+ * Copyright (c) 2014 Hans-Joachim Ricklefs, Drägerkoppel 7,
+ * 23684 Scharbeutz, Germany
+ *
+ * Copyright (c) 2014 DYNA Instruments GmbH, Tempowerkring 7,
+ * 21076 Hamburg, Germany
+ * All rights reserved.
+ *
+ */
+
+#ifndef _CAN_PLATFORM_OKI9620_H_
+#define _CAN_PLATFORM_OKI9620_H_
+
+#include <linux/types.h>
+
+struct oki9620_platform_data {
+  u32	osc_freq;		/* CAN bus oscillator frequency in Hz */
+  int	irq_pin;
+  int	rdy_pin;
+};
+
+#endif  // _CAN_PLATFORM_OKI9620_H_
--- /dev/null
+++ b/arch/arm/mach-at91/board-dynavel-hwrev21-can-oki9620.c
@@ -0,0 +1,222 @@
+/*
+ * board-dynavel-hwrev21-can-oki9620.c
+ *
+ *  Created on: 18.11.2014
+ *      Author: lode
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/irqnr.h>
+#include <linux/gpio.h>
+#include <linux/can/platform/oki9620.h>
+#include <mach/at91sam9_smc.h>
+
+#include "board.h"
+#include "sam9_smc.h"
+#include "generic.h"
+
+#ifdef ECLIPSE_EDITOR
+#define __init
+#define __exit
+#define IS_ENABLED(x) (1)
+#define KERN_ERR
+#endif
+
+/*
+ * CAN-Controller OKI ML9620
+ */
+static int can_chip_select = 5;
+
+static void release(struct device *dev)
+{
+  struct oki9620_platform_data *oki = dev->platform_data;
+  at91_set_GPIO_periph(oki->rdy_pin, 1);
+  gpio_free(oki->rdy_pin);
+  at91_set_GPIO_periph(oki->irq_pin, 1);
+  gpio_free(oki->irq_pin);
+}
+
+static struct resource eco45_oki9620_resources[] = {
+  [0] = {
+    .start   = AT91_CHIPSELECT_5,
+    .end     = AT91_CHIPSELECT_5 + 0xFF,
+    .flags   = IORESOURCE_MEM,
+  },
+  [1] = {
+    .start   = AT91_PIN_PD7,
+    .end     = AT91_PIN_PD7,
+    .flags   = IORESOURCE_IRQ,
+  },
+};
+
+static struct oki9620_platform_data eco_g45_oki9620_data = {
+  .osc_freq = 8000000,    /* CAN bus oscillator frequency in Hz */
+  .irq_pin = AT91_PIN_PD7,
+  .rdy_pin = AT91_PIN_PC15,
+};
+
+static struct platform_device eco_g45_can_device = {
+  .name           = "oki9620_platform",
+  .id             = 0,
+  .dev            = {
+    .platform_data  = &eco_g45_oki9620_data,
+    .release      = release,
+  },
+  .resource       = eco45_oki9620_resources,
+  .num_resources  = ARRAY_SIZE(eco45_oki9620_resources),
+};
+
+static struct sam9_smc_config __initdata eco_g45_oki9620_smc_config = {
+  .ncs_read_setup   = 0,
+  .nrd_setup        = 4,
+  .ncs_write_setup  = 0,
+  .nwe_setup        = 4,
+
+  .ncs_read_pulse   = 54,
+  .nrd_pulse        = 30,
+  .ncs_write_pulse  = 54,
+  .nwe_pulse        = 30,
+
+  .read_cycle       = 55,
+  .write_cycle      = 55,
+
+  .mode = AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_FROZEN | AT91_SMC_DBW_8 | AT91_SMC_TDFMODE,
+  .tdf_cycles       = 2,
+};
+
+static int __init board_rev21_can_init(void)
+{
+  int ret = 0;
+  struct oki9620_platform_data *data = &eco_g45_oki9620_data;
+
+  eco45_oki9620_resources[1].start = eco45_oki9620_resources[1].end = eco_g45_oki9620_data.irq_pin;
+
+  do { // a breakable block to avoid goto
+    switch(can_chip_select)
+    {
+//    case 0:
+//      eco45_oki9620_resources[0].start = AT91_CHIPSELECT_0;
+//      eco45_oki9620_resources[0].end   = AT91_CHIPSELECT_0 + 0xFF;
+//      break;
+//    case 1:
+//      eco45_oki9620_resources[0].start = AT91_CHIPSELECT_1;
+//      eco45_oki9620_resources[0].end   = AT91_CHIPSELECT_1 + 0xFF;
+//      break;
+    case 2:
+      eco45_oki9620_resources[0].start = AT91_CHIPSELECT_2;
+      eco45_oki9620_resources[0].end   = AT91_CHIPSELECT_2 + 0xFF;
+      break;
+//    case 3:
+//      eco45_oki9620_resources[0].start = AT91_CHIPSELECT_3;
+//      eco45_oki9620_resources[0].end   = AT91_CHIPSELECT_3 + 0xFF;
+//      break;
+    case 4:
+      eco45_oki9620_resources[0].start = AT91_CHIPSELECT_4;
+      eco45_oki9620_resources[0].end   = AT91_CHIPSELECT_4 + 0xFF;
+      break;
+    case 5:
+      eco45_oki9620_resources[0].start = AT91_CHIPSELECT_5;
+      eco45_oki9620_resources[0].end   = AT91_CHIPSELECT_5 + 0xFF;
+      break;
+//    case 6:
+//      eco45_oki9620_resources[0].start = AT91_CHIPSELECT_6;
+//      eco45_oki9620_resources[0].end   = AT91_CHIPSELECT_6 + 0xFF;
+//      break;
+//    case 7:
+//      eco45_oki9620_resources[0].start = AT91_CHIPSELECT_7;
+//      eco45_oki9620_resources[0].end   = AT91_CHIPSELECT_7 + 0xFF;
+//      break;
+    default:
+      ret = -ENXIO;
+      break;
+    }
+
+    if (ret)
+      break;
+
+    /* configure rdy pin */
+    if (gpio_is_valid(data->rdy_pin)) {
+      ret = gpio_request(data->rdy_pin, eco_g45_can_device.name);
+      if (ret)
+        break;
+      ret = at91_set_A_periph(data->rdy_pin, 0);
+      if (ret)
+        break;
+
+      do {
+        /* configure chip-select */
+        sam9_smc_configure(0, can_chip_select, &eco_g45_oki9620_smc_config);
+
+        /* configure irq pin */
+        if (gpio_is_valid(data->irq_pin)){
+          ret = gpio_request(data->irq_pin, eco_g45_can_device.name);
+          if (ret)
+            break;
+
+          do {
+            ret = at91_set_gpio_input(data->irq_pin, 1);
+            if (ret)
+              break;
+
+            ret = at91_set_deglitch(data->irq_pin, 1);
+            if (ret)
+              break;
+
+            /* register device */
+            ret = platform_device_register(&eco_g45_can_device);
+
+          } while (0);
+
+          if (ret)
+          {
+            at91_set_GPIO_periph(data->irq_pin, 1);
+            gpio_free(data->irq_pin);
+          }
+        }
+        else
+        {
+          ret = -ENXIO;
+        }
+      } while (0);
+
+      if (ret)
+      {
+        at91_set_GPIO_periph(data->rdy_pin, 1);
+        gpio_free(data->rdy_pin);
+      }
+
+    }
+    else
+    {
+      ret = -ENXIO;
+    }
+
+  } while (0);
+
+  return ret;
+}
+
+static void __exit board_rev21_can_exit(void)
+{
+  platform_device_unregister(&eco_g45_can_device);
+}
+
+
+module_param_named(can_irq_pin, eco_g45_oki9620_data.irq_pin, int, 0444);
+MODULE_PARM_DESC(can_irq_pin, " IRQ input pin at the AT91, coming from the CAN controller");
+
+module_param(can_chip_select, int, 0444);
+MODULE_PARM_DESC(can_chip_select, " AT91 chip select to the CAN controller (selects base address), valid values: 2, 4, 5");
+
+module_param_named(can_osc_freq, eco_g45_oki9620_data.osc_freq, int, 0444);
+MODULE_PARM_DESC(can_osc_freq, " Oscillator frequency of the CAN controller");
+
+module_init(board_rev21_can_init);
+module_exit(board_rev21_can_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Johannes Lode <linuxer>@quantentunnel.de");
+MODULE_DESCRIPTION("Platform device module for the OK-ML9620 CAN controller on the DYNAvel board Rev2.1.");
--- a/arch/arm/mach-at91/sam9_smc.c
+++ b/arch/arm/mach-at91/sam9_smc.c
@@ -69,6 +69,7 @@ void sam9_smc_configure(int id, int cs,
 {
 	sam9_smc_cs_configure(AT91_SMC_CS(id, cs), config);
 }
+EXPORT_SYMBOL(sam9_smc_configure);
 
 static void sam9_smc_cs_read_mode(void __iomem *base,
 					struct sam9_smc_config *config)
--- a/arch/arm/mach-at91/Makefile
+++ b/arch/arm/mach-at91/Makefile
@@ -81,6 +81,7 @@ obj-$(CONFIG_MACH_SNAPPER_9260)	+= board
 # AT91SAM9G45 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9M10G45EK) += board-sam9m10g45ek.o
 obj-$(CONFIG_MACH_AT91SAM9G45_CONFIG)	+= board-configfs-at91sam9g45.o
+obj-$(CONFIG_MACH_ECOG45_DYNAVEL21)    += board-dynavel-hwrev21-can-oki9620.o
 obj-$(CONFIG_MACH_ECOG45)			+= board-eco-g45.o
 obj-$(CONFIG_MACH_ECOG45_EVAL)		+= board-eco-g45.o board-eval-eco-g45.o
 
--- a/arch/arm/mach-at91/Kconfig.non_dt
+++ b/arch/arm/mach-at91/Kconfig.non_dt
@@ -357,6 +357,16 @@ config MACH_ECOG45_EVAL
 
 endchoice
 
+config MACH_ECOG45_DYNAVEL21
+    tristate "DYNA Instruments GmbH DYNAvel board Rev 2.1"
+    depends on ARCH_AT91SAM9G45 && MACH_ECOG45 && !MACH_AT91SAM9M10G45EK && !MACH_ECOG45_EVAL
+    select CAN_OKI9620
+    select CAN_OKI9620_PLATFORM
+    help
+      Select this for the DYNA Instruments GmbH DYNAvel board Rev 2.1.
+      
+      This enables support for OKI ML9620 CAN controller.
+
 endif
 
 # ----------------------------------------------------------
