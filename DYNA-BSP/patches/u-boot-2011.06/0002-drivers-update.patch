diff -urN u-boot-2011.06/drivers/block/ahci.c u-boot-HEAD/drivers/block/ahci.c
--- u-boot-2011.06/drivers/block/ahci.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/block/ahci.c	2011-09-19 23:25:08.000000000 +0200
@@ -78,13 +78,15 @@
 
 static int ahci_host_init(struct ahci_probe_ent *probe_ent)
 {
+#ifndef CONFIG_SCSI_AHCI_PLAT
 	pci_dev_t pdev = probe_ent->dev;
+	u16 tmp16;
+	unsigned short vendor;
+#endif
 	volatile u8 *mmio = (volatile u8 *)probe_ent->mmio_base;
 	u32 tmp, cap_save;
-	u16 tmp16;
 	int i, j;
 	volatile u8 *port_mmio;
-	unsigned short vendor;
 
 	cap_save = readl(mmio + HOST_CAP);
 	cap_save &= ((1 << 28) | (1 << 17));
@@ -110,6 +112,7 @@
 	writel(cap_save, mmio + HOST_CAP);
 	writel_with_flush(0xf, mmio + HOST_PORTS_IMPL);
 
+#ifndef CONFIG_SCSI_AHCI_PLAT
 	pci_read_config_word(pdev, PCI_VENDOR_ID, &vendor);
 
 	if (vendor == PCI_VENDOR_ID_INTEL) {
@@ -118,7 +121,7 @@
 		tmp16 |= 0xf;
 		pci_write_config_word(pdev, 0x92, tmp16);
 	}
-
+#endif
 	probe_ent->cap = readl(mmio + HOST_CAP);
 	probe_ent->port_map = readl(mmio + HOST_PORTS_IMPL);
 	probe_ent->n_ports = (probe_ent->cap & 0x1f) + 1;
@@ -183,22 +186,24 @@
 	writel(tmp | HOST_IRQ_EN, mmio + HOST_CTL);
 	tmp = readl(mmio + HOST_CTL);
 	debug("HOST_CTL 0x%x\n", tmp);
-
+#ifndef CONFIG_SCSI_AHCI_PLAT
 	pci_read_config_word(pdev, PCI_COMMAND, &tmp16);
 	tmp |= PCI_COMMAND_MASTER;
 	pci_write_config_word(pdev, PCI_COMMAND, tmp16);
-
+#endif
 	return 0;
 }
 
 
 static void ahci_print_info(struct ahci_probe_ent *probe_ent)
 {
+#ifndef CONFIG_SCSI_AHCI_PLAT
 	pci_dev_t pdev = probe_ent->dev;
+	u16 cc;
+#endif
 	volatile u8 *mmio = (volatile u8 *)probe_ent->mmio_base;
 	u32 vers, cap, impl, speed;
 	const char *speed_s;
-	u16 cc;
 	const char *scc_s;
 
 	vers = readl(mmio + HOST_VERSION);
@@ -213,6 +218,9 @@
 	else
 		speed_s = "?";
 
+#ifdef CONFIG_SCSI_AHCI_PLAT
+	scc_s = "SATA";
+#else
 	pci_read_config_word(pdev, 0x0a, &cc);
 	if (cc == 0x0101)
 		scc_s = "IDE";
@@ -222,7 +230,7 @@
 		scc_s = "RAID";
 	else
 		scc_s = "unknown";
-
+#endif
 	printf("AHCI %02x%02x.%02x%02x "
 	       "%u slots %u ports %s Gbps 0x%x impl %s mode\n",
 	       (vers >> 24) & 0xff,
@@ -249,6 +257,7 @@
 	       cap & (1 << 13) ? "part " : "");
 }
 
+#ifndef CONFIG_SCSI_AHCI_PLAT
 static int ahci_init_one(pci_dev_t pdev)
 {
 	u16 vendor;
@@ -291,7 +300,7 @@
       err_out:
 	return rc;
 }
-
+#endif
 
 #define MAX_DATA_BYTE_COUNT  (4*1024*1024)
 
@@ -468,7 +477,7 @@
 {
 	int i;
 	for (i = 0; i < len / 2; i++)
-		target[i] = le16_to_cpu(src[i]);
+		target[i] = swab16(src[i]);
 	return (char *)target;
 }
 
@@ -667,7 +676,9 @@
 	int i;
 	u32 linkmap;
 
+#ifndef CONFIG_SCSI_AHCI_PLAT
 	ahci_init_one(busdevfunc);
+#endif
 
 	linkmap = probe_ent->link_port_map;
 
@@ -682,6 +693,49 @@
 	}
 }
 
+#ifdef CONFIG_SCSI_AHCI_PLAT
+int ahci_init(u32 base)
+{
+	int i, rc = 0;
+	u32 linkmap;
+
+	memset(ataid, 0, sizeof(ataid));
+
+	probe_ent = malloc(sizeof(struct ahci_probe_ent));
+	memset(probe_ent, 0, sizeof(struct ahci_probe_ent));
+
+	probe_ent->host_flags = ATA_FLAG_SATA
+				| ATA_FLAG_NO_LEGACY
+				| ATA_FLAG_MMIO
+				| ATA_FLAG_PIO_DMA
+				| ATA_FLAG_NO_ATAPI;
+	probe_ent->pio_mask = 0x1f;
+	probe_ent->udma_mask = 0x7f;	/*Fixme,assume to support UDMA6 */
+
+	probe_ent->mmio_base = base;
+
+	/* initialize adapter */
+	rc = ahci_host_init(probe_ent);
+	if (rc)
+		goto err_out;
+
+	ahci_print_info(probe_ent);
+
+	linkmap = probe_ent->link_port_map;
+
+	for (i = 0; i < CONFIG_SYS_SCSI_MAX_SCSI_ID; i++) {
+		if (((linkmap >> i) & 0x01)) {
+			if (ahci_port_start((u8) i)) {
+				printf("Can not start port %d\n", i);
+				continue;
+			}
+			ahci_set_feature((u8) i);
+		}
+	}
+err_out:
+	return rc;
+}
+#endif
 
 void scsi_bus_reset(void)
 {
diff -urN u-boot-2011.06/drivers/block/mg_disk.c u-boot-HEAD/drivers/block/mg_disk.c
--- u-boot-2011.06/drivers/block/mg_disk.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/block/mg_disk.c	2011-09-19 23:25:08.000000000 +0200
@@ -91,7 +91,9 @@
 	u32 from, cur, err;
 
 	err = MG_ERR_NONE;
+#ifdef CONFIG_SYS_LOW_RES_TIMER
 	reset_timer();
+#endif
 	from = get_timer(0);
 
 	status = readb(mg_base() + MG_REG_STATUS);
@@ -522,10 +524,12 @@
 	return err;
 }
 
+#ifdef CONFIG_PARTITIONS
 block_dev_desc_t *mg_disk_get_dev(int dev)
 {
 	return ((block_dev_desc_t *) & mg_disk_dev);
 }
+#endif
 
 /* must override this function */
 struct mg_drv_data * __attribute__((weak)) mg_get_drv_data (void)
diff -urN u-boot-2011.06/drivers/block/sata_sil3114.c u-boot-HEAD/drivers/block/sata_sil3114.c
--- u-boot-2011.06/drivers/block/sata_sil3114.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/block/sata_sil3114.c	2011-09-19 23:25:08.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) Excito Elektronik i Skåne AB, All rights reserved.
+ * Copyright (C) Excito Elektronik i SkÃ¥ne AB, All rights reserved.
  * Author: Tor Krill <tor@excito.com>
  *
  * This program is free software; you can redistribute it and/or
diff -urN u-boot-2011.06/drivers/block/sata_sil3114.h u-boot-HEAD/drivers/block/sata_sil3114.h
--- u-boot-2011.06/drivers/block/sata_sil3114.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/block/sata_sil3114.h	2011-09-19 23:25:08.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) Excito Elektronik i Skåne AB, All rights reserved.
+ * Copyright (C) Excito Elektronik i SkÃ¥ne AB, All rights reserved.
  * Author: Tor Krill <tor@excito.com>
  *
  * This program is free software; you can redistribute it and/or
diff -urN u-boot-2011.06/drivers/block/systemace.c u-boot-HEAD/drivers/block/systemace.c
--- u-boot-2011.06/drivers/block/systemace.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/block/systemace.c	2011-09-19 23:25:08.000000000 +0200
@@ -104,6 +104,7 @@
 	ace_writew((val & 0xffff), 0x18);
 }
 
+#ifdef CONFIG_PARTITIONS
 block_dev_desc_t *systemace_get_dev(int dev)
 {
 	/* The first time through this, the systemace_dev object is
@@ -128,6 +129,7 @@
 
 	return &systemace_dev;
 }
+#endif
 
 /*
  * This function is called (by dereferencing the block_read pointer in
 
diff -urN u-boot-2011.06/drivers/fpga/ACEX1K.c u-boot-HEAD/drivers/fpga/ACEX1K.c
--- u-boot-2011.06/drivers/fpga/ACEX1K.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/ACEX1K.c	2011-09-19 23:25:08.000000000 +0200
@@ -48,13 +48,13 @@
 #define CONFIG_SYS_FPGA_WAIT CONFIG_SYS_HZ/10		/* 100 ms */
 #endif
 
-static int ACEX1K_ps_load( Altera_desc *desc, void *buf, size_t bsize );
-static int ACEX1K_ps_dump( Altera_desc *desc, void *buf, size_t bsize );
-/* static int ACEX1K_ps_info( Altera_desc *desc ); */
+static int ACEX1K_ps_load(Altera_desc *desc, const void *buf, size_t bsize);
+static int ACEX1K_ps_dump(Altera_desc *desc, const void *buf, size_t bsize);
+/* static int ACEX1K_ps_info(Altera_desc *desc); */
 
 /* ------------------------------------------------------------------------- */
 /* ACEX1K Generic Implementation */
-int ACEX1K_load (Altera_desc * desc, void *buf, size_t bsize)
+int ACEX1K_load(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -74,7 +74,7 @@
 	return ret_val;
 }
 
-int ACEX1K_dump (Altera_desc * desc, void *buf, size_t bsize)
+int ACEX1K_dump(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -103,7 +103,7 @@
 /* ------------------------------------------------------------------------- */
 /* ACEX1K Passive Serial Generic Implementation                                  */
 
-static int ACEX1K_ps_load (Altera_desc * desc, void *buf, size_t bsize)
+static int ACEX1K_ps_load(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume the worst */
 	Altera_ACEX1K_Passive_Serial_fns *fn = desc->iface_fns;
@@ -256,7 +256,7 @@
 	return ret_val;
 }
 
-static int ACEX1K_ps_dump (Altera_desc * desc, void *buf, size_t bsize)
+static int ACEX1K_ps_dump(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	/* Readback is only available through the Slave Parallel and         */
 	/* boundary-scan interfaces.                                         */
diff -urN u-boot-2011.06/drivers/fpga/altera.c u-boot-HEAD/drivers/fpga/altera.c
--- u-boot-2011.06/drivers/fpga/altera.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/altera.c	2011-09-19 23:25:08.000000000 +0200
@@ -45,7 +45,7 @@
 static int altera_validate (Altera_desc * desc, const char *fn);
 
 /* ------------------------------------------------------------------------- */
-int altera_load( Altera_desc *desc, void *buf, size_t bsize )
+int altera_load(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume a failure */
 
@@ -60,7 +60,7 @@
 					__FUNCTION__);
 			ret_val = ACEX1K_load (desc, buf, bsize);
 #elif defined(CONFIG_FPGA_CYCLON2)
-			PRINTF ("%s: Launching the CYCLON II Loader...\n",
+			PRINTF ("%s: Launching the CYCLONE II Loader...\n",
 					__FUNCTION__);
 			ret_val = CYC2_load (desc, buf, bsize);
 #else
@@ -85,7 +85,7 @@
 	return ret_val;
 }
 
-int altera_dump( Altera_desc *desc, void *buf, size_t bsize )
+int altera_dump(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume a failure */
 
diff -urN u-boot-2011.06/drivers/fpga/cyclon2.c u-boot-HEAD/drivers/fpga/cyclon2.c
--- u-boot-2011.06/drivers/fpga/cyclon2.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/cyclon2.c	2011-09-19 23:25:08.000000000 +0200
@@ -47,13 +47,13 @@
 #define CONFIG_SYS_FPGA_WAIT CONFIG_SYS_HZ/10		/* 100 ms */
 #endif
 
-static int CYC2_ps_load( Altera_desc *desc, void *buf, size_t bsize );
-static int CYC2_ps_dump( Altera_desc *desc, void *buf, size_t bsize );
+static int CYC2_ps_load(Altera_desc *desc, const void *buf, size_t bsize);
+static int CYC2_ps_dump(Altera_desc *desc, const void *buf, size_t bsize);
 /* static int CYC2_ps_info( Altera_desc *desc ); */
 
 /* ------------------------------------------------------------------------- */
 /* CYCLON2 Generic Implementation */
-int CYC2_load (Altera_desc * desc, void *buf, size_t bsize)
+int CYC2_load(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -63,6 +63,16 @@
 		ret_val = CYC2_ps_load (desc, buf, bsize);
 		break;
 
+	case fast_passive_parallel:
+		/* Fast Passive Parallel (FPP) and PS only differ in what is
+		 * done in the write() callback. Use the existing PS load
+		 * function for FPP, too.
+		 */
+		PRINTF ("%s: Launching Fast Passive Parallel Loader\n",
+		      __FUNCTION__);
+		ret_val = CYC2_ps_load(desc, buf, bsize);
+		break;
+
 		/* Add new interface types here */
 
 	default:
@@ -73,7 +83,7 @@
 	return ret_val;
 }
 
-int CYC2_dump (Altera_desc * desc, void *buf, size_t bsize)
+int CYC2_dump(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -100,7 +110,7 @@
 
 /* ------------------------------------------------------------------------- */
 /* CYCLON2 Passive Serial Generic Implementation                                  */
-static int CYC2_ps_load (Altera_desc * desc, void *buf, size_t bsize)
+static int CYC2_ps_load(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume the worst */
 	Altera_CYC2_Passive_Serial_fns *fn = desc->iface_fns;
@@ -200,7 +210,7 @@
 	return ret_val;
 }
 
-static int CYC2_ps_dump (Altera_desc * desc, void *buf, size_t bsize)
+static int CYC2_ps_dump(Altera_desc *desc, const void *buf, size_t bsize)
 {
 	/* Readback is only available through the Slave Parallel and         */
 	/* boundary-scan interfaces.                                         */
diff -urN u-boot-2011.06/drivers/fpga/fpga.c u-boot-HEAD/drivers/fpga/fpga.c
--- u-boot-2011.06/drivers/fpga/fpga.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/fpga.c	2011-09-19 23:25:08.000000000 +0200
@@ -52,7 +52,7 @@
 
 /* Local static functions */
 static __attribute__((__const__)) fpga_desc * __attribute__((__const__)) fpga_get_desc( int devnum );
-static __attribute__((__const__)) fpga_desc * __attribute__((__const__)) fpga_validate( int devnum, void *buf,
+static __attribute__((__const__)) fpga_desc * __attribute__((__const__)) fpga_validate(int devnum, const void *buf,
 					 size_t bsize, char *fn );
 static int fpga_dev_info( int devnum );
 
@@ -94,7 +94,7 @@
 /* fpga_validate
  *	generic parameter checking code
  */
-static __attribute__((__const__)) fpga_desc * __attribute__((__const__)) fpga_validate( int devnum, void *buf,
+static __attribute__((__const__)) fpga_desc * __attribute__((__const__)) fpga_validate(int devnum, const void *buf,
 					 size_t bsize, char *fn )
 {
 	fpga_desc * desc = fpga_get_desc( devnum );
@@ -212,7 +212,7 @@
 /*
  *	Generic multiplexing code
  */
-int fpga_load( int devnum, void *buf, size_t bsize )
+int fpga_load(int devnum, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;           /* assume failure */
 	fpga_desc * desc = fpga_validate( devnum, buf, bsize, (char *)__FUNCTION__ );
@@ -252,7 +252,7 @@
 /* fpga_dump
  *	generic multiplexing code
  */
-int fpga_dump( int devnum, void *buf, size_t bsize )
+int fpga_dump(int devnum, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;           /* assume failure */
 	fpga_desc * desc = fpga_validate( devnum, buf, bsize, (char *)__FUNCTION__ );
diff -urN u-boot-2011.06/drivers/fpga/lattice.c u-boot-HEAD/drivers/fpga/lattice.c
--- u-boot-2011.06/drivers/fpga/lattice.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/lattice.c	2011-09-19 23:25:08.000000000 +0200
@@ -34,7 +34,7 @@
 #include <lattice.h>
 
 static lattice_board_specific_func *pfns;
-static char *fpga_image;
+static const char *fpga_image;
 static unsigned long read_bytes;
 static unsigned long bufsize;
 static unsigned short expectedCRC;
@@ -302,7 +302,7 @@
 	return ret_val;
 }
 
-int lattice_load(Lattice_desc *desc, void *buf, size_t bsize)
+int lattice_load(Lattice_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -335,7 +335,7 @@
 	return ret_val;
 }
 
-int lattice_dump(Lattice_desc *desc, void *buf, size_t bsize)
+int lattice_dump(Lattice_desc *desc, const void *buf, size_t bsize)
 {
 	puts("Dump not supported for Lattice FPGA\n");
 
diff -urN u-boot-2011.06/drivers/fpga/spartan2.c u-boot-HEAD/drivers/fpga/spartan2.c
--- u-boot-2011.06/drivers/fpga/spartan2.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/spartan2.c	2011-09-19 23:25:08.000000000 +0200
@@ -48,17 +48,17 @@
 #define CONFIG_SYS_FPGA_WAIT CONFIG_SYS_HZ/100	/* 10 ms */
 #endif
 
-static int Spartan2_sp_load( Xilinx_desc *desc, void *buf, size_t bsize );
-static int Spartan2_sp_dump( Xilinx_desc *desc, void *buf, size_t bsize );
-/* static int Spartan2_sp_info( Xilinx_desc *desc ); */
-
-static int Spartan2_ss_load( Xilinx_desc *desc, void *buf, size_t bsize );
-static int Spartan2_ss_dump( Xilinx_desc *desc, void *buf, size_t bsize );
-/* static int Spartan2_ss_info( Xilinx_desc *desc ); */
+static int Spartan2_sp_load(Xilinx_desc *desc, const void *buf, size_t bsize);
+static int Spartan2_sp_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+/* static int Spartan2_sp_info(Xilinx_desc *desc ); */
+
+static int Spartan2_ss_load(Xilinx_desc *desc, const void *buf, size_t bsize);
+static int Spartan2_ss_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+/* static int Spartan2_ss_info(Xilinx_desc *desc ); */
 
 /* ------------------------------------------------------------------------- */
 /* Spartan-II Generic Implementation */
-int Spartan2_load (Xilinx_desc * desc, void *buf, size_t bsize)
+int Spartan2_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -81,7 +81,7 @@
 	return ret_val;
 }
 
-int Spartan2_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+int Spartan2_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -113,7 +113,7 @@
 /* ------------------------------------------------------------------------- */
 /* Spartan-II Slave Parallel Generic Implementation */
 
-static int Spartan2_sp_load (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Spartan2_sp_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume the worst */
 	Xilinx_Spartan2_Slave_Parallel_fns *fn = desc->iface_fns;
@@ -265,7 +265,7 @@
 	return ret_val;
 }
 
-static int Spartan2_sp_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Spartan2_sp_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume the worst */
 	Xilinx_Spartan2_Slave_Parallel_fns *fn = desc->iface_fns;
@@ -313,7 +313,7 @@
 
 /* ------------------------------------------------------------------------- */
 
-static int Spartan2_ss_load (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Spartan2_ss_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume the worst */
 	Xilinx_Spartan2_Slave_Serial_fns *fn = desc->iface_fns;
@@ -456,7 +456,7 @@
 	return ret_val;
 }
 
-static int Spartan2_ss_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Spartan2_ss_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	/* Readback is only available through the Slave Parallel and         */
 	/* boundary-scan interfaces.                                         */
diff -urN u-boot-2011.06/drivers/fpga/spartan3.c u-boot-HEAD/drivers/fpga/spartan3.c
--- u-boot-2011.06/drivers/fpga/spartan3.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/spartan3.c	2011-09-19 23:25:08.000000000 +0200
@@ -53,17 +53,17 @@
 #define CONFIG_SYS_FPGA_WAIT CONFIG_SYS_HZ/100	/* 10 ms */
 #endif
 
-static int Spartan3_sp_load( Xilinx_desc *desc, void *buf, size_t bsize );
-static int Spartan3_sp_dump( Xilinx_desc *desc, void *buf, size_t bsize );
-/* static int Spartan3_sp_info( Xilinx_desc *desc ); */
-
-static int Spartan3_ss_load( Xilinx_desc *desc, void *buf, size_t bsize );
-static int Spartan3_ss_dump( Xilinx_desc *desc, void *buf, size_t bsize );
-/* static int Spartan3_ss_info( Xilinx_desc *desc ); */
+static int Spartan3_sp_load(Xilinx_desc *desc, const void *buf, size_t bsize);
+static int Spartan3_sp_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+/* static int Spartan3_sp_info(Xilinx_desc *desc ); */
+
+static int Spartan3_ss_load(Xilinx_desc *desc, const void *buf, size_t bsize);
+static int Spartan3_ss_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+/* static int Spartan3_ss_info(Xilinx_desc *desc); */
 
 /* ------------------------------------------------------------------------- */
 /* Spartan-II Generic Implementation */
-int Spartan3_load (Xilinx_desc * desc, void *buf, size_t bsize)
+int Spartan3_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -86,7 +86,7 @@
 	return ret_val;
 }
 
-int Spartan3_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+int Spartan3_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -118,7 +118,7 @@
 /* ------------------------------------------------------------------------- */
 /* Spartan-II Slave Parallel Generic Implementation */
 
-static int Spartan3_sp_load (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Spartan3_sp_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume the worst */
 	Xilinx_Spartan3_Slave_Parallel_fns *fn = desc->iface_fns;
@@ -272,7 +272,7 @@
 	return ret_val;
 }
 
-static int Spartan3_sp_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Spartan3_sp_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume the worst */
 	Xilinx_Spartan3_Slave_Parallel_fns *fn = desc->iface_fns;
@@ -320,7 +320,7 @@
 
 /* ------------------------------------------------------------------------- */
 
-static int Spartan3_ss_load (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Spartan3_ss_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume the worst */
 	Xilinx_Spartan3_Slave_Serial_fns *fn = desc->iface_fns;
@@ -475,7 +475,7 @@
 	return ret_val;
 }
 
-static int Spartan3_ss_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Spartan3_ss_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	/* Readback is only available through the Slave Parallel and         */
 	/* boundary-scan interfaces.                                         */
diff -urN u-boot-2011.06/drivers/fpga/virtex2.c u-boot-HEAD/drivers/fpga/virtex2.c
--- u-boot-2011.06/drivers/fpga/virtex2.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/virtex2.c	2011-09-19 23:25:08.000000000 +0200
@@ -101,13 +101,13 @@
 #define CONFIG_SYS_FPGA_WAIT_CONFIG	CONFIG_SYS_HZ/5	/* 200 ms */
 #endif
 
-static int Virtex2_ssm_load (Xilinx_desc * desc, void *buf, size_t bsize);
-static int Virtex2_ssm_dump (Xilinx_desc * desc, void *buf, size_t bsize);
+static int Virtex2_ssm_load(Xilinx_desc *desc, const void *buf, size_t bsize);
+static int Virtex2_ssm_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
 
-static int Virtex2_ss_load (Xilinx_desc * desc, void *buf, size_t bsize);
-static int Virtex2_ss_dump (Xilinx_desc * desc, void *buf, size_t bsize);
+static int Virtex2_ss_load(Xilinx_desc *desc, const void *buf, size_t bsize);
+static int Virtex2_ss_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
 
-int Virtex2_load (Xilinx_desc * desc, void *buf, size_t bsize)
+int Virtex2_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -129,7 +129,7 @@
 	return ret_val;
 }
 
-int Virtex2_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+int Virtex2_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 
@@ -170,7 +170,7 @@
  *    INIT_B and DONE lines.  If both are high, configuration has
  *    succeeded. Congratulations!
  */
-static int Virtex2_ssm_load (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Virtex2_ssm_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 	Xilinx_Virtex2_Slave_SelectMap_fns *fn = desc->iface_fns;
@@ -369,7 +369,7 @@
 /*
  * Read the FPGA configuration data
  */
-static int Virtex2_ssm_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Virtex2_ssm_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;
 	Xilinx_Virtex2_Slave_SelectMap_fns *fn = desc->iface_fns;
@@ -421,13 +421,13 @@
 	return ret_val;
 }
 
-static int Virtex2_ss_load (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Virtex2_ss_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	printf ("%s: Slave Serial Loading is unsupported\n", __FUNCTION__);
 	return FPGA_FAIL;
 }
 
-static int Virtex2_ss_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+static int Virtex2_ss_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	printf ("%s: Slave Serial Dumping is unsupported\n", __FUNCTION__);
 	return FPGA_FAIL;
diff -urN u-boot-2011.06/drivers/fpga/xilinx.c u-boot-HEAD/drivers/fpga/xilinx.c
--- u-boot-2011.06/drivers/fpga/xilinx.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/fpga/xilinx.c	2011-09-19 23:25:08.000000000 +0200
@@ -48,7 +48,7 @@
 
 /* ------------------------------------------------------------------------- */
 
-int xilinx_load (Xilinx_desc * desc, void *buf, size_t bsize)
+int xilinx_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume a failure */
 
@@ -95,7 +95,7 @@
 	return ret_val;
 }
 
-int xilinx_dump (Xilinx_desc * desc, void *buf, size_t bsize)
+int xilinx_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 {
 	int ret_val = FPGA_FAIL;	/* assume a failure */
 
diff -urN u-boot-2011.06/drivers/gpio/da8xx_gpio.c u-boot-HEAD/drivers/gpio/da8xx_gpio.c
--- u-boot-2011.06/drivers/gpio/da8xx_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/gpio/da8xx_gpio.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,270 @@
+/*
+ * GPIO driver for TI DaVinci DA8xx SOCs.
+ *
+ * (C) Copyright 2011 Guralp Systems Ltd.
+ * Laurence Withers <lwithers@guralp.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/davinci_misc.h>
+
+static struct gpio_registry {
+	int is_registered;
+	char name[GPIO_NAME_SIZE];
+} gpio_registry[MAX_NUM_GPIOS];
+
+#define pinmux(x)       (&davinci_syscfg_regs->pinmux[x])
+
+static const struct pinmux_config gpio_pinmux[] = {
+	{ pinmux(1), 8, 7 },	/* GP0[0] */
+	{ pinmux(1), 8, 6 },
+	{ pinmux(1), 8, 5 },
+	{ pinmux(1), 8, 4 },
+	{ pinmux(1), 8, 3 },
+	{ pinmux(1), 8, 2 },
+	{ pinmux(1), 8, 1 },
+	{ pinmux(1), 8, 0 },
+	{ pinmux(0), 8, 7 },
+	{ pinmux(0), 8, 6 },
+	{ pinmux(0), 8, 5 },
+	{ pinmux(0), 8, 4 },
+	{ pinmux(0), 8, 3 },
+	{ pinmux(0), 8, 2 },
+	{ pinmux(0), 8, 1 },
+	{ pinmux(0), 8, 0 },
+	{ pinmux(4), 8, 7 },	/* GP1[0] */
+	{ pinmux(4), 8, 6 },
+	{ pinmux(4), 8, 5 },
+	{ pinmux(4), 8, 4 },
+	{ pinmux(4), 8, 3 },
+	{ pinmux(4), 8, 2 },
+	{ pinmux(4), 4, 1 },
+	{ pinmux(4), 4, 0 },
+	{ pinmux(3), 4, 0 },
+	{ pinmux(2), 4, 6 },
+	{ pinmux(2), 4, 5 },
+	{ pinmux(2), 4, 4 },
+	{ pinmux(2), 4, 3 },
+	{ pinmux(2), 4, 2 },
+	{ pinmux(2), 4, 1 },
+	{ pinmux(2), 8, 0 },
+	{ pinmux(6), 8, 7 },	/* GP2[0] */
+	{ pinmux(6), 8, 6 },
+	{ pinmux(6), 8, 5 },
+	{ pinmux(6), 8, 4 },
+	{ pinmux(6), 8, 3 },
+	{ pinmux(6), 8, 2 },
+	{ pinmux(6), 8, 1 },
+	{ pinmux(6), 8, 0 },
+	{ pinmux(5), 8, 7 },
+	{ pinmux(5), 8, 6 },
+	{ pinmux(5), 8, 5 },
+	{ pinmux(5), 8, 4 },
+	{ pinmux(5), 8, 3 },
+	{ pinmux(5), 8, 2 },
+	{ pinmux(5), 8, 1 },
+	{ pinmux(5), 8, 0 },
+	{ pinmux(8), 8, 7 },	/* GP3[0] */
+	{ pinmux(8), 8, 6 },
+	{ pinmux(8), 8, 5 },
+	{ pinmux(8), 8, 4 },
+	{ pinmux(8), 8, 3 },
+	{ pinmux(8), 8, 2 },
+	{ pinmux(8), 8, 1 },
+	{ pinmux(8), 8, 0 },
+	{ pinmux(7), 8, 7 },
+	{ pinmux(7), 8, 6 },
+	{ pinmux(7), 8, 5 },
+	{ pinmux(7), 8, 4 },
+	{ pinmux(7), 8, 3 },
+	{ pinmux(7), 8, 2 },
+	{ pinmux(7), 8, 1 },
+	{ pinmux(7), 8, 0 },
+	{ pinmux(10), 8, 7 },	/* GP4[0] */
+	{ pinmux(10), 8, 6 },
+	{ pinmux(10), 8, 5 },
+	{ pinmux(10), 8, 4 },
+	{ pinmux(10), 8, 3 },
+	{ pinmux(10), 8, 2 },
+	{ pinmux(10), 8, 1 },
+	{ pinmux(10), 8, 0 },
+	{ pinmux(9), 8, 7 },
+	{ pinmux(9), 8, 6 },
+	{ pinmux(9), 8, 5 },
+	{ pinmux(9), 8, 4 },
+	{ pinmux(9), 8, 3 },
+	{ pinmux(9), 8, 2 },
+	{ pinmux(9), 8, 1 },
+	{ pinmux(9), 8, 0 },
+	{ pinmux(12), 8, 7 },	/* GP5[0] */
+	{ pinmux(12), 8, 6 },
+	{ pinmux(12), 8, 5 },
+	{ pinmux(12), 8, 4 },
+	{ pinmux(12), 8, 3 },
+	{ pinmux(12), 8, 2 },
+	{ pinmux(12), 8, 1 },
+	{ pinmux(12), 8, 0 },
+	{ pinmux(11), 8, 7 },
+	{ pinmux(11), 8, 6 },
+	{ pinmux(11), 8, 5 },
+	{ pinmux(11), 8, 4 },
+	{ pinmux(11), 8, 3 },
+	{ pinmux(11), 8, 2 },
+	{ pinmux(11), 8, 1 },
+	{ pinmux(11), 8, 0 },
+	{ pinmux(19), 8, 6 },	/* GP6[0] */
+	{ pinmux(19), 8, 5 },
+	{ pinmux(19), 8, 4 },
+	{ pinmux(19), 8, 3 },
+	{ pinmux(19), 8, 2 },
+	{ pinmux(16), 8, 1 },
+	{ pinmux(14), 8, 1 },
+	{ pinmux(14), 8, 0 },
+	{ pinmux(13), 8, 7 },
+	{ pinmux(13), 8, 6 },
+	{ pinmux(13), 8, 5 },
+	{ pinmux(13), 8, 4 },
+	{ pinmux(13), 8, 3 },
+	{ pinmux(13), 8, 2 },
+	{ pinmux(13), 8, 1 },
+	{ pinmux(13), 8, 0 },
+	{ pinmux(18), 8, 1 },	/* GP7[0] */
+	{ pinmux(18), 8, 0 },
+	{ pinmux(17), 8, 7 },
+	{ pinmux(17), 8, 6 },
+	{ pinmux(17), 8, 5 },
+	{ pinmux(17), 8, 4 },
+	{ pinmux(17), 8, 3 },
+	{ pinmux(17), 8, 2 },
+	{ pinmux(17), 8, 1 },
+	{ pinmux(17), 8, 0 },
+	{ pinmux(16), 8, 7 },
+	{ pinmux(16), 8, 6 },
+	{ pinmux(16), 8, 5 },
+	{ pinmux(16), 8, 4 },
+	{ pinmux(16), 8, 3 },
+	{ pinmux(16), 8, 2 },
+	{ pinmux(19), 8, 0 },	/* GP8[0] */
+	{ pinmux(3), 4, 7 },
+	{ pinmux(3), 4, 6 },
+	{ pinmux(3), 4, 5 },
+	{ pinmux(3), 4, 4 },
+	{ pinmux(3), 4, 3 },
+	{ pinmux(3), 4, 2 },
+	{ pinmux(2), 4, 7 },
+	{ pinmux(19), 8, 1 },
+	{ pinmux(19), 8, 0 },
+	{ pinmux(18), 8, 7 },
+	{ pinmux(18), 8, 6 },
+	{ pinmux(18), 8, 5 },
+	{ pinmux(18), 8, 4 },
+	{ pinmux(18), 8, 3 },
+	{ pinmux(18), 8, 2 },
+};
+
+int gpio_request(int gp, const char *label)
+{
+	if (gp >= MAX_NUM_GPIOS)
+		return -1;
+
+	if (gpio_registry[gp].is_registered)
+		return -1;
+
+	gpio_registry[gp].is_registered = 1;
+	strncpy(gpio_registry[gp].name, label, GPIO_NAME_SIZE);
+	gpio_registry[gp].name[GPIO_NAME_SIZE - 1] = 0;
+
+	davinci_configure_pin_mux(&gpio_pinmux[gp], 1);
+
+	return 0;
+}
+
+void gpio_free(int gp)
+{
+	gpio_registry[gp].is_registered = 0;
+}
+
+void gpio_toggle_value(int gp)
+{
+	struct davinci_gpio *bank;
+
+	bank = GPIO_BANK(gp);
+	gpio_set_value(gp, !gpio_get_value(gp));
+}
+
+int gpio_direction_input(int gp)
+{
+	struct davinci_gpio *bank;
+
+	bank = GPIO_BANK(gp);
+	setbits_le32(&bank->dir, 1U << GPIO_BIT(gp));
+	return 0;
+}
+
+int gpio_direction_output(int gp, int value)
+{
+	struct davinci_gpio *bank;
+
+	bank = GPIO_BANK(gp);
+	clrbits_le32(&bank->dir, 1U << GPIO_BIT(gp));
+	gpio_set_value(gp, value);
+	return 0;
+}
+
+int gpio_get_value(int gp)
+{
+	struct davinci_gpio *bank;
+	unsigned int ip;
+
+	bank = GPIO_BANK(gp);
+	ip = in_le32(&bank->in_data) & (1U << GPIO_BIT(gp));
+	return ip ? 1 : 0;
+}
+
+void gpio_set_value(int gp, int value)
+{
+	struct davinci_gpio *bank;
+
+	bank = GPIO_BANK(gp);
+
+	if (value)
+		bank->set_data = 1U << GPIO_BIT(gp);
+	else
+		bank->clr_data = 1U << GPIO_BIT(gp);
+}
+
+void gpio_info(void)
+{
+	int gp, dir, val;
+	struct davinci_gpio *bank;
+
+	for (gp = 0; gp < MAX_NUM_GPIOS; ++gp) {
+		bank = GPIO_BANK(gp);
+		dir = in_le32(&bank->dir) & (1U << GPIO_BIT(gp));
+		val = gpio_get_value(gp);
+
+		printf("% 4d: %s: %d [%c] %s\n",
+			gp, dir ? " in" : "out", val,
+			gpio_registry[gp].is_registered ? 'x' : ' ',
+			gpio_registry[gp].name);
+	}
+}
diff -urN u-boot-2011.06/drivers/gpio/Makefile u-boot-HEAD/drivers/gpio/Makefile
--- u-boot-2011.06/drivers/gpio/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/gpio/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -31,6 +31,8 @@
 COBJS-$(CONFIG_MXC_GPIO)	+= mxc_gpio.o
 COBJS-$(CONFIG_PCA953X)		+= pca953x.o
 COBJS-$(CONFIG_S5P)		+= s5p_gpio.o
+COBJS-$(CONFIG_TEGRA2_GPIO)	+= tegra2_gpio.o
+COBJS-$(CONFIG_DA8XX_GPIO)	+= da8xx_gpio.o
 
 COBJS	:= $(COBJS-y)
 SRCS 	:= $(COBJS:.o=.c)
diff -urN u-boot-2011.06/drivers/gpio/mxc_gpio.c u-boot-HEAD/drivers/gpio/mxc_gpio.c
--- u-boot-2011.06/drivers/gpio/mxc_gpio.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/gpio/mxc_gpio.c	2011-09-19 23:25:08.000000000 +0200
@@ -2,6 +2,9 @@
  * Copyright (C) 2009
  * Guennadi Liakhovetski, DENX Software Engineering, <lg@denx.de>
  *
+ * Copyright (C) 2011
+ * Stefano Babic, DENX Software Engineering, <sbabic@denx.de>
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -22,10 +25,16 @@
  */
 #include <common.h>
 #include <asm/arch/imx-regs.h>
+#include <asm/gpio.h>
 #include <asm/io.h>
-#include <mxc_gpio.h>
 #include <errno.h>
 
+enum mxc_gpio_direction {
+	MXC_GPIO_DIRECTION_IN,
+	MXC_GPIO_DIRECTION_OUT,
+};
+
+
 /* GPIO port description */
 static unsigned long gpio_ports[] = {
 	[0] = GPIO1_BASE_ADDR,
@@ -41,7 +50,8 @@
 #endif
 };
 
-int mxc_gpio_direction(unsigned int gpio, enum mxc_gpio_direction direction)
+static int mxc_gpio_direction(unsigned int gpio,
+	enum mxc_gpio_direction direction)
 {
 	unsigned int port = gpio >> 5;
 	struct gpio_regs *regs;
@@ -68,7 +78,7 @@
 	return 0;
 }
 
-void mxc_gpio_set(unsigned int gpio, unsigned int value)
+void gpio_set_value(int gpio, int value)
 {
 	unsigned int port = gpio >> 5;
 	struct gpio_regs *regs;
@@ -89,7 +99,7 @@
 	writel(l, &regs->gpio_dr);
 }
 
-int mxc_gpio_get(unsigned int gpio)
+int gpio_get_value(int gpio)
 {
 	unsigned int port = gpio >> 5;
 	struct gpio_regs *regs;
@@ -106,3 +116,36 @@
 
 	return l;
 }
+
+int gpio_request(int gp, const char *label)
+{
+	unsigned int port = gp >> 5;
+	if (port >= ARRAY_SIZE(gpio_ports))
+		return -EINVAL;
+	return 0;
+}
+
+void gpio_free(int gp)
+{
+}
+
+void gpio_toggle_value(int gp)
+{
+	gpio_set_value(gp, !gpio_get_value(gp));
+}
+
+int gpio_direction_input(int gp)
+{
+	return mxc_gpio_direction(gp, MXC_GPIO_DIRECTION_IN);
+}
+
+int gpio_direction_output(int gp, int value)
+{
+	int ret = mxc_gpio_direction(gp, MXC_GPIO_DIRECTION_OUT);
+
+	if (ret < 0)
+		return ret;
+
+	gpio_set_value(gp, value);
+	return 0;
+}
diff -urN u-boot-2011.06/drivers/gpio/s5p_gpio.c u-boot-HEAD/drivers/gpio/s5p_gpio.c
--- u-boot-2011.06/drivers/gpio/s5p_gpio.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/gpio/s5p_gpio.c	2011-09-19 23:25:08.000000000 +0200
@@ -36,7 +36,7 @@
 #define RATE_MASK(x)		(0x1 << (x + 16))
 #define RATE_SET(x)		(0x1 << (x + 16))
 
-void gpio_cfg_pin(struct s5p_gpio_bank *bank, int gpio, int cfg)
+void s5p_gpio_cfg_pin(struct s5p_gpio_bank *bank, int gpio, int cfg)
 {
 	unsigned int value;
 
@@ -46,11 +46,11 @@
 	writel(value, &bank->con);
 }
 
-void gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
+void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
 {
 	unsigned int value;
 
-	gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
+	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
 
 	value = readl(&bank->dat);
 	value &= ~DAT_MASK(gpio);
@@ -59,12 +59,12 @@
 	writel(value, &bank->dat);
 }
 
-void gpio_direction_input(struct s5p_gpio_bank *bank, int gpio)
+void s5p_gpio_direction_input(struct s5p_gpio_bank *bank, int gpio)
 {
-	gpio_cfg_pin(bank, gpio, GPIO_INPUT);
+	s5p_gpio_cfg_pin(bank, gpio, GPIO_INPUT);
 }
 
-void gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
+void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
 {
 	unsigned int value;
 
@@ -75,7 +75,7 @@
 	writel(value, &bank->dat);
 }
 
-unsigned int gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
+unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
 {
 	unsigned int value;
 
@@ -83,7 +83,7 @@
 	return !!(value & DAT_MASK(gpio));
 }
 
-void gpio_set_pull(struct s5p_gpio_bank *bank, int gpio, int mode)
+void s5p_gpio_set_pull(struct s5p_gpio_bank *bank, int gpio, int mode)
 {
 	unsigned int value;
 
@@ -102,7 +102,7 @@
 	writel(value, &bank->pull);
 }
 
-void gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
+void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
 {
 	unsigned int value;
 
@@ -123,7 +123,7 @@
 	writel(value, &bank->drv);
 }
 
-void gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
+void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
 {
 	unsigned int value;
 
@@ -141,3 +141,47 @@
 
 	writel(value, &bank->drv);
 }
+
+struct s5p_gpio_bank *s5p_gpio_get_bank(int nr)
+{
+	int bank = nr / GPIO_PER_BANK;
+	bank *= sizeof(struct s5p_gpio_bank);
+
+	return (struct s5p_gpio_bank *) (s5p_gpio_base(nr) + bank);
+}
+
+int s5p_gpio_get_pin(int nr)
+{
+	return nr % GPIO_PER_BANK;
+}
+
+int gpio_request(int gpio, const char *label)
+{
+	return 0;
+}
+
+int gpio_direction_input(int nr)
+{
+	s5p_gpio_direction_input(s5p_gpio_get_bank(nr),
+				s5p_gpio_get_pin(nr));
+	return 0;
+}
+
+int gpio_direction_output(int nr, int value)
+{
+	s5p_gpio_direction_output(s5p_gpio_get_bank(nr),
+				 s5p_gpio_get_pin(nr), value);
+	return 0;
+}
+
+int gpio_get_value(int nr)
+{
+	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(nr),
+				       s5p_gpio_get_pin(nr));
+}
+
+void gpio_set_value(int nr, int value)
+{
+	s5p_gpio_set_value(s5p_gpio_get_bank(nr),
+			  s5p_gpio_get_pin(nr), value);
+}
diff -urN u-boot-2011.06/drivers/gpio/tegra2_gpio.c u-boot-HEAD/drivers/gpio/tegra2_gpio.c
--- u-boot-2011.06/drivers/gpio/tegra2_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/gpio/tegra2_gpio.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,255 @@
+/*
+ * NVIDIA Tegra2 GPIO handling.
+ *  (C) Copyright 2010,2011
+ *  NVIDIA Corporation <www.nvidia.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Based on (mostly copied from) kw_gpio.c based Linux 2.6 kernel driver.
+ * Tom Warren (twarren@nvidia.com)
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/arch/tegra2.h>
+#include <asm/gpio.h>
+
+enum {
+	TEGRA2_CMD_INFO,
+	TEGRA2_CMD_PORT,
+	TEGRA2_CMD_OUTPUT,
+	TEGRA2_CMD_INPUT,
+};
+
+static struct gpio_names {
+	char name[GPIO_NAME_SIZE];
+} gpio_names[MAX_NUM_GPIOS];
+
+static char *get_name(int i)
+{
+	return *gpio_names[i].name ? gpio_names[i].name : "UNKNOWN";
+}
+
+/* Return config of pin 'gp' as GPIO (1) or SFPIO (0) */
+static int get_config(int gp)
+{
+	struct gpio_ctlr *gpio = (struct gpio_ctlr *)NV_PA_GPIO_BASE;
+	struct gpio_ctlr_bank *bank = &gpio->gpio_bank[GPIO_BANK(gp)];
+	u32 u;
+	int type;
+
+	u = readl(&bank->gpio_config[GPIO_PORT(gp)]);
+	type =  (u >> GPIO_BIT(gp)) & 1;
+
+	debug("get_config: port = %d, bit = %d is %s\n",
+		GPIO_FULLPORT(gp), GPIO_BIT(gp), type ? "GPIO" : "SFPIO");
+
+	return type;
+}
+
+/* Config pin 'gp' as GPIO or SFPIO, based on 'type' */
+static void set_config(int gp, int type)
+{
+	struct gpio_ctlr *gpio = (struct gpio_ctlr *)NV_PA_GPIO_BASE;
+	struct gpio_ctlr_bank *bank = &gpio->gpio_bank[GPIO_BANK(gp)];
+	u32 u;
+
+	debug("set_config: port = %d, bit = %d, %s\n",
+		GPIO_FULLPORT(gp), GPIO_BIT(gp), type ? "GPIO" : "SFPIO");
+
+	u = readl(&bank->gpio_config[GPIO_PORT(gp)]);
+	if (type)				/* GPIO */
+		u |= 1 << GPIO_BIT(gp);
+	else
+		u &= ~(1 << GPIO_BIT(gp));
+	writel(u, &bank->gpio_config[GPIO_PORT(gp)]);
+}
+
+/* Return GPIO pin 'gp' direction - 0 = input or 1 = output */
+static int get_direction(int gp)
+{
+	struct gpio_ctlr *gpio = (struct gpio_ctlr *)NV_PA_GPIO_BASE;
+	struct gpio_ctlr_bank *bank = &gpio->gpio_bank[GPIO_BANK(gp)];
+	u32 u;
+	int dir;
+
+	u = readl(&bank->gpio_dir_out[GPIO_PORT(gp)]);
+	dir =  (u >> GPIO_BIT(gp)) & 1;
+
+	debug("get_direction: port = %d, bit = %d, %s\n",
+		GPIO_FULLPORT(gp), GPIO_BIT(gp), dir ? "OUT" : "IN");
+
+	return dir;
+}
+
+/* Config GPIO pin 'gp' as input or output (OE) as per 'output' */
+static void set_direction(int gp, int output)
+{
+	struct gpio_ctlr *gpio = (struct gpio_ctlr *)NV_PA_GPIO_BASE;
+	struct gpio_ctlr_bank *bank = &gpio->gpio_bank[GPIO_BANK(gp)];
+	u32 u;
+
+	debug("set_direction: port = %d, bit = %d, %s\n",
+		GPIO_FULLPORT(gp), GPIO_BIT(gp), output ? "OUT" : "IN");
+
+	u = readl(&bank->gpio_dir_out[GPIO_PORT(gp)]);
+	if (output)
+		u |= 1 << GPIO_BIT(gp);
+	else
+		u &= ~(1 << GPIO_BIT(gp));
+	writel(u, &bank->gpio_dir_out[GPIO_PORT(gp)]);
+}
+
+/* set GPIO pin 'gp' output bit as 0 or 1 as per 'high' */
+static void set_level(int gp, int high)
+{
+	struct gpio_ctlr *gpio = (struct gpio_ctlr *)NV_PA_GPIO_BASE;
+	struct gpio_ctlr_bank *bank = &gpio->gpio_bank[GPIO_BANK(gp)];
+	u32 u;
+
+	debug("set_level: port = %d, bit %d == %d\n",
+		GPIO_FULLPORT(gp), GPIO_BIT(gp), high);
+
+	u = readl(&bank->gpio_out[GPIO_PORT(gp)]);
+	if (high)
+		u |= 1 << GPIO_BIT(gp);
+	else
+		u &= ~(1 << GPIO_BIT(gp));
+	writel(u, &bank->gpio_out[GPIO_PORT(gp)]);
+}
+
+/*
+ * Generic_GPIO primitives.
+ */
+
+int gpio_request(int gp, const char *label)
+{
+	if (gp >= MAX_NUM_GPIOS)
+		return -1;
+
+	strncpy(gpio_names[gp].name, label, GPIO_NAME_SIZE);
+	gpio_names[gp].name[GPIO_NAME_SIZE - 1] = '\0';
+
+	/* Configure as a GPIO */
+	set_config(gp, 1);
+
+	return 0;
+}
+
+void gpio_free(int gp)
+{
+}
+
+/* read GPIO OUT value of pin 'gp' */
+static int gpio_get_output_value(int gp)
+{
+	struct gpio_ctlr *gpio = (struct gpio_ctlr *)NV_PA_GPIO_BASE;
+	struct gpio_ctlr_bank *bank = &gpio->gpio_bank[GPIO_BANK(gp)];
+	int val;
+
+	debug("gpio_get_output_value: pin = %d (port %d:bit %d)\n",
+		gp, GPIO_FULLPORT(gp), GPIO_BIT(gp));
+
+	val = readl(&bank->gpio_out[GPIO_PORT(gp)]);
+
+	return (val >> GPIO_BIT(gp)) & 1;
+}
+
+void gpio_toggle_value(int gp)
+{
+	gpio_set_value(gp, !gpio_get_output_value(gp));
+}
+
+/* set GPIO pin 'gp' as an input */
+int gpio_direction_input(int gp)
+{
+	debug("gpio_direction_input: pin = %d (port %d:bit %d)\n",
+		gp, GPIO_FULLPORT(gp), GPIO_BIT(gp));
+
+	/* Configure GPIO direction as input. */
+	set_direction(gp, 0);
+
+	return 0;
+}
+
+/* set GPIO pin 'gp' as an output, with polarity 'value' */
+int gpio_direction_output(int gp, int value)
+{
+	debug("gpio_direction_output: pin = %d (port %d:bit %d) = %s\n",
+		gp, GPIO_FULLPORT(gp), GPIO_BIT(gp), value ? "HIGH" : "LOW");
+
+	/* Configure GPIO output value. */
+	set_level(gp, value);
+
+	/* Configure GPIO direction as output. */
+	set_direction(gp, 1);
+
+	return 0;
+}
+
+/* read GPIO IN value of pin 'gp' */
+int gpio_get_value(int gp)
+{
+	struct gpio_ctlr *gpio = (struct gpio_ctlr *)NV_PA_GPIO_BASE;
+	struct gpio_ctlr_bank *bank = &gpio->gpio_bank[GPIO_BANK(gp)];
+	int val;
+
+	debug("gpio_get_value: pin = %d (port %d:bit %d)\n",
+		gp, GPIO_FULLPORT(gp), GPIO_BIT(gp));
+
+	val = readl(&bank->gpio_in[GPIO_PORT(gp)]);
+
+	return (val >> GPIO_BIT(gp)) & 1;
+}
+
+/* write GPIO OUT value to pin 'gp' */
+void gpio_set_value(int gp, int value)
+{
+	debug("gpio_set_value: pin = %d (port %d:bit %d), value = %d\n",
+		gp, GPIO_FULLPORT(gp), GPIO_BIT(gp), value);
+
+	/* Configure GPIO output value. */
+	set_level(gp, value);
+}
+
+/*
+ * Display Tegra GPIO information
+ */
+void gpio_info(void)
+{
+	int c, type;
+
+	for (c = 0; c < MAX_NUM_GPIOS; c++) {
+		type = get_config(c);		/* GPIO, not SFPIO */
+		if (type) {
+			printf("GPIO_%d:\t%s is an %s, ", c,
+				get_name(c),
+				get_direction(c) ? "OUTPUT" : "INPUT");
+			if (get_direction(c))
+				printf("value = %d", gpio_get_output_value(c));
+			else
+				printf("value = %d", gpio_get_value(c));
+			printf("\n");
+		} else
+			continue;
+	}
+}
diff -urN u-boot-2011.06/drivers/hwmon/adm1021.c u-boot-HEAD/drivers/hwmon/adm1021.c
--- u-boot-2011.06/drivers/hwmon/adm1021.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/hwmon/adm1021.c	2011-09-19 23:25:08.000000000 +0200
@@ -109,8 +109,8 @@
 	return 0;
 } /* dtt_write() */
 
-static int
-_dtt_init (int sensor)
+int
+dtt_init_one(int sensor)
 {
 	dtt_cfg_t *dcp = &dttcfg[sensor >> 1];
 	int reg, val;
@@ -164,28 +164,7 @@
 		return 1;
 
 	return 0;
-} /* _dtt_init() */
-
-int
-dtt_init (void)
-{
-	int i;
-	unsigned char sensors[] = CONFIG_DTT_SENSORS;
-	const char *const header = "DTT:   ";
-
-	/* switch to correct I2C bus */
-	I2C_SET_BUS(CONFIG_SYS_DTT_BUS_NUM);
-
-	for (i = 0; i < sizeof(sensors); i++) {
-		if (_dtt_init(sensors[i]) != 0)
-			printf ("%s%d FAILED INIT\n", header, i+1);
-		else
-			printf ("%s%d is %i C\n", header, i+1,
-				dtt_get_temp(sensors[i]));
-	}
-
-	return (0);
-} /* dtt_init() */
+} /* dtt_init_one() */
 
 int
 dtt_get_temp (int sensor)
diff -urN u-boot-2011.06/drivers/hwmon/adt7460.c u-boot-HEAD/drivers/hwmon/adt7460.c
--- u-boot-2011.06/drivers/hwmon/adt7460.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/hwmon/adt7460.c	2011-09-19 23:25:08.000000000 +0200
@@ -50,7 +50,7 @@
 	return 0;
 }
 
-int dtt_init(void)
+int dtt_init_one(int sensor)
 {
 	printf("ADT7460 at I2C address 0x%2x\n", ADT7460_ADDRESS);
 
diff -urN u-boot-2011.06/drivers/hwmon/ds1621.c u-boot-HEAD/drivers/hwmon/ds1621.c
--- u-boot-2011.06/drivers/hwmon/ds1621.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/hwmon/ds1621.c	2011-09-19 23:25:08.000000000 +0200
@@ -126,7 +126,7 @@
 }
 
 
-static int _dtt_init(int sensor)
+int dtt_init_one(int sensor)
 {
 	int val;
 
@@ -155,23 +155,6 @@
 	return 0;
 }
 
-
-int dtt_init (void)
-{
-	int i;
-	unsigned char sensors[] = CONFIG_DTT_SENSORS;
-
-	for (i = 0; i < sizeof(sensors); i++) {
-		if (_dtt_init(sensors[i]) != 0)
-			printf("DTT%d:  FAILED\n", i + 1);
-		else
-			printf("DTT%d:  %i C\n", i + 1, dtt_get_temp(sensors[i]));
-	}
-
-	return (0);
-}
-
-
 int dtt_get_temp(int sensor)
 {
 	int i;
diff -urN u-boot-2011.06/drivers/hwmon/ds1775.c u-boot-HEAD/drivers/hwmon/ds1775.c
--- u-boot-2011.06/drivers/hwmon/ds1775.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/hwmon/ds1775.c	2011-09-19 23:25:08.000000000 +0200
@@ -98,7 +98,7 @@
 }
 
 
-static int _dtt_init(int sensor)
+int dtt_init_one(int sensor)
 {
 	int val;
 
@@ -133,23 +133,6 @@
 	return 0;
 }
 
-
-int dtt_init (void)
-{
-	int i;
-	unsigned char sensors[] = CONFIG_DTT_SENSORS;
-
-	for (i = 0; i < sizeof(sensors); i++) {
-		if (_dtt_init(sensors[i]) != 0)
-			printf("DTT%d:  FAILED\n", i+1);
-		else
-			printf("DTT%d:  %i C\n", i+1, dtt_get_temp(sensors[i]));
-	}
-
-	return (0);
-}
-
-
 int dtt_get_temp(int sensor)
 {
 	return (dtt_read(sensor, DTT_READ_TEMP) / 256);
diff -urN u-boot-2011.06/drivers/hwmon/lm63.c u-boot-HEAD/drivers/hwmon/lm63.c
--- u-boot-2011.06/drivers/hwmon/lm63.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/hwmon/lm63.c	2011-09-19 23:25:08.000000000 +0200
@@ -101,7 +101,7 @@
 	return sensor && (sensor != DTT_I2C_LM63_ADDR);
 }
 
-static int _dtt_init(int sensor)
+int dtt_init_one(int sensor)
 {
 	int i;
 	int val;
@@ -175,20 +175,3 @@
 	/* Ignore LSB for now, U-Boot only prints natural numbers */
 	return temp >> 8;
 }
-
-int dtt_init(void)
-{
-	int i;
-	unsigned char sensors[] = CONFIG_DTT_SENSORS;
-	const char *const header = "DTT:   ";
-
-	for (i = 0; i < sizeof(sensors); i++) {
-		if (_dtt_init(sensors[i]) != 0)
-			printf("%s%d FAILED INIT\n", header, i + 1);
-		else
-			printf("%s%d is %i C\n", header, i + 1,
-			       dtt_get_temp(sensors[i]));
-	}
-
-	return 0;
-}
diff -urN u-boot-2011.06/drivers/hwmon/lm73.c u-boot-HEAD/drivers/hwmon/lm73.c
--- u-boot-2011.06/drivers/hwmon/lm73.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/hwmon/lm73.c	2011-09-19 23:25:08.000000000 +0200
@@ -112,7 +112,7 @@
 			      dlen);
 } /* dtt_write() */
 
-static int _dtt_init(int const sensor)
+int dtt_init_one(int const sensor)
 {
 	int val;
 
@@ -148,23 +148,7 @@
 
 	dtt_read(sensor, DTT_CONTROL);	/* clear temperature flags */
 	return 0;
-} /* _dtt_init() */
-
-int dtt_init(void)
-{
-	int i;
-	unsigned char sensors[] = CONFIG_DTT_SENSORS;
-	const char *const header = "DTT:   ";
-
-	for (i = 0; i < sizeof(sensors); i++) {
-		if (0 != _dtt_init(sensors[i]))
-			printf("%s%d FAILED INIT\n", header, i + 1);
-		else
-			printf("%s%d is %i C\n", header, i + 1,
-			       dtt_get_temp(sensors[i]));
-	}
-	return 0;
-} /* dtt_init() */
+} /* dtt_init_one() */
 
 int dtt_get_temp(int const sensor)
 {
diff -urN u-boot-2011.06/drivers/hwmon/lm75.c u-boot-HEAD/drivers/hwmon/lm75.c
--- u-boot-2011.06/drivers/hwmon/lm75.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/hwmon/lm75.c	2011-09-19 23:25:08.000000000 +0200
@@ -119,7 +119,7 @@
 } /* dtt_write() */
 
 
-static int _dtt_init(int sensor)
+int dtt_init_one(int sensor)
 {
 	int val;
 
@@ -145,32 +145,7 @@
 		return 1;
 
 	return 0;
-} /* _dtt_init() */
-
-
-int dtt_init (void)
-{
-	int i;
-	unsigned char sensors[] = CONFIG_DTT_SENSORS;
-	const char *const header = "DTT:   ";
-	int old_bus;
-
-	/* switch to correct I2C bus */
-	old_bus = I2C_GET_BUS();
-	I2C_SET_BUS(CONFIG_SYS_DTT_BUS_NUM);
-
-	for (i = 0; i < sizeof(sensors); i++) {
-	if (_dtt_init(sensors[i]) != 0)
-		printf("%s%d FAILED INIT\n", header, i+1);
-	else
-		printf("%s%d is %i C\n", header, i+1,
-		dtt_get_temp(sensors[i]));
-	}
-	/* switch back to original I2C bus */
-	I2C_SET_BUS(old_bus);
-
-	return (0);
-} /* dtt_init() */
+} /* dtt_init_one() */
 
 int dtt_get_temp(int sensor)
 {
diff -urN u-boot-2011.06/drivers/hwmon/lm81.c u-boot-HEAD/drivers/hwmon/lm81.c
--- u-boot-2011.06/drivers/hwmon/lm81.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/hwmon/lm81.c	2011-09-19 23:25:08.000000000 +0200
@@ -89,7 +89,7 @@
 #define DTT_CONFIG	0x40
 #define DTT_ADR		0x48
 
-static int _dtt_init(int sensor)
+int dtt_init_one(int sensor)
 {
 	int	man;
 	int	adr;
@@ -111,26 +111,9 @@
 
 	debug ("DTT:   Found LM81@%x Rev: %d\n", adr, rev);
 	return 0;
-} /* _dtt_init() */
+} /* dtt_init_one() */
 
 
-int dtt_init (void)
-{
-    int i;
-    unsigned char sensors[] = CONFIG_DTT_SENSORS;
-    const char *const header = "DTT:   ";
-
-    for (i = 0; i < sizeof(sensors); i++) {
-	if (_dtt_init(sensors[i]) != 0)
-	    printf("%s%d FAILED INIT\n", header, i+1);
-	else
-	    printf("%s%d is %i C\n", header, i+1,
-		   dtt_get_temp(sensors[i]));
-    }
-
-    return (0);
-} /* dtt_init() */
-
 #define TEMP_FROM_REG(temp) \
    ((temp)<256?((((temp)&0x1fe) >> 1) * 10)	 + ((temp) & 1) * 5:  \
 	       ((((temp)&0x1fe) >> 1) -255) * 10 - ((temp) & 1) * 5)  \
diff -urN u-boot-2011.06/drivers/i2c/mxc_i2c.c u-boot-HEAD/drivers/i2c/mxc_i2c.c
--- u-boot-2011.06/drivers/i2c/mxc_i2c.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/i2c/mxc_i2c.c	2011-09-19 23:25:08.000000000 +0200
@@ -89,14 +89,11 @@
 #if defined(CONFIG_MX31)
 	struct clock_control_regs *sc_regs =
 		(struct clock_control_regs *)CCM_BASE;
-
-	freq = mx31_get_ipg_clk();
 	/* start the required I2C clock */
 	writel(readl(&sc_regs->cgr0) | (3 << I2C_CLK_OFFSET),
 		&sc_regs->cgr0);
-#else
-	freq = mxc_get_clock(MXC_IPG_PERCLK);
 #endif
+	freq = mxc_get_clock(MXC_IPG_PERCLK);
 
 	for (i = 0; i < 0x1f; i++)
 		if (freq / div[i] <= speed)
diff -urN u-boot-2011.06/drivers/i2c/omap24xx_i2c.c u-boot-HEAD/drivers/i2c/omap24xx_i2c.c
--- u-boot-2011.06/drivers/i2c/omap24xx_i2c.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/i2c/omap24xx_i2c.c	2011-09-19 23:25:08.000000000 +0200
@@ -31,8 +31,8 @@
 
 #define I2C_TIMEOUT	1000
 
-static void wait_for_bb (void);
-static u16 wait_for_pin (void);
+static void wait_for_bb(void);
+static u16 wait_for_pin(void);
 static void flush_fifo(void);
 
 static struct i2c *i2c_base = (struct i2c *)I2C_DEFAULT_BASE;
@@ -40,7 +40,7 @@
 static unsigned int bus_initialized[I2C_BUS_MAX];
 static unsigned int current_bus;
 
-void i2c_init (int speed, int slaveadd)
+void i2c_init(int speed, int slaveadd)
 {
 	int psc, fsscll, fssclh;
 	int hsscll = 0, hssclh = 0;
@@ -107,9 +107,9 @@
 		sclh = (unsigned int)fssclh;
 	}
 
-	if (readw (&i2c_base->con) & I2C_CON_EN) {
-		writew (0, &i2c_base->con);
-		udelay (50000);
+	if (readw(&i2c_base->con) & I2C_CON_EN) {
+		writew(0, &i2c_base->con);
+		udelay(50000);
 	}
 
 	writew(0x2, &i2c_base->sysc); /* for ES2 after soft reset */
@@ -130,35 +130,36 @@
 	writew(sclh, &i2c_base->sclh);
 
 	/* own address */
-	writew (slaveadd, &i2c_base->oa);
-	writew (I2C_CON_EN, &i2c_base->con);
+	writew(slaveadd, &i2c_base->oa);
+	writew(I2C_CON_EN, &i2c_base->con);
 
 	/* have to enable intrrupts or OMAP i2c module doesn't work */
-	writew (I2C_IE_XRDY_IE | I2C_IE_RRDY_IE | I2C_IE_ARDY_IE |
+	writew(I2C_IE_XRDY_IE | I2C_IE_RRDY_IE | I2C_IE_ARDY_IE |
 		I2C_IE_NACK_IE | I2C_IE_AL_IE, &i2c_base->ie);
-	udelay (1000);
+	udelay(1000);
 	flush_fifo();
-	writew (0xFFFF, &i2c_base->stat);
-	writew (0, &i2c_base->cnt);
+	writew(0xFFFF, &i2c_base->stat);
+	writew(0, &i2c_base->cnt);
 
 	if (gd->flags & GD_FLG_RELOC)
 		bus_initialized[current_bus] = 1;
 }
 
-static int i2c_read_byte (u8 devaddr, u8 regoffset, u8 * value)
+static int i2c_read_byte(u8 devaddr, u8 regoffset, u8 *value)
 {
 	int i2c_error = 0;
 	u16 status;
 
 	/* wait until bus not busy */
-	wait_for_bb ();
+	wait_for_bb();
 
 	/* one byte only */
-	writew (1, &i2c_base->cnt);
+	writew(1, &i2c_base->cnt);
 	/* set slave address */
-	writew (devaddr, &i2c_base->sa);
+	writew(devaddr, &i2c_base->sa);
 	/* no stop bit needed here */
-	writew (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_TRX, &i2c_base->con);
+	writew(I2C_CON_EN | I2C_CON_MST | I2C_CON_STT |
+	      I2C_CON_TRX, &i2c_base->con);
 
 	/* send register offset */
 	while (1) {
@@ -196,7 +197,7 @@
 		}
 		if (status & I2C_STAT_RRDY) {
 #if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX) || \
-    defined(CONFIG_OMAP44XX)
+	defined(CONFIG_OMAP44XX)
 			*value = readb(&i2c_base->data);
 #else
 			*value = readw(&i2c_base->data);
@@ -211,79 +212,8 @@
 
 read_exit:
 	flush_fifo();
-	writew (0xFFFF, &i2c_base->stat);
-	writew (0, &i2c_base->cnt);
-	return i2c_error;
-}
-
-static int i2c_write_byte (u8 devaddr, u8 regoffset, u8 value)
-{
-	int i2c_error = 0;
-	u16 status;
-
-	/* wait until bus not busy */
-	wait_for_bb ();
-
-	/* two bytes */
-	writew (2, &i2c_base->cnt);
-	/* set slave address */
-	writew (devaddr, &i2c_base->sa);
-	/* stop bit needed here */
-	writew (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_TRX |
-		I2C_CON_STP, &i2c_base->con);
-
-	while (1) {
-		status = wait_for_pin();
-		if (status == 0 || status & I2C_STAT_NACK) {
-			i2c_error = 1;
-			goto write_exit;
-		}
-		if (status & I2C_STAT_XRDY) {
-#if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX) || \
-    defined(CONFIG_OMAP44XX)
-			/* send register offset */
-			writeb(regoffset, &i2c_base->data);
-			writew(I2C_STAT_XRDY, &i2c_base->stat);
-
-			while (1) {
-				status = wait_for_pin();
-				if (status == 0 || status & I2C_STAT_NACK) {
-					i2c_error = 1;
-					goto write_exit;
-				}
-				if (status & I2C_STAT_XRDY) {
-					/* send data */
-					writeb(value, &i2c_base->data);
-					writew(I2C_STAT_XRDY, &i2c_base->stat);
-				}
-				if (status & I2C_STAT_ARDY) {
-					writew(I2C_STAT_ARDY, &i2c_base->stat);
-					break;
-				}
-			}
-			break;
-#else
-			/* send out two bytes */
-			writew((value << 8) + regoffset, &i2c_base->data);
-			writew(I2C_STAT_XRDY, &i2c_base->stat);
-#endif
-		}
-		if (status & I2C_STAT_ARDY) {
-			writew(I2C_STAT_ARDY, &i2c_base->stat);
-			break;
-		}
-	}
-
-	wait_for_bb();
-
-	status = readw(&i2c_base->stat);
-	if (status & I2C_STAT_NACK)
-		i2c_error = 1;
-
-write_exit:
-	flush_fifo();
-	writew (0xFFFF, &i2c_base->stat);
-	writew (0, &i2c_base->cnt);
+	writew(0xFFFF, &i2c_base->stat);
+	writew(0, &i2c_base->cnt);
 	return i2c_error;
 }
 
@@ -293,38 +223,37 @@
 	/* note: if you try and read data when its not there or ready
 	 * you get a bus error
 	 */
-	while(1){
+	while (1) {
 		stat = readw(&i2c_base->stat);
-		if(stat == I2C_STAT_RRDY){
+		if (stat == I2C_STAT_RRDY) {
 #if defined(CONFIG_OMAP243X) || defined(CONFIG_OMAP34XX) || \
-    defined(CONFIG_OMAP44XX)
+	defined(CONFIG_OMAP44XX)
 			readb(&i2c_base->data);
 #else
 			readw(&i2c_base->data);
 #endif
-			writew(I2C_STAT_RRDY,&i2c_base->stat);
+			writew(I2C_STAT_RRDY, &i2c_base->stat);
 			udelay(1000);
-		}else
+		} else
 			break;
 	}
 }
 
-int i2c_probe (uchar chip)
+int i2c_probe(uchar chip)
 {
 	u16 status;
 	int res = 1; /* default = fail */
 
-	if (chip == readw (&i2c_base->oa)) {
+	if (chip == readw(&i2c_base->oa))
 		return res;
-	}
 
 	/* wait until bus not busy */
-	wait_for_bb ();
+	wait_for_bb();
 
 	/* try to write one byte */
-	writew (1, &i2c_base->cnt);
+	writew(1, &i2c_base->cnt);
 	/* set slave address */
-	writew (chip, &i2c_base->sa);
+	writew(chip, &i2c_base->sa);
 	/* stop bit needed here */
 	writew(I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_TRX |
 	       I2C_CON_STP, &i2c_base->con);
@@ -339,29 +268,30 @@
 	writew(0, &i2c_base->con);
 
 	flush_fifo();
-	writew (0, &i2c_base->cnt); /* don't allow any more data in...we don't want it.*/
+	/* don't allow any more data in... we don't want it. */
+	writew(0, &i2c_base->cnt);
 	writew(0xFFFF, &i2c_base->stat);
 	return res;
 }
 
-int i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
+int i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
 {
 	int i;
 
 	if (alen > 1) {
-		printf ("I2C read: addr len %d not supported\n", alen);
+		printf("I2C read: addr len %d not supported\n", alen);
 		return 1;
 	}
 
 	if (addr + len > 256) {
-		printf ("I2C read: address out of range\n");
+		printf("I2C read: address out of range\n");
 		return 1;
 	}
 
 	for (i = 0; i < len; i++) {
-		if (i2c_read_byte (chip, addr + i, &buffer[i])) {
-			printf ("I2C read: I/O error\n");
-			i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+		if (i2c_read_byte(chip, addr + i, &buffer[i])) {
+			printf("I2C read: I/O error\n");
+			i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
 			return 1;
 		}
 	}
@@ -369,65 +299,116 @@
 	return 0;
 }
 
-int i2c_write (uchar chip, uint addr, int alen, uchar * buffer, int len)
+int i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
 {
 	int i;
+	u16 status;
+	int i2c_error = 0;
 
 	if (alen > 1) {
-		printf ("I2C read: addr len %d not supported\n", alen);
+		printf("I2C write: addr len %d not supported\n", alen);
 		return 1;
 	}
 
 	if (addr + len > 256) {
-		printf ("I2C read: address out of range\n");
+		printf("I2C write: address 0x%x + 0x%x out of range\n",
+				addr, len);
 		return 1;
 	}
 
+	/* wait until bus not busy */
+	wait_for_bb();
+
+	/* start address phase - will write regoffset + len bytes data */
+	/* TODO consider case when !CONFIG_OMAP243X/34XX/44XX */
+	writew(alen + len, &i2c_base->cnt);
+	/* set slave address */
+	writew(chip, &i2c_base->sa);
+	/* stop bit needed here */
+	writew(I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_TRX |
+		I2C_CON_STP, &i2c_base->con);
+
+	/* Send address byte */
+	status = wait_for_pin();
+
+	if (status == 0 || status & I2C_STAT_NACK) {
+		i2c_error = 1;
+		printf("error waiting for i2c address ACK (status=0x%x)\n",
+		      status);
+		goto write_exit;
+	}
+
+	if (status & I2C_STAT_XRDY) {
+		writeb(addr & 0xFF, &i2c_base->data);
+		writew(I2C_STAT_XRDY, &i2c_base->stat);
+	} else {
+		i2c_error = 1;
+		printf("i2c bus not ready for transmit (status=0x%x)\n",
+		      status);
+		goto write_exit;
+	}
+
+	/* address phase is over, now write data */
 	for (i = 0; i < len; i++) {
-		if (i2c_write_byte (chip, addr + i, buffer[i])) {
-			printf ("I2C read: I/O error\n");
-			i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
-			return 1;
+		status = wait_for_pin();
+
+		if (status == 0 || status & I2C_STAT_NACK) {
+			i2c_error = 1;
+			printf("i2c error waiting for data ACK (status=0x%x)\n",
+					status);
+			goto write_exit;
+		}
+
+		if (status & I2C_STAT_XRDY) {
+			writeb(buffer[i], &i2c_base->data);
+			writew(I2C_STAT_XRDY, &i2c_base->stat);
+		} else {
+			i2c_error = 1;
+			printf("i2c bus not ready for Tx (i=%d)\n", i);
+			goto write_exit;
 		}
 	}
 
-	return 0;
+write_exit:
+	flush_fifo();
+	writew(0xFFFF, &i2c_base->stat);
+	return i2c_error;
 }
 
-static void wait_for_bb (void)
+static void wait_for_bb(void)
 {
 	int timeout = I2C_TIMEOUT;
 	u16 stat;
 
-	writew(0xFFFF, &i2c_base->stat);	 /* clear current interruts...*/
-	while ((stat = readw (&i2c_base->stat) & I2C_STAT_BB) && timeout--) {
-		writew (stat, &i2c_base->stat);
+	writew(0xFFFF, &i2c_base->stat);	/* clear current interrupts...*/
+	while ((stat = readw(&i2c_base->stat) & I2C_STAT_BB) && timeout--) {
+		writew(stat, &i2c_base->stat);
 		udelay(1000);
 	}
 
 	if (timeout <= 0) {
-		printf ("timed out in wait_for_bb: I2C_STAT=%x\n",
-			readw (&i2c_base->stat));
+		printf("timed out in wait_for_bb: I2C_STAT=%x\n",
+			readw(&i2c_base->stat));
 	}
 	writew(0xFFFF, &i2c_base->stat);	 /* clear delayed stuff*/
 }
 
-static u16 wait_for_pin (void)
+static u16 wait_for_pin(void)
 {
 	u16 status;
 	int timeout = I2C_TIMEOUT;
 
 	do {
-		udelay (1000);
-		status = readw (&i2c_base->stat);
-	} while (  !(status &
+		udelay(1000);
+		status = readw(&i2c_base->stat);
+	} while (!(status &
 		   (I2C_STAT_ROVR | I2C_STAT_XUDF | I2C_STAT_XRDY |
 		    I2C_STAT_RRDY | I2C_STAT_ARDY | I2C_STAT_NACK |
 		    I2C_STAT_AL)) && timeout--);
 
 	if (timeout <= 0) {
-		printf ("timed out in wait_for_pin: I2C_STAT=%x\n",
-			readw (&i2c_base->stat));
+		printf("timed out in wait_for_pin: I2C_STAT=%x\n",
+			readw(&i2c_base->stat));
 		writew(0xFFFF, &i2c_base->stat);
 		status = 0;
 	}
@@ -442,7 +423,7 @@
 		return -1;
 	}
 
-#if I2C_BUS_MAX==3
+#if I2C_BUS_MAX == 3
 	if (bus == 2)
 		i2c_base = (struct i2c *)I2C_BASE3;
 	else
@@ -454,7 +435,7 @@
 
 	current_bus = bus;
 
-	if(!bus_initialized[current_bus])
+	if (!bus_initialized[current_bus])
 		i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
 
 	return 0;
diff -urN u-boot-2011.06/drivers/misc/ali512x.c u-boot-HEAD/drivers/misc/ali512x.c
--- u-boot-2011.06/drivers/misc/ali512x.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/misc/ali512x.c	2011-09-19 23:25:08.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * Daniel Engström, Omicron Ceti AB <daniel@omicron.se>.
+ * Daniel EngstrÃ¶m, Omicron Ceti AB <daniel@omicron.se>.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
diff -urN u-boot-2011.06/drivers/mmc/ftsdc010_esdhc.c u-boot-HEAD/drivers/mmc/ftsdc010_esdhc.c
--- u-boot-2011.06/drivers/mmc/ftsdc010_esdhc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/mmc/ftsdc010_esdhc.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,667 @@
+/*
+ * Copyright (C) 2011 Andes Technology Corporation
+ * Macpaul Lin, Andes Technology Corporation <macpaul@andestech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+
+#include <asm/io.h>
+#include <faraday/ftsdc010.h>
+
+/*
+ * supported mmc hosts
+ * setting the number CONFIG_FTSDC010_NUMBER in your configuration file.
+ */
+static struct mmc ftsdc010_dev[CONFIG_FTSDC010_NUMBER];
+static struct mmc_host ftsdc010_host[CONFIG_FTSDC010_NUMBER];
+
+static struct ftsdc010_mmc *ftsdc010_get_base_mmc(int dev_index)
+{
+	return (struct ftsdc010_mmc *)CONFIG_FTSDC010_BASE + dev_index;
+}
+
+#ifdef DEBUG
+static void ftsdc010_dump_reg(struct mmc_host *host)
+{
+	debug("cmd: %08x\n",		readl(&host->reg->cmd));
+	debug("argu: %08x\n",		readl(&host->reg->argu));
+	debug("rsp0: %08x\n",		readl(&host->reg->rsp0));
+	debug("rsp1: %08x\n",		readl(&host->reg->rsp1));
+	debug("rsp2: %08x\n",		readl(&host->reg->rsp2));
+	debug("rsp3: %08x\n",		readl(&host->reg->rsp3));
+	debug("rsp_cmd: %08x\n",	readl(&host->reg->rsp_cmd));
+	debug("dcr: %08x\n",		readl(&host->reg->dcr));
+	debug("dtr: %08x\n",		readl(&host->reg->dtr));
+	debug("dlr: %08x\n",		readl(&host->reg->dlr));
+	debug("status: %08x\n",		readl(&host->reg->status));
+	debug("clr: %08x\n",		readl(&host->reg->clr));
+	debug("int_mask: %08x\n",	readl(&host->reg->int_mask));
+	debug("pcr: %08x\n",		readl(&host->reg->pcr));
+	debug("ccr: %08x\n",		readl(&host->reg->ccr));
+	debug("bwr: %08x\n",		readl(&host->reg->bwr));
+	debug("dwr: %08x\n",		readl(&host->reg->dwr));
+	debug("feature: %08x\n",	readl(&host->reg->feature));
+	debug("rev: %08x\n",		readl(&host->reg->rev));
+}
+#endif
+
+static unsigned int enable_imask(struct ftsdc010_mmc *reg, unsigned int imask)
+{
+	unsigned int newmask;
+
+	newmask = readl(&reg->int_mask);
+	newmask |= imask;
+
+	writel(newmask, &reg->int_mask);
+
+	return newmask;
+}
+
+static void ftsdc010_pio_read(struct mmc_host *host, char *buf, unsigned int size)
+{
+	unsigned int fifo;
+	unsigned int fifo_words;
+	unsigned int *ptr;
+	unsigned int status;
+	unsigned int retry = 0;
+
+	/* get_data_buffer */
+	ptr = (unsigned int *)buf;
+
+	while (size) {
+		status = readl(&host->reg->status);
+
+		if (status & FTSDC010_STATUS_FIFO_ORUN) {
+			fifo = host->fifo_len > size ?
+				size : host->fifo_len;
+
+			size -= fifo;
+
+			fifo_words = fifo >> 2;
+
+			while (fifo_words--)
+				*ptr++ = readl(&host->reg->dwr);
+
+			/*
+			 * for adding some delays for SD card to put
+			 * data into FIFO again
+			 */
+			udelay(4*FTSDC010_DELAY_UNIT);
+
+#ifdef CONFIG_FTSDC010_SDIO
+			/* sdio allow non-power-of-2 blksz */
+			if (fifo & 3) {
+				unsigned int n = fifo & 3;
+				unsigned int data = readl(&host->reg->dwr);
+
+				unsigned char *p = (unsigned char *)ptr;
+
+				while (n--) {
+					*p++ = data;
+					data >>= 8;
+				}
+			}
+#endif
+		} else {
+			udelay(1);
+			if (++retry >= FTSDC010_PIO_RETRY) {
+				debug("%s: PIO_RETRY timeout\n", __func__);
+				return;
+			}
+		}
+	}
+}
+
+static void ftsdc010_pio_write(struct mmc_host *host, const char *buf,
+			unsigned int size)
+{
+	unsigned int fifo;
+	unsigned int *ptr;
+	unsigned int status;
+	unsigned int retry = 0;
+
+	/* get data buffer */
+	ptr = (unsigned int *)buf;
+
+	while (size) {
+		status = readl(&host->reg->status);
+
+		if (status & FTSDC010_STATUS_FIFO_ORUN) {
+			fifo = host->fifo_len > size ?
+				size : host->fifo_len;
+
+			size -= fifo;
+
+			fifo = (fifo + 3) >> 2;
+
+			while (fifo--) {
+				writel(*ptr, &host->reg->dwr);
+				ptr++;
+			}
+
+		} else {
+			udelay(1);
+			if (++retry >= FTSDC010_PIO_RETRY) {
+				debug("%s: PIO_RETRY timeout\n", __func__);
+				return;
+			}
+		}
+	}
+}
+
+static int ftsdc010_pio_check_status(struct mmc *mmc, struct mmc_cmd *cmd,
+			struct mmc_data *data)
+{
+	struct mmc_host *host = mmc->priv;
+
+	unsigned int sta, clear;
+	unsigned int i;
+
+	/* check response and hardware status */
+	clear = 0;
+
+	/* chech CMD_SEND */
+	for (i = 0; i < FTSDC010_CMD_RETRY; i++) {
+		sta = readl(&host->reg->status);
+		/* Command Complete */
+		if (sta & FTSDC010_STATUS_CMD_SEND) {
+			if (!data)
+				clear |= FTSDC010_CLR_CMD_SEND;
+			break;
+		}
+	}
+
+	if (i > FTSDC010_CMD_RETRY) {
+		printf("%s: send command timeout\n", __func__);
+		return TIMEOUT;
+	}
+
+	/* debug: print status register and command index*/
+	debug("sta: %08x cmd %d\n", sta, cmd->cmdidx);
+
+	/* handle data FIFO */
+	if ((sta & FTSDC010_STATUS_FIFO_ORUN) ||
+		(sta & FTSDC010_STATUS_FIFO_URUN)) {
+
+		/* Wrong DATA FIFO Flag */
+		if (data == NULL)
+			printf("%s, data fifo wrong: sta: %08x cmd %d\n",
+				__func__, sta, cmd->cmdidx);
+
+		if (sta & FTSDC010_STATUS_FIFO_ORUN)
+			clear |= FTSDC010_STATUS_FIFO_ORUN;
+		if (sta & FTSDC010_STATUS_FIFO_URUN)
+			clear |= FTSDC010_STATUS_FIFO_URUN;
+	}
+
+	/* check RSP TIMEOUT or FAIL */
+	if (sta & FTSDC010_STATUS_RSP_TIMEOUT) {
+		/* RSP TIMEOUT */
+		debug("%s: RSP timeout: sta: %08x cmd %d\n",
+				__func__, sta, cmd->cmdidx);
+
+		clear |= FTSDC010_CLR_RSP_TIMEOUT;
+		writel(clear, &host->reg->clr);
+
+		return TIMEOUT;
+	} else if (sta & FTSDC010_STATUS_RSP_CRC_FAIL) {
+		/* clear response fail bit */
+		debug("%s: RSP CRC FAIL: sta: %08x cmd %d\n",
+				__func__, sta, cmd->cmdidx);
+
+		clear |= FTSDC010_CLR_RSP_CRC_FAIL;
+		writel(clear, &host->reg->clr);
+
+		return 0;
+	} else if (sta & FTSDC010_STATUS_RSP_CRC_OK) {
+
+		/* clear response CRC OK bit */
+		clear |= FTSDC010_CLR_RSP_CRC_OK;
+	}
+
+	/* check DATA TIMEOUT or FAIL */
+	if (data) {
+		if (sta & FTSDC010_STATUS_DATA_TIMEOUT) {
+			/* DATA TIMEOUT */
+			debug("%s: DATA TIMEOUT: sta: %08x\n",
+					__func__, sta);
+
+			clear |= FTSDC010_STATUS_DATA_TIMEOUT;
+			writel(sta, &host->reg->clr);
+			return TIMEOUT;
+		} else if (sta & FTSDC010_STATUS_DATA_CRC_FAIL) {
+			/* Error Interrupt */
+			debug("%s: DATA CRC FAIL: sta: %08x\n",
+					__func__, sta);
+
+			clear |= FTSDC010_STATUS_DATA_CRC_FAIL;
+			writel(clear, &host->reg->clr);
+
+			return 0;
+		} else if (sta & FTSDC010_STATUS_DATA_END) {
+			/* Transfer Complete */
+			clear |= FTSDC010_STATUS_DATA_END;
+		}
+	}
+
+	/* transaction is success and clear status register */
+	writel(clear, &host->reg->clr);
+
+	return 0;
+}
+
+static int ftsdc010_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
+			struct mmc_data *data)
+{
+	struct mmc_host *host = mmc->priv;
+
+#ifdef CONFIG_FTSDC010_SDIO
+	unsigned int scon;
+#endif
+	unsigned int ccon;
+	unsigned int mask, tmpmask;
+	unsigned int ret;
+
+	if (data)
+		mask = FTSDC010_INT_MASK_RSP_TIMEOUT;
+	else if (cmd->resp_type & MMC_RSP_PRESENT)
+		mask = FTSDC010_INT_MASK_RSP_TIMEOUT;
+	else
+		mask = FTSDC010_INT_MASK_CMD_SEND;
+
+	/* write argu reg */
+	debug("%s: cmd->arg: %08x\n", __func__, cmd->cmdarg);
+	writel(cmd->cmdarg, &host->reg->argu);
+
+	/* setup cmd reg */
+	debug("cmd: %d\n", cmd->cmdidx);
+	debug("resp: %08x\n", cmd->resp_type);
+
+	/* setup commnad */
+	ccon = FTSDC010_CMD_IDX(cmd->cmdidx);
+
+	/* setup command flags */
+	ccon |= FTSDC010_CMD_CMD_EN;
+
+	/*
+	 * This hardware didn't support specific commands for mapping
+	 * MMC_RSP_BUSY and MMC_RSP_OPCODE. Hence we don't deal with it.
+	 */
+	if (cmd->resp_type & MMC_RSP_PRESENT) {
+		ccon |= FTSDC010_CMD_NEED_RSP;
+		mask |= FTSDC010_INT_MASK_RSP_CRC_OK |
+			FTSDC010_INT_MASK_RSP_CRC_FAIL;
+	}
+
+	if (cmd->resp_type & MMC_RSP_136)
+		ccon |= FTSDC010_CMD_LONG_RSP;
+
+	/* In Linux driver, MMC_CMD_APP_CMD is checked in last_opcode */
+	if (host->last_opcode == MMC_CMD_APP_CMD)
+		ccon |= FTSDC010_CMD_APP_CMD;
+
+#ifdef CONFIG_FTSDC010_SDIO
+	scon = readl(&host->reg->sdio_ctrl1);
+	if (host->card_type == MMC_TYPE_SDIO)
+		scon |= FTSDC010_SDIO_CTRL1_SDIO_ENABLE;
+	else
+		scon &= ~FTSDC010_SDIO_CTRL1_SDIO_ENABLE;
+	writel(scon, &host->reg->sdio_ctrl1);
+#endif
+
+	/* record last opcode for specifing the command type to hardware */
+	host->last_opcode = cmd->cmdidx;
+
+	/* write int_mask reg */
+	tmpmask = readl(&host->reg->int_mask);
+	tmpmask |= mask;
+	writel(tmpmask, &host->reg->int_mask);
+
+	/* write cmd reg */
+	debug("%s: ccon: %08x\n", __func__, ccon);
+	writel(ccon, &host->reg->cmd);
+	udelay(4*FTSDC010_DELAY_UNIT);
+
+	/* read/write data */
+	if (data && (data->flags & MMC_DATA_READ)) {
+		ftsdc010_pio_read(host, data->dest,
+				data->blocksize * data->blocks);
+	} else if (data && (data->flags & MMC_DATA_WRITE)) {
+		ftsdc010_pio_write(host, data->src,
+				data->blocksize * data->blocks);
+	}
+
+	/* pio check response status */
+	ret = ftsdc010_pio_check_status(mmc, cmd, data);
+	if (!ret) {
+		/* if it is long response */
+		if (ccon & FTSDC010_CMD_LONG_RSP) {
+			cmd->response[0] = readl(&host->reg->rsp3);
+			cmd->response[1] = readl(&host->reg->rsp2);
+			cmd->response[2] = readl(&host->reg->rsp1);
+			cmd->response[3] = readl(&host->reg->rsp0);
+
+		} else {
+			cmd->response[0] = readl(&host->reg->rsp0);
+		}
+	}
+
+	udelay(FTSDC010_DELAY_UNIT);
+	return ret;
+}
+
+static unsigned int cal_blksz(unsigned int blksz)
+{
+	unsigned int blksztwo = 0;
+
+	while (blksz >>= 1)
+		blksztwo++;
+
+	return blksztwo;
+}
+
+static int ftsdc010_setup_data(struct mmc *mmc, struct mmc_data *data)
+{
+	struct mmc_host *host = mmc->priv;
+	unsigned int dcon, newmask;
+
+	/* configure data transfer paramter */
+	if (!data)
+		return 0;
+
+	if (((data->blocksize - 1) & data->blocksize) != 0) {
+		printf("%s: can't do non-power-of 2 sized block transfers"
+			" (blksz %d)\n", __func__, data->blocksize);
+		return -1;
+	}
+
+	/*
+	 * We cannot deal with unaligned blocks with more than
+	 * one block being transfered.
+	 */
+	if ((data->blocksize <= 2) && (data->blocks > 1)) {
+			printf("%s: can't do non-word sized block transfers"
+				" (blksz %d)\n", __func__, data->blocksize);
+			return -1;
+	}
+
+	/* data length */
+	dcon = data->blocksize * data->blocks;
+	writel(dcon, &host->reg->dlr);
+
+	/* write data control */
+	dcon = cal_blksz(data->blocksize);
+
+	/* add to IMASK register */
+	newmask = (FTSDC010_STATUS_RSP_CRC_FAIL | FTSDC010_STATUS_DATA_TIMEOUT);
+
+	/*
+	 * enable UNDERRUN will trigger interrupt immediatedly
+	 * So setup it when rsp is received successfully
+	 */
+	if (data->flags & MMC_DATA_WRITE) {
+		dcon |= FTSDC010_DCR_DATA_WRITE;
+	} else {
+		dcon &= ~FTSDC010_DCR_DATA_WRITE;
+		newmask |= FTSDC010_STATUS_FIFO_ORUN;
+	}
+	enable_imask(host->reg, newmask);
+
+#ifdef CONFIG_FTSDC010_SDIO
+	/* always reset fifo since last transfer may fail */
+	dcon |= FTSDC010_DCR_FIFO_RST;
+
+	/* handle sdio */
+	dcon = data->blocksize | data->blocks << 15;
+	if (data->blocks > 1)
+		dcon |= FTSDC010_SDIO_CTRL1_SDIO_BLK_MODE;
+#endif
+
+	/* enable data transfer which will be pended until cmd is send */
+	dcon |= FTSDC010_DCR_DATA_EN;
+	writel(dcon, &host->reg->dcr);
+
+	return 0;
+}
+
+static int ftsdc010_send_request(struct mmc *mmc, struct mmc_cmd *cmd,
+			struct mmc_data *data)
+{
+	int ret;
+
+	if (data) {
+		ret = ftsdc010_setup_data(mmc, data);
+
+		if (ret) {
+			printf("%s: setup data error\n", __func__);
+			return -1;
+		}
+
+		if ((data->flags & MMC_DATA_BOTH_DIR) == MMC_DATA_BOTH_DIR) {
+			printf("%s: data is both direction\n", __func__);
+			return -1;
+		}
+	}
+
+	/* Send command */
+	ret = ftsdc010_send_cmd(mmc, cmd, data);
+	return ret;
+}
+
+static int ftsdc010_card_detect(struct mmc *mmc)
+{
+	struct mmc_host *host = mmc->priv;
+	unsigned int sta;
+
+	sta = readl(&host->reg->status);
+	debug("%s: card status: %08x\n", __func__, sta);
+
+	return (sta & FTSDC010_STATUS_CARD_DETECT) ? 0 : 1;
+}
+
+static int ftsdc010_request(struct mmc *mmc, struct mmc_cmd *cmd,
+			struct mmc_data *data)
+{
+	int ret;
+
+	if (ftsdc010_card_detect(mmc) == 0) {
+		printf("%s: no medium present\n", __func__);
+		return -1;
+	} else {
+		ret = ftsdc010_send_request(mmc, cmd, data);
+		return ret;
+	}
+}
+
+static void ftsdc010_set_clk(struct mmc *mmc)
+{
+	struct mmc_host *host = mmc->priv;
+	unsigned char clk_div;
+	unsigned char real_rate;
+	unsigned int clock;
+
+	debug("%s: mmc_set_clock: %x\n", __func__, mmc->clock);
+	clock = readl(&host->reg->ccr);
+
+	if (mmc->clock == 0) {
+		real_rate = 0;
+		clock |= FTSDC010_CCR_CLK_DIS;
+	} else {
+		debug("%s, mmc->clock: %08x, origin clock: %08x\n",
+			 __func__, mmc->clock, clock);
+
+		for (clk_div = 0; clk_div <= 127; clk_div++) {
+			real_rate = (CONFIG_SYS_CLK_FREQ / 2) /
+					(2 * (clk_div + 1));
+
+			if (real_rate <= mmc->clock)
+				break;
+		}
+
+		debug("%s: computed real_rete: %x, clk_div: %x\n",
+			 __func__, real_rate, clk_div);
+
+		if (clk_div > 127)
+			debug("%s: no match clock rate, %x\n",
+				__func__, mmc->clock);
+
+		clock = (clock & ~FTSDC010_CCR_CLK_DIV(0x7f)) |
+				FTSDC010_CCR_CLK_DIV(clk_div);
+
+		clock &= ~FTSDC010_CCR_CLK_DIS;
+	}
+
+	debug("%s, set clock: %08x\n", __func__, clock);
+	writel(clock, &host->reg->ccr);
+}
+
+static void ftsdc010_set_ios(struct mmc *mmc)
+{
+	struct mmc_host *host = mmc->priv;
+	unsigned int power;
+	unsigned long val;
+	unsigned int bus_width;
+
+	debug("%s: bus_width: %x, clock: %d\n",
+		__func__, mmc->bus_width, mmc->clock);
+
+	/* set pcr: power on */
+	power = readl(&host->reg->pcr);
+	power |= FTSDC010_PCR_POWER_ON;
+	writel(power, &host->reg->pcr);
+
+	if (mmc->clock)
+		ftsdc010_set_clk(mmc);
+
+	/* set bwr: bus width reg */
+	bus_width = readl(&host->reg->bwr);
+	bus_width &= ~(FTSDC010_BWR_WIDE_8_BUS | FTSDC010_BWR_WIDE_4_BUS |
+			FTSDC010_BWR_SINGLE_BUS);
+
+	if (mmc->bus_width == 8)
+		bus_width |= FTSDC010_BWR_WIDE_8_BUS;
+	else if (mmc->bus_width == 4)
+		bus_width |= FTSDC010_BWR_WIDE_4_BUS;
+	else
+		bus_width |= FTSDC010_BWR_SINGLE_BUS;
+
+	writel(bus_width, &host->reg->bwr);
+
+	/* set fifo depth */
+	val = readl(&host->reg->feature);
+	host->fifo_len = FTSDC010_FEATURE_FIFO_DEPTH(val) * 4; /* 4 bytes */
+
+	/* set data timeout register */
+	val = -1;
+	writel(val, &host->reg->dtr);
+}
+
+static void ftsdc010_reset(struct mmc_host *host)
+{
+	unsigned int timeout;
+
+	/* Do SDC_RST: Software reset for all register */
+	writel(FTSDC010_CMD_SDC_RST, &host->reg->cmd);
+
+	host->clock = 0;
+
+	/* this hardware has no reset finish flag to read */
+	/* wait 100ms maximum */
+	timeout = 100;
+
+	/* hw clears the bit when it's done */
+	while (readl(&host->reg->dtr) != 0) {
+		if (timeout == 0) {
+			printf("%s: reset timeout error\n", __func__);
+			return;
+		}
+		timeout--;
+		udelay(10*FTSDC010_DELAY_UNIT);
+	}
+}
+
+static int ftsdc010_core_init(struct mmc *mmc)
+{
+	struct mmc_host *host = mmc->priv;
+	unsigned int mask;
+	unsigned int major, minor, revision;
+
+	/* get hardware version */
+	host->version = readl(&host->reg->rev);
+
+	major = FTSDC010_REV_MAJOR(host->version);
+	minor = FTSDC010_REV_MINOR(host->version);
+	revision = FTSDC010_REV_REVISION(host->version);
+
+	printf("ftsdc010 hardware ver: %d_%d_r%d\n", major, minor, revision);
+
+	/* Interrupt MASK register init - mask all */
+	writel(0x0, &host->reg->int_mask);
+
+	mask = FTSDC010_INT_MASK_CMD_SEND |
+		FTSDC010_INT_MASK_DATA_END |
+		FTSDC010_INT_MASK_CARD_CHANGE;
+#ifdef CONFIG_FTSDC010_SDIO
+	mask |= FTSDC010_INT_MASK_CP_READY |
+		FTSDC010_INT_MASK_CP_BUF_READY |
+		FTSDC010_INT_MASK_PLAIN_TEXT_READY |
+		FTSDC010_INT_MASK_SDIO_IRPT;
+#endif
+
+	writel(mask, &host->reg->int_mask);
+
+	return 0;
+}
+
+int ftsdc010_mmc_init(int dev_index)
+{
+	struct mmc *mmc;
+	struct mmc_host *host;
+
+	mmc = &ftsdc010_dev[dev_index];
+
+	sprintf(mmc->name, "FTSDC010 SD/MMC");
+	mmc->priv = &ftsdc010_host[dev_index];
+	mmc->send_cmd = ftsdc010_request;
+	mmc->set_ios = ftsdc010_set_ios;
+	mmc->init = ftsdc010_core_init;
+
+	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	mmc->host_caps = MMC_MODE_4BIT | MMC_MODE_8BIT;
+
+	mmc->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+
+	mmc->f_min = CONFIG_SYS_CLK_FREQ / 2 / (2*128);
+	mmc->f_max = CONFIG_SYS_CLK_FREQ / 2 / 2;
+
+	ftsdc010_host[dev_index].clock = 0;
+	ftsdc010_host[dev_index].reg = ftsdc010_get_base_mmc(dev_index);
+	mmc_register(mmc);
+
+	/* reset mmc */
+	host = (struct mmc_host *)mmc->priv;
+	ftsdc010_reset(host);
+
+	return 0;
+}
diff -urN u-boot-2011.06/drivers/mmc/Makefile u-boot-HEAD/drivers/mmc/Makefile
--- u-boot-2011.06/drivers/mmc/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mmc/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -29,15 +29,19 @@
 COBJS-$(CONFIG_BFIN_SDH) += bfin_sdh.o
 COBJS-$(CONFIG_DAVINCI_MMC) += davinci_mmc.o
 COBJS-$(CONFIG_FSL_ESDHC) += fsl_esdhc.o
+COBJS-$(CONFIG_FTSDC010) += ftsdc010_esdhc.o
 COBJS-$(CONFIG_GENERIC_MMC) += mmc.o
 COBJS-$(CONFIG_GENERIC_ATMEL_MCI) += gen_atmel_mci.o
 COBJS-$(CONFIG_MMC_SPI) += mmc_spi.o
 COBJS-$(CONFIG_ARM_PL180_MMCI) += arm_pl180_mmci.o
+COBJS-$(CONFIG_MV_SDHCI) += mv_sdhci.o
 COBJS-$(CONFIG_MXC_MMC) += mxcmmc.o
-COBJS-$(CONFIG_OMAP3_MMC) += omap3_mmc.o
 COBJS-$(CONFIG_OMAP_HSMMC) += omap_hsmmc.o
 COBJS-$(CONFIG_PXA_MMC) += pxa_mmc.o
 COBJS-$(CONFIG_S5P_MMC) += s5p_mmc.o
+COBJS-$(CONFIG_SDHCI) += sdhci.o
+COBJS-$(CONFIG_SH_MMCIF) += sh_mmcif.o
+COBJS-$(CONFIG_TEGRA2_MMC) += tegra2_mmc.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff -urN u-boot-2011.06/drivers/mmc/mmc.c u-boot-HEAD/drivers/mmc/mmc.c
--- u-boot-2011.06/drivers/mmc/mmc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mmc/mmc.c	2011-09-19 23:25:08.000000000 +0200
@@ -115,7 +115,8 @@
 
 	cmd.cmdidx = MMC_CMD_SEND_STATUS;
 	cmd.resp_type = MMC_RSP_R1;
-	cmd.cmdarg = 0;
+	if (!mmc_host_is_spi(mmc))
+		cmd.cmdarg = mmc->rca << 16;
 	cmd.flags = 0;
 
 	do {
@@ -174,6 +175,88 @@
 	return NULL;
 }
 
+static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
+{
+	struct mmc_cmd cmd;
+	ulong end;
+	int err, start_cmd, end_cmd;
+
+	if (mmc->high_capacity)
+		end = start + blkcnt - 1;
+	else {
+		end = (start + blkcnt - 1) * mmc->write_bl_len;
+		start *= mmc->write_bl_len;
+	}
+
+	if (IS_SD(mmc)) {
+		start_cmd = SD_CMD_ERASE_WR_BLK_START;
+		end_cmd = SD_CMD_ERASE_WR_BLK_END;
+	} else {
+		start_cmd = MMC_CMD_ERASE_GROUP_START;
+		end_cmd = MMC_CMD_ERASE_GROUP_END;
+	}
+
+	cmd.cmdidx = start_cmd;
+	cmd.cmdarg = start;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.flags = 0;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		goto err_out;
+
+	cmd.cmdidx = end_cmd;
+	cmd.cmdarg = end;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		goto err_out;
+
+	cmd.cmdidx = MMC_CMD_ERASE;
+	cmd.cmdarg = SECURE_ERASE;
+	cmd.resp_type = MMC_RSP_R1b;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		goto err_out;
+
+	return 0;
+
+err_out:
+	puts("mmc erase failed\n");
+	return err;
+}
+
+static unsigned long
+mmc_berase(int dev_num, unsigned long start, lbaint_t blkcnt)
+{
+	int err = 0;
+	struct mmc *mmc = find_mmc_device(dev_num);
+	lbaint_t blk = 0, blk_r = 0;
+
+	if (!mmc)
+		return -1;
+
+	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
+		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
+			"The erase range would be change to 0x%lx~0x%lx\n\n",
+		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
+		       ((start + blkcnt + mmc->erase_grp_size)
+		       & ~(mmc->erase_grp_size - 1)) - 1);
+
+	while (blk < blkcnt) {
+		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
+			mmc->erase_grp_size : (blkcnt - blk);
+		err = mmc_erase_t(mmc, start + blk, blk_r);
+		if (err)
+			break;
+
+		blk += blk_r;
+	}
+
+	return blk;
+}
+
 static ulong
 mmc_write_blocks(struct mmc *mmc, ulong start, lbaint_t blkcnt, const void*src)
 {
@@ -449,6 +532,10 @@
 				(mmc->voltages &
 				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
 				(cmd.response[0] & OCR_ACCESS_MODE));
+
+		if (mmc->host_caps & MMC_MODE_HC)
+			cmd.cmdarg |= OCR_HCS;
+
 		cmd.flags = 0;
 
 		err = mmc_send_cmd(mmc, &cmd, NULL);
@@ -771,7 +858,7 @@
 {
 	int err;
 	uint mult, freq;
-	u64 cmult, csize;
+	u64 cmult, csize, capacity;
 	struct mmc_cmd cmd;
 	char ext_csd[512];
 	int timeout = 1000;
@@ -911,14 +998,40 @@
 			return err;
 	}
 
+	/*
+	 * For SD, its erase group is always one sector
+	 */
+	mmc->erase_grp_size = 1;
 	mmc->part_config = MMCPART_NOAVAILABLE;
 	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
 		/* check  ext_csd version and capacity */
 		err = mmc_send_ext_csd(mmc, ext_csd);
 		if (!err & (ext_csd[192] >= 2)) {
-			mmc->capacity = ext_csd[212] << 0 | ext_csd[213] << 8 |
-					ext_csd[214] << 16 | ext_csd[215] << 24;
-			mmc->capacity *= 512;
+			/*
+			 * According to the JEDEC Standard, the value of
+			 * ext_csd's capacity is valid if the value is more
+			 * than 2GB
+			 */
+			capacity = ext_csd[212] << 0 | ext_csd[213] << 8 |
+				   ext_csd[214] << 16 | ext_csd[215] << 24;
+			capacity *= 512;
+			if ((capacity >> 20) > 2 * 1024)
+				mmc->capacity = capacity;
+		}
+
+		/*
+		 * Check whether GROUP_DEF is set, if yes, read out
+		 * group size from ext_csd directly, or calculate
+		 * the group size from the csd value.
+		 */
+		if (ext_csd[175])
+			mmc->erase_grp_size = ext_csd[224] * 512 * 1024;
+		else {
+			int erase_gsz, erase_gmul;
+			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
+			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
+			mmc->erase_grp_size = (erase_gsz + 1)
+				* (erase_gmul + 1);
 		}
 
 		/* store the partition info of emmc */
@@ -1044,6 +1157,7 @@
 	mmc->block_dev.removable = 1;
 	mmc->block_dev.block_read = mmc_bread;
 	mmc->block_dev.block_write = mmc_bwrite;
+	mmc->block_dev.block_erase = mmc_berase;
 	if (!mmc->b_max)
 		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
 
@@ -1054,12 +1168,14 @@
 	return 0;
 }
 
+#ifdef CONFIG_PARTITIONS
 block_dev_desc_t *mmc_get_dev(int dev)
 {
 	struct mmc *mmc = find_mmc_device(dev);
 
 	return mmc ? &mmc->block_dev : NULL;
 }
+#endif
 
 int mmc_init(struct mmc *mmc)
 {
diff -urN u-boot-2011.06/drivers/mmc/mv_sdhci.c u-boot-HEAD/drivers/mmc/mv_sdhci.c
--- u-boot-2011.06/drivers/mmc/mv_sdhci.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/mmc/mv_sdhci.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,21 @@
+#include <common.h>
+#include <malloc.h>
+#include <sdhci.h>
+
+static char *MVSDH_NAME = "mv_sdh";
+int mv_sdh_init(u32 regbase, u32 max_clk, u32 min_clk, u32 quirks)
+{
+	struct sdhci_host *host = NULL;
+	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
+	if (!host) {
+		printf("sdh_host malloc fail!\n");
+		return 1;
+	}
+
+	host->name = MVSDH_NAME;
+	host->ioaddr = (void *)regbase;
+	host->quirks = quirks;
+	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
+	add_sdhci(host, max_clk, min_clk);
+	return 0;
+}
diff -urN u-boot-2011.06/drivers/mmc/omap3_mmc.c u-boot-HEAD/drivers/mmc/omap3_mmc.c
--- u-boot-2011.06/drivers/mmc/omap3_mmc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mmc/omap3_mmc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,570 +0,0 @@
-/*
- * (C) Copyright 2008
- * Texas Instruments, <www.ti.com>
- * Syed Mohammed Khasim <khasim@ti.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation's version 2 of
- * the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-#include <fat.h>
-#include <mmc.h>
-#include <part.h>
-#include <i2c.h>
-#include <twl4030.h>
-#include <asm/io.h>
-
-#include "omap3_mmc.h"
-
-static const unsigned short mmc_transspeed_val[15][4] = {
-	{CLKD(10, 1), CLKD(10, 10), CLKD(10, 100), CLKD(10, 1000)},
-	{CLKD(12, 1), CLKD(12, 10), CLKD(12, 100), CLKD(12, 1000)},
-	{CLKD(13, 1), CLKD(13, 10), CLKD(13, 100), CLKD(13, 1000)},
-	{CLKD(15, 1), CLKD(15, 10), CLKD(15, 100), CLKD(15, 1000)},
-	{CLKD(20, 1), CLKD(20, 10), CLKD(20, 100), CLKD(20, 1000)},
-	{CLKD(26, 1), CLKD(26, 10), CLKD(26, 100), CLKD(26, 1000)},
-	{CLKD(30, 1), CLKD(30, 10), CLKD(30, 100), CLKD(30, 1000)},
-	{CLKD(35, 1), CLKD(35, 10), CLKD(35, 100), CLKD(35, 1000)},
-	{CLKD(40, 1), CLKD(40, 10), CLKD(40, 100), CLKD(40, 1000)},
-	{CLKD(45, 1), CLKD(45, 10), CLKD(45, 100), CLKD(45, 1000)},
-	{CLKD(52, 1), CLKD(52, 10), CLKD(52, 100), CLKD(52, 1000)},
-	{CLKD(55, 1), CLKD(55, 10), CLKD(55, 100), CLKD(55, 1000)},
-	{CLKD(60, 1), CLKD(60, 10), CLKD(60, 100), CLKD(60, 1000)},
-	{CLKD(70, 1), CLKD(70, 10), CLKD(70, 100), CLKD(70, 1000)},
-	{CLKD(80, 1), CLKD(80, 10), CLKD(80, 100), CLKD(80, 1000)}
-};
-
-static mmc_card_data cur_card_data;
-static block_dev_desc_t mmc_blk_dev;
-static hsmmc_t *mmc_base = (hsmmc_t *)OMAP_HSMMC1_BASE;
-
-int mmc_set_dev(int dev_num)
-{
-	switch (dev_num) {
-	case 1:
-		mmc_base = (hsmmc_t *)OMAP_HSMMC1_BASE;
-		break;
-	case 2:
-		mmc_base = (hsmmc_t *)OMAP_HSMMC2_BASE;
-		break;
-	case 3:
-		mmc_base = (hsmmc_t *)OMAP_HSMMC3_BASE;
-		break;
-	default:
-		mmc_base = (hsmmc_t *)OMAP_HSMMC1_BASE;
-		return 1;
-	}
-
-	return 0;
-}
-
-block_dev_desc_t *mmc_get_dev(int dev)
-{
-	return (block_dev_desc_t *) &mmc_blk_dev;
-}
-
-static unsigned char mmc_board_init(void)
-{
-#if defined(CONFIG_TWL4030_POWER)
-	twl4030_power_mmc_init();
-#endif
-
-#if defined(CONFIG_OMAP34XX)
-	t2_t *t2_base = (t2_t *)T2_BASE;
-	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
-
-	writel(readl(&t2_base->pbias_lite) | PBIASLITEPWRDNZ1 |
-		PBIASSPEEDCTRL0 | PBIASLITEPWRDNZ0,
-		&t2_base->pbias_lite);
-
-	writel(readl(&t2_base->devconf0) | MMCSDIO1ADPCLKISEL,
-		&t2_base->devconf0);
-
-	writel(readl(&t2_base->devconf1) | MMCSDIO2ADPCLKISEL,
-		&t2_base->devconf1);
-
-	writel(readl(&prcm_base->fclken1_core) |
-		EN_MMC1 | EN_MMC2 | EN_MMC3,
-		&prcm_base->fclken1_core);
-
-	writel(readl(&prcm_base->iclken1_core) |
-		EN_MMC1 | EN_MMC2 | EN_MMC3,
-		&prcm_base->iclken1_core);
-#endif
-
-/* TODO add appropriate OMAP4 init */
-
-	return 1;
-}
-
-static void mmc_init_stream(void)
-{
-	writel(readl(&mmc_base->con) | INIT_INITSTREAM, &mmc_base->con);
-
-	writel(MMC_CMD0, &mmc_base->cmd);
-	while (!(readl(&mmc_base->stat) & CC_MASK));
-
-	writel(CC_MASK, &mmc_base->stat);
-
-	writel(MMC_CMD0, &mmc_base->cmd);
-	while (!(readl(&mmc_base->stat) & CC_MASK));
-
-	writel(readl(&mmc_base->con) & ~INIT_INITSTREAM, &mmc_base->con);
-}
-
-static unsigned char mmc_clock_config(unsigned int iclk, unsigned short clk_div)
-{
-	unsigned int val;
-
-	mmc_reg_out(&mmc_base->sysctl, (ICE_MASK | DTO_MASK | CEN_MASK),
-			(ICE_STOP | DTO_15THDTO | CEN_DISABLE));
-
-	switch (iclk) {
-	case CLK_INITSEQ:
-		val = MMC_INIT_SEQ_CLK / 2;
-		break;
-	case CLK_400KHZ:
-		val = MMC_400kHz_CLK;
-		break;
-	case CLK_MISC:
-		val = clk_div;
-		break;
-	default:
-		return 0;
-	}
-	mmc_reg_out(&mmc_base->sysctl, ICE_MASK | CLKD_MASK,
-			(val << CLKD_OFFSET) | ICE_OSCILLATE);
-
-	while ((readl(&mmc_base->sysctl) & ICS_MASK) == ICS_NOTREADY);
-
-	writel(readl(&mmc_base->sysctl) | CEN_ENABLE, &mmc_base->sysctl);
-	return 1;
-}
-
-static unsigned char mmc_init_setup(void)
-{
-	unsigned int reg_val;
-
-	mmc_board_init();
-
-	writel(readl(&mmc_base->sysconfig) | MMC_SOFTRESET,
-		&mmc_base->sysconfig);
-	while ((readl(&mmc_base->sysstatus) & RESETDONE) == 0);
-
-	writel(readl(&mmc_base->sysctl) | SOFTRESETALL, &mmc_base->sysctl);
-	while ((readl(&mmc_base->sysctl) & SOFTRESETALL) != 0x0);
-
-	writel(DTW_1_BITMODE | SDBP_PWROFF | SDVS_3V0, &mmc_base->hctl);
-	writel(readl(&mmc_base->capa) | VS30_3V0SUP | VS18_1V8SUP,
-		&mmc_base->capa);
-
-	reg_val = readl(&mmc_base->con) & RESERVED_MASK;
-
-	writel(CTPL_MMC_SD | reg_val | WPP_ACTIVEHIGH | CDP_ACTIVEHIGH |
-		MIT_CTO | DW8_1_4BITMODE | MODE_FUNC | STR_BLOCK |
-		HR_NOHOSTRESP | INIT_NOINIT | NOOPENDRAIN, &mmc_base->con);
-
-	mmc_clock_config(CLK_INITSEQ, 0);
-	writel(readl(&mmc_base->hctl) | SDBP_PWRON, &mmc_base->hctl);
-
-	writel(IE_BADA | IE_CERR | IE_DEB | IE_DCRC | IE_DTO | IE_CIE |
-		IE_CEB | IE_CCRC | IE_CTO | IE_BRR | IE_BWR | IE_TC | IE_CC,
-		&mmc_base->ie);
-
-	mmc_init_stream();
-	return 1;
-}
-
-static unsigned char mmc_send_cmd(unsigned int cmd, unsigned int arg,
-				unsigned int *response)
-{
-	unsigned int mmc_stat;
-
-	while ((readl(&mmc_base->pstate) & DATI_MASK) == DATI_CMDDIS);
-
-	writel(BLEN_512BYTESLEN | NBLK_STPCNT, &mmc_base->blk);
-	writel(0xFFFFFFFF, &mmc_base->stat);
-	writel(arg, &mmc_base->arg);
-	writel(cmd | CMD_TYPE_NORMAL | CICE_NOCHECK | CCCE_NOCHECK |
-		MSBS_SGLEBLK | ACEN_DISABLE | BCE_DISABLE | DE_DISABLE,
-		&mmc_base->cmd);
-
-	while (1) {
-		do {
-			mmc_stat = readl(&mmc_base->stat);
-		} while (mmc_stat == 0);
-
-		if ((mmc_stat & ERRI_MASK) != 0)
-			return (unsigned char) mmc_stat;
-
-		if (mmc_stat & CC_MASK) {
-			writel(CC_MASK, &mmc_base->stat);
-			response[0] = readl(&mmc_base->rsp10);
-			if ((cmd & RSP_TYPE_MASK) == RSP_TYPE_LGHT136) {
-				response[1] = readl(&mmc_base->rsp32);
-				response[2] = readl(&mmc_base->rsp54);
-				response[3] = readl(&mmc_base->rsp76);
-			}
-			break;
-		}
-	}
-	return 1;
-}
-
-static unsigned char mmc_read_data(unsigned int *output_buf)
-{
-	unsigned int mmc_stat;
-	unsigned int read_count = 0;
-
-	/*
-	 * Start Polled Read
-	 */
-	while (1) {
-		do {
-			mmc_stat = readl(&mmc_base->stat);
-		} while (mmc_stat == 0);
-
-		if ((mmc_stat & ERRI_MASK) != 0)
-			return (unsigned char) mmc_stat;
-
-		if (mmc_stat & BRR_MASK) {
-			unsigned int k;
-
-			writel(readl(&mmc_base->stat) | BRR_MASK,
-				&mmc_base->stat);
-			for (k = 0; k < MMCSD_SECTOR_SIZE / 4; k++) {
-				*output_buf = readl(&mmc_base->data);
-				output_buf++;
-				read_count += 4;
-			}
-		}
-
-		if (mmc_stat & BWR_MASK)
-			writel(readl(&mmc_base->stat) | BWR_MASK,
-				&mmc_base->stat);
-
-		if (mmc_stat & TC_MASK) {
-			writel(readl(&mmc_base->stat) | TC_MASK,
-				&mmc_base->stat);
-			break;
-		}
-	}
-	return 1;
-}
-
-static unsigned char mmc_detect_card(mmc_card_data *mmc_card_cur)
-{
-	unsigned char err;
-	unsigned int argument = 0;
-	unsigned int ocr_value, ocr_recvd, ret_cmd41, hcs_val;
-	unsigned short retry_cnt = 2000;
-	mmc_resp_t mmc_resp;
-
-	/* Set to Initialization Clock */
-	err = mmc_clock_config(CLK_400KHZ, 0);
-	if (err != 1)
-		return err;
-
-	mmc_card_cur->RCA = MMC_RELATIVE_CARD_ADDRESS;
-	argument = 0x00000000;
-
-	ocr_value = (0x1FF << 15);
-	err = mmc_send_cmd(MMC_CMD0, argument, mmc_resp.resp);
-	if (err != 1)
-		return err;
-
-	argument = SD_CMD8_CHECK_PATTERN | SD_CMD8_2_7_3_6_V_RANGE;
-	err = mmc_send_cmd(MMC_SDCMD8, argument, mmc_resp.resp);
-	hcs_val = (err == 1) ?
-		MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR :
-		MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE;
-
-	argument = 0x0000 << 16;
-	err = mmc_send_cmd(MMC_CMD55, argument, mmc_resp.resp);
-	if (err == 1) {
-		mmc_card_cur->card_type = SD_CARD;
-		ocr_value |= hcs_val;
-		ret_cmd41 = MMC_ACMD41;
-	} else {
-		mmc_card_cur->card_type = MMC_CARD;
-		ocr_value |= MMC_OCR_REG_ACCESS_MODE_SECTOR;
-		ret_cmd41 = MMC_CMD1;
-		writel(readl(&mmc_base->con) & ~OD, &mmc_base->con);
-		writel(readl(&mmc_base->con) | OPENDRAIN, &mmc_base->con);
-	}
-
-	argument = ocr_value;
-	err = mmc_send_cmd(ret_cmd41, argument, mmc_resp.resp);
-	if (err != 1)
-		return err;
-
-	ocr_recvd = mmc_resp.r3.ocr;
-
-	while (!(ocr_recvd & (0x1 << 31)) && (retry_cnt > 0)) {
-		retry_cnt--;
-		if (mmc_card_cur->card_type == SD_CARD) {
-			argument = 0x0000 << 16;
-			err = mmc_send_cmd(MMC_CMD55, argument, mmc_resp.resp);
-		}
-
-		argument = ocr_value;
-		err = mmc_send_cmd(ret_cmd41, argument, mmc_resp.resp);
-		if (err != 1)
-			return err;
-		ocr_recvd = mmc_resp.r3.ocr;
-	}
-
-	if (!(ocr_recvd & (0x1 << 31)))
-		return 0;
-
-	if (mmc_card_cur->card_type == MMC_CARD) {
-		if ((ocr_recvd & MMC_OCR_REG_ACCESS_MODE_MASK) ==
-			MMC_OCR_REG_ACCESS_MODE_SECTOR) {
-			mmc_card_cur->mode = SECTOR_MODE;
-		} else {
-			mmc_card_cur->mode = BYTE_MODE;
-		}
-
-		ocr_recvd &= ~MMC_OCR_REG_ACCESS_MODE_MASK;
-	} else {
-		if ((ocr_recvd & MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK)
-			== MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR) {
-			mmc_card_cur->mode = SECTOR_MODE;
-		} else {
-			mmc_card_cur->mode = BYTE_MODE;
-		}
-		ocr_recvd &= ~MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK;
-	}
-
-	ocr_recvd &= ~(0x1 << 31);
-	if (!(ocr_recvd & ocr_value))
-		return 0;
-
-	err = mmc_send_cmd(MMC_CMD2, argument, mmc_resp.resp);
-	if (err != 1)
-		return err;
-
-	if (mmc_card_cur->card_type == MMC_CARD) {
-		argument = mmc_card_cur->RCA << 16;
-		err = mmc_send_cmd(MMC_CMD3, argument, mmc_resp.resp);
-		if (err != 1)
-			return err;
-	} else {
-		argument = 0x00000000;
-		err = mmc_send_cmd(MMC_SDCMD3, argument, mmc_resp.resp);
-		if (err != 1)
-			return err;
-
-		mmc_card_cur->RCA = mmc_resp.r6.newpublishedrca;
-	}
-
-	writel(readl(&mmc_base->con) & ~OD, &mmc_base->con);
-	writel(readl(&mmc_base->con) | NOOPENDRAIN, &mmc_base->con);
-	return 1;
-}
-
-static unsigned char mmc_read_cardsize(mmc_card_data *mmc_dev_data,
-				mmc_csd_reg_t *cur_csd)
-{
-	mmc_extended_csd_reg_t ext_csd;
-	unsigned int size, count, blk_len, blk_no, card_size, argument;
-	unsigned char err;
-	unsigned int resp[4];
-
-	if (mmc_dev_data->mode == SECTOR_MODE) {
-		if (mmc_dev_data->card_type == SD_CARD) {
-			card_size =
-				(((mmc_sd2_csd_reg_t *) cur_csd)->
-				c_size_lsb & MMC_SD2_CSD_C_SIZE_LSB_MASK) |
-				((((mmc_sd2_csd_reg_t *) cur_csd)->
-				c_size_msb & MMC_SD2_CSD_C_SIZE_MSB_MASK)
-				<< MMC_SD2_CSD_C_SIZE_MSB_OFFSET);
-			mmc_dev_data->size = card_size * 1024;
-			if (mmc_dev_data->size == 0)
-				return 0;
-		} else {
-			argument = 0x00000000;
-			err = mmc_send_cmd(MMC_CMD8, argument, resp);
-			if (err != 1)
-				return err;
-			err = mmc_read_data((unsigned int *) &ext_csd);
-			if (err != 1)
-				return err;
-			mmc_dev_data->size = ext_csd.sectorcount;
-
-			if (mmc_dev_data->size == 0)
-				mmc_dev_data->size = 8388608;
-		}
-	} else {
-		if (cur_csd->c_size_mult >= 8)
-			return 0;
-
-		if (cur_csd->read_bl_len >= 12)
-			return 0;
-
-		/* Compute size */
-		count = 1 << (cur_csd->c_size_mult + 2);
-		card_size = (cur_csd->c_size_lsb & MMC_CSD_C_SIZE_LSB_MASK) |
-			((cur_csd->c_size_msb & MMC_CSD_C_SIZE_MSB_MASK)
-			<< MMC_CSD_C_SIZE_MSB_OFFSET);
-		blk_no = (card_size + 1) * count;
-		blk_len = 1 << cur_csd->read_bl_len;
-		size = blk_no * blk_len;
-		mmc_dev_data->size = size / MMCSD_SECTOR_SIZE;
-		if (mmc_dev_data->size == 0)
-			return 0;
-	}
-	return 1;
-}
-
-static unsigned long mmc_bread(int dev_num, unsigned long blknr,
-		lbaint_t blkcnt, void *dst)
-{
-	unsigned char err;
-	unsigned int argument;
-	unsigned int resp[4];
-	unsigned int *output_buf = dst;
-	unsigned int sec_inc_val;
-	lbaint_t i;
-
-	if (blkcnt == 0)
-		return 0;
-
-	if (cur_card_data.mode == SECTOR_MODE) {
-		argument = blknr;
-		sec_inc_val = 1;
-	} else {
-		argument = blknr * MMCSD_SECTOR_SIZE;
-		sec_inc_val = MMCSD_SECTOR_SIZE;
-	}
-
-	for (i = 0; i < blkcnt; i++) {
-		err = mmc_send_cmd(MMC_CMD17, argument, resp);
-		if (err != 1) {
-			printf("mmc: CMD17 failed, status = %08x\n", err);
-			break;
-		}
-
-		err = mmc_read_data(output_buf);
-		if (err != 1) {
-			printf("mmc: read failed, status = %08x\n", err);
-			break;
-		}
-
-		output_buf += (MMCSD_SECTOR_SIZE / 4);
-		argument += sec_inc_val;
-	}
-
-	return i;
-}
-
-static unsigned char configure_mmc(mmc_card_data *mmc_card_cur)
-{
-	unsigned char ret_val;
-	unsigned int argument;
-	unsigned int trans_clk, trans_fact, trans_unit, retries = 2;
-	unsigned char trans_speed;
-	mmc_resp_t mmc_resp;
-
-	ret_val = mmc_init_setup();
-
-	if (ret_val != 1)
-		return ret_val;
-
-	do {
-		ret_val = mmc_detect_card(mmc_card_cur);
-		retries--;
-	} while ((retries > 0) && (ret_val != 1));
-
-	argument = mmc_card_cur->RCA << 16;
-	ret_val = mmc_send_cmd(MMC_CMD9, argument, mmc_resp.resp);
-	if (ret_val != 1)
-		return ret_val;
-
-	if (mmc_card_cur->card_type == MMC_CARD)
-		mmc_card_cur->version = mmc_resp.Card_CSD.spec_vers;
-
-	trans_speed = mmc_resp.Card_CSD.tran_speed;
-
-	ret_val = mmc_send_cmd(MMC_CMD4, MMC_DSR_DEFAULT << 16, mmc_resp.resp);
-	if (ret_val != 1)
-		return ret_val;
-
-	trans_unit = trans_speed & MMC_CSD_TRAN_SPEED_UNIT_MASK;
-	trans_fact = trans_speed & MMC_CSD_TRAN_SPEED_FACTOR_MASK;
-
-	if (trans_unit > MMC_CSD_TRAN_SPEED_UNIT_100MHZ)
-		return 0;
-
-	if ((trans_fact < MMC_CSD_TRAN_SPEED_FACTOR_1_0) ||
-		(trans_fact > MMC_CSD_TRAN_SPEED_FACTOR_8_0))
-		return 0;
-
-	trans_unit >>= 0;
-	trans_fact >>= 3;
-
-	trans_clk = mmc_transspeed_val[trans_fact - 1][trans_unit] * 2;
-	ret_val = mmc_clock_config(CLK_MISC, trans_clk);
-
-	if (ret_val != 1)
-		return ret_val;
-
-	argument = mmc_card_cur->RCA << 16;
-	ret_val = mmc_send_cmd(MMC_CMD7_SELECT, argument, mmc_resp.resp);
-	if (ret_val != 1)
-		return ret_val;
-
-	/* Configure the block length to 512 bytes */
-	argument = MMCSD_SECTOR_SIZE;
-	ret_val = mmc_send_cmd(MMC_CMD16, argument, mmc_resp.resp);
-	if (ret_val != 1)
-		return ret_val;
-
-	/* get the card size in sectors */
-	ret_val = mmc_read_cardsize(mmc_card_cur, &mmc_resp.Card_CSD);
-	if (ret_val != 1)
-		return ret_val;
-
-	return 1;
-}
-
-int mmc_legacy_init(int dev)
-{
-	if (mmc_set_dev(dev) != 0)
-		return 1;
-
-	if (configure_mmc(&cur_card_data) != 1)
-		return 1;
-
-	mmc_blk_dev.if_type = IF_TYPE_MMC;
-	mmc_blk_dev.part_type = PART_TYPE_DOS;
-	mmc_blk_dev.dev = 0;
-	mmc_blk_dev.lun = 0;
-	mmc_blk_dev.type = 0;
-
-	/* FIXME fill in the correct size (is set to 32MByte) */
-	mmc_blk_dev.blksz = MMCSD_SECTOR_SIZE;
-	mmc_blk_dev.lba = 0x10000;
-	mmc_blk_dev.removable = 0;
-	mmc_blk_dev.block_read = mmc_bread;
-
-	fat_register_device(&mmc_blk_dev, 1);
-	return 0;
-}
diff -urN u-boot-2011.06/drivers/mmc/omap3_mmc.h u-boot-HEAD/drivers/mmc/omap3_mmc.h
--- u-boot-2011.06/drivers/mmc/omap3_mmc.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mmc/omap3_mmc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-/*
- * (C) Copyright 2008
- * Texas Instruments, <www.ti.com>
- * Syed Mohammed Khasim <khasim@ti.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation's version 2 of
- * the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef MMC_H
-#define MMC_H
-
-#include <asm/arch/mmc_host_def.h>
-
-/* Responses */
-#define RSP_TYPE_NONE	(RSP_TYPE_NORSP   | CCCE_NOCHECK | CICE_NOCHECK)
-#define RSP_TYPE_R1	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
-#define RSP_TYPE_R1B	(RSP_TYPE_LGHT48B | CCCE_CHECK   | CICE_CHECK)
-#define RSP_TYPE_R2	(RSP_TYPE_LGHT136 | CCCE_CHECK   | CICE_NOCHECK)
-#define RSP_TYPE_R3	(RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
-#define RSP_TYPE_R4	(RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
-#define RSP_TYPE_R5	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
-#define RSP_TYPE_R6	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
-#define RSP_TYPE_R7	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
-
-/* All supported commands */
-#define MMC_CMD0	(INDEX(0)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD1	(INDEX(1)  | RSP_TYPE_R3   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD2	(INDEX(2)  | RSP_TYPE_R2   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD3	(INDEX(3)  | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_SDCMD3	(INDEX(3)  | RSP_TYPE_R6   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD4	(INDEX(4)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD6	(INDEX(6)  | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD7_SELECT	(INDEX(7)  | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD7_DESELECT (INDEX(7)| RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD8	(INDEX(8)  | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
-#define MMC_SDCMD8	(INDEX(8)  | RSP_TYPE_R7   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD9	(INDEX(9)  | RSP_TYPE_R2   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD12	(INDEX(12) | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD13	(INDEX(13) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD15	(INDEX(15) | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD16	(INDEX(16) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_CMD17	(INDEX(17) | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
-#define MMC_CMD24	(INDEX(24) | RSP_TYPE_R1   | DP_DATA    | DDIR_WRITE)
-#define MMC_ACMD6	(INDEX(6)  | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_ACMD41	(INDEX(41) | RSP_TYPE_R3   | DP_NO_DATA | DDIR_WRITE)
-#define MMC_ACMD51	(INDEX(51) | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
-#define MMC_CMD55	(INDEX(55) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
-
-#define MMC_AC_CMD_RCA_MASK	(unsigned int)(0xFFFF << 16)
-#define MMC_BC_CMD_DSR_MASK	(unsigned int)(0xFFFF << 16)
-#define MMC_DSR_DEFAULT		0x0404
-#define SD_CMD8_CHECK_PATTERN	0xAA
-#define SD_CMD8_2_7_3_6_V_RANGE	(0x01 << 8)
-
-/* Clock Configurations and Macros */
-
-#define MMC_CLOCK_REFERENCE		96
-#define MMC_RELATIVE_CARD_ADDRESS	0x1234
-#define MMC_INIT_SEQ_CLK		(MMC_CLOCK_REFERENCE * 1000 / 80)
-#define MMC_400kHz_CLK			(MMC_CLOCK_REFERENCE * 1000 / 400)
-#define CLKDR(r, f, u)			((((r)*100) / ((f)*(u))) + 1)
-#define CLKD(f, u)			(CLKDR(MMC_CLOCK_REFERENCE, f, u))
-
-#define MMC_OCR_REG_ACCESS_MODE_MASK	(0x3 << 29)
-#define MMC_OCR_REG_ACCESS_MODE_BYTE 	(0x0 << 29)
-#define MMC_OCR_REG_ACCESS_MODE_SECTOR	(0x2 << 29)
-
-#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK		(0x1 << 30)
-#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE		(0x0 << 30)
-#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR	(0x1 << 30)
-
-#define MMC_SD2_CSD_C_SIZE_LSB_MASK	0xFFFF
-#define MMC_SD2_CSD_C_SIZE_MSB_MASK	0x003F
-#define MMC_SD2_CSD_C_SIZE_MSB_OFFSET	16
-#define MMC_CSD_C_SIZE_LSB_MASK		0x0003
-#define MMC_CSD_C_SIZE_MSB_MASK		0x03FF
-#define MMC_CSD_C_SIZE_MSB_OFFSET	2
-
-#define MMC_CSD_TRAN_SPEED_UNIT_MASK	(0x07 << 0)
-#define MMC_CSD_TRAN_SPEED_FACTOR_MASK	(0x0F << 3)
-#define MMC_CSD_TRAN_SPEED_UNIT_100MHZ	(0x3 << 0)
-#define MMC_CSD_TRAN_SPEED_FACTOR_1_0	(0x01 << 3)
-#define MMC_CSD_TRAN_SPEED_FACTOR_8_0	(0x0F << 3)
-
-typedef struct {
-	unsigned not_used:1;
-	unsigned crc:7;
-	unsigned ecc:2;
-	unsigned file_format:2;
-	unsigned tmp_write_protect:1;
-	unsigned perm_write_protect:1;
-	unsigned copy:1;
-	unsigned file_format_grp:1;
-	unsigned content_prot_app:1;
-	unsigned reserved_1:4;
-	unsigned write_bl_partial:1;
-	unsigned write_bl_len:4;
-	unsigned r2w_factor:3;
-	unsigned default_ecc:2;
-	unsigned wp_grp_enable:1;
-	unsigned wp_grp_size:5;
-	unsigned erase_grp_mult:5;
-	unsigned erase_grp_size:5;
-	unsigned c_size_mult:3;
-	unsigned vdd_w_curr_max:3;
-	unsigned vdd_w_curr_min:3;
-	unsigned vdd_r_curr_max:3;
-	unsigned vdd_r_curr_min:3;
-	unsigned c_size_lsb:2;
-	unsigned c_size_msb:10;
-	unsigned reserved_2:2;
-	unsigned dsr_imp:1;
-	unsigned read_blk_misalign:1;
-	unsigned write_blk_misalign:1;
-	unsigned read_bl_partial:1;
-	unsigned read_bl_len:4;
-	unsigned ccc:12;
-	unsigned tran_speed:8;
-	unsigned nsac:8;
-	unsigned taac:8;
-	unsigned reserved_3:2;
-	unsigned spec_vers:4;
-	unsigned csd_structure:2;
-} mmc_csd_reg_t;
-
-/* csd for sd2.0 */
-typedef struct {
-	unsigned not_used:1;
-	unsigned crc:7;
-	unsigned reserved_1:2;
-	unsigned file_format:2;
-	unsigned tmp_write_protect:1;
-	unsigned perm_write_protect:1;
-	unsigned copy:1;
-	unsigned file_format_grp:1;
-	unsigned reserved_2:5;
-	unsigned write_bl_partial:1;
-	unsigned write_bl_len:4;
-	unsigned r2w_factor:3;
-	unsigned reserved_3:2;
-	unsigned wp_grp_enable:1;
-	unsigned wp_grp_size:7;
-	unsigned sector_size:7;
-	unsigned erase_blk_len:1;
-	unsigned reserved_4:1;
-	unsigned c_size_lsb:16;
-	unsigned c_size_msb:6;
-	unsigned reserved_5:6;
-	unsigned dsr_imp:1;
-	unsigned read_blk_misalign:1;
-	unsigned write_blk_misalign:1;
-	unsigned read_bl_partial:1;
-	unsigned read_bl_len:4;
-	unsigned ccc:12;
-	unsigned tran_speed:8;
-	unsigned nsac:8;
-	unsigned taac:8;
-	unsigned reserved_6:6;
-	unsigned csd_structure:2;
-} mmc_sd2_csd_reg_t;
-
-/* extended csd - 512 bytes long */
-typedef struct {
-	unsigned char reserved_1[181];
-	unsigned char erasedmemorycontent;
-	unsigned char reserved_2;
-	unsigned char buswidthmode;
-	unsigned char reserved_3;
-	unsigned char highspeedinterfacetiming;
-	unsigned char reserved_4;
-	unsigned char powerclass;
-	unsigned char reserved_5;
-	unsigned char commandsetrevision;
-	unsigned char reserved_6;
-	unsigned char commandset;
-	unsigned char extendedcsdrevision;
-	unsigned char reserved_7;
-	unsigned char csdstructureversion;
-	unsigned char reserved_8;
-	unsigned char cardtype;
-	unsigned char reserved_9[3];
-	unsigned char powerclass_52mhz_1_95v;
-	unsigned char powerclass_26mhz_1_95v;
-	unsigned char powerclass_52mhz_3_6v;
-	unsigned char powerclass_26mhz_3_6v;
-	unsigned char reserved_10;
-	unsigned char minreadperf_4b_26mhz;
-	unsigned char minwriteperf_4b_26mhz;
-	unsigned char minreadperf_8b_26mhz_4b_52mhz;
-	unsigned char minwriteperf_8b_26mhz_4b_52mhz;
-	unsigned char minreadperf_8b_52mhz;
-	unsigned char minwriteperf_8b_52mhz;
-	unsigned char reserved_11;
-	unsigned int sectorcount;
-	unsigned char reserved_12[288];
-	unsigned char supportedcommandsets;
-	unsigned char reserved_13[7];
-} mmc_extended_csd_reg_t;
-
-/* mmc sd responce */
-typedef struct {
-	unsigned int ocr;
-} mmc_resp_r3;
-
-typedef struct {
-	unsigned short cardstatus;
-	unsigned short newpublishedrca;
-} mmc_resp_r6;
-
-typedef union {
-	unsigned int resp[4];
-	mmc_resp_r3 r3;
-	mmc_resp_r6 r6;
-	mmc_csd_reg_t Card_CSD;
-} mmc_resp_t;
-
-#endif /* MMC_H */
diff -urN u-boot-2011.06/drivers/mmc/s5p_mmc.c u-boot-HEAD/drivers/mmc/s5p_mmc.c
--- u-boot-2011.06/drivers/mmc/s5p_mmc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mmc/s5p_mmc.c	2011-09-19 23:25:08.000000000 +0200
@@ -232,9 +232,15 @@
 						__func__, mask);
 				return -1;
 			} else if (mask & (1 << 3)) {
-				/* DMA Interrupt */
+				/*
+				 * DMA Interrupt, restart the transfer where
+				 * it was interrupted.
+				 */
+				unsigned int address = readl(&host->reg->sysad);
+
 				debug("DMA end\n");
-				break;
+				writel((1 << 3), &host->reg->norintsts);
+				writel(address, &host->reg->sysad);
 			} else if (mask & (1 << 1)) {
 				/* Transfer Complete */
 				debug("r/w is done\n");
@@ -425,12 +431,13 @@
 	 * NORMAL Interrupt Status Enable Register init
 	 * [5] ENSTABUFRDRDY : Buffer Read Ready Status Enable
 	 * [4] ENSTABUFWTRDY : Buffer write Ready Status Enable
+	 * [3] ENSTADMAINT : DMA Interrupt Status Enable
 	 * [1] ENSTASTANSCMPLT : Transfre Complete Status Enable
 	 * [0] ENSTACMDCMPLT : Command Complete Status Enable
-	*/
+	 */
 	mask = readl(&host->reg->norintstsen);
 	mask &= ~(0xffff);
-	mask |= (1 << 5) | (1 << 4) | (1 << 1) | (1 << 0);
+	mask |= (1 << 5) | (1 << 4) | (1 << 3) | (1 << 1) | (1 << 0);
 	writel(mask, &host->reg->norintstsen);
 
 	/*
@@ -462,7 +469,7 @@
 		mmc->host_caps = MMC_MODE_8BIT;
 	else
 		mmc->host_caps = MMC_MODE_4BIT;
-	mmc->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+	mmc->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS | MMC_MODE_HC;
 
 	mmc->f_min = 400000;
 	mmc->f_max = 52000000;
diff -urN u-boot-2011.06/drivers/mmc/sdhci.c u-boot-HEAD/drivers/mmc/sdhci.c
--- u-boot-2011.06/drivers/mmc/sdhci.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/mmc/sdhci.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,433 @@
+/*
+ * Copyright 2011, Marvell Semiconductor Inc.
+ * Lei Wen <leiwen@marvell.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Back ported to the 8xx platform (from the 8260 platform) by
+ * Murray.Jensen@cmst.csiro.au, 27-Jan-01.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <sdhci.h>
+
+void *aligned_buffer;
+
+static void sdhci_reset(struct sdhci_host *host, u8 mask)
+{
+	unsigned long timeout;
+
+	/* Wait max 100 ms */
+	timeout = 100;
+	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
+		if (timeout == 0) {
+			printf("Reset 0x%x never completed.\n", (int)mask);
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+}
+
+static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
+{
+	int i;
+	if (cmd->resp_type & MMC_RSP_136) {
+		/* CRC is stripped so we need to do some shifting. */
+		for (i = 0; i < 4; i++) {
+			cmd->response[i] = sdhci_readl(host,
+					SDHCI_RESPONSE + (3-i)*4) << 8;
+			if (i != 3)
+				cmd->response[i] |= sdhci_readb(host,
+						SDHCI_RESPONSE + (3-i)*4-1);
+		}
+	} else {
+		cmd->response[0] = sdhci_readl(host, SDHCI_RESPONSE);
+	}
+}
+
+static void sdhci_transfer_pio(struct sdhci_host *host, struct mmc_data *data)
+{
+	int i;
+	char *offs;
+	for (i = 0; i < data->blocksize; i += 4) {
+		offs = data->dest + i;
+		if (data->flags == MMC_DATA_READ)
+			*(u32 *)offs = sdhci_readl(host, SDHCI_BUFFER);
+		else
+			sdhci_writel(host, *(u32 *)offs, SDHCI_BUFFER);
+	}
+}
+
+static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data,
+				unsigned int start_addr)
+{
+	unsigned int stat, rdy, mask, block = 0;
+
+	rdy = SDHCI_INT_SPACE_AVAIL | SDHCI_INT_DATA_AVAIL;
+	mask = SDHCI_DATA_AVAILABLE | SDHCI_SPACE_AVAILABLE;
+	do {
+		stat = sdhci_readl(host, SDHCI_INT_STATUS);
+		if (stat & SDHCI_INT_ERROR) {
+			printf("Error detected in status(0x%X)!\n", stat);
+			return -1;
+		}
+		if (stat & rdy) {
+			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
+				continue;
+			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
+			sdhci_transfer_pio(host, data);
+			data->dest += data->blocksize;
+			if (++block >= data->blocks)
+				break;
+		}
+#ifdef CONFIG_MMC_SDMA
+		if (stat & SDHCI_INT_DMA_END) {
+			sdhci_writel(host, SDHCI_INT_DMA_END, SDHCI_INT_STATUS);
+			start_addr &= SDHCI_DEFAULT_BOUNDARY_SIZE - 1;
+			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
+			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
+		}
+#endif
+	} while (!(stat & SDHCI_INT_DATA_END));
+	return 0;
+}
+
+int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
+		       struct mmc_data *data)
+{
+	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
+	unsigned int stat = 0;
+	int ret = 0;
+	int trans_bytes = 0, is_aligned = 1;
+	u32 mask, flags, mode;
+	unsigned int timeout, start_addr = 0;
+
+	/* Wait max 10 ms */
+	timeout = 10;
+
+	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
+	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
+
+	/* We shouldn't wait for data inihibit for stop commands, even
+	   though they might use busy signaling */
+	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
+		mask &= ~SDHCI_DATA_INHIBIT;
+
+	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
+		if (timeout == 0) {
+			printf("Controller never released inhibit bit(s).\n");
+			return COMM_ERR;
+		}
+		timeout--;
+		udelay(1000);
+	}
+
+	mask = SDHCI_INT_RESPONSE;
+	if (!(cmd->resp_type & MMC_RSP_PRESENT))
+		flags = SDHCI_CMD_RESP_NONE;
+	else if (cmd->resp_type & MMC_RSP_136)
+		flags = SDHCI_CMD_RESP_LONG;
+	else if (cmd->resp_type & MMC_RSP_BUSY) {
+		flags = SDHCI_CMD_RESP_SHORT_BUSY;
+		mask |= SDHCI_INT_DATA_END;
+	} else
+		flags = SDHCI_CMD_RESP_SHORT;
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		flags |= SDHCI_CMD_CRC;
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		flags |= SDHCI_CMD_INDEX;
+	if (data)
+		flags |= SDHCI_CMD_DATA;
+
+	/*Set Transfer mode regarding to data flag*/
+	if (data != 0) {
+		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
+		mode = SDHCI_TRNS_BLK_CNT_EN;
+		trans_bytes = data->blocks * data->blocksize;
+		if (data->blocks > 1)
+			mode |= SDHCI_TRNS_MULTI;
+
+		if (data->flags == MMC_DATA_READ)
+			mode |= SDHCI_TRNS_READ;
+
+#ifdef CONFIG_MMC_SDMA
+		if (data->flags == MMC_DATA_READ)
+			start_addr = (unsigned int)data->dest;
+		else
+			start_addr = (unsigned int)data->src;
+		if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
+				(start_addr & 0x7) != 0x0) {
+			is_aligned = 0;
+			start_addr = (unsigned int)aligned_buffer;
+			if (data->flags != MMC_DATA_READ)
+				memcpy(aligned_buffer, data->src, trans_bytes);
+		}
+
+		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
+		mode |= SDHCI_TRNS_DMA;
+#endif
+		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
+				data->blocksize),
+				SDHCI_BLOCK_SIZE);
+		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
+		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
+	}
+
+	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
+#ifdef CONFIG_MMC_SDMA
+	flush_cache(0, ~0);
+#endif
+	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
+	do {
+		stat = sdhci_readl(host, SDHCI_INT_STATUS);
+		if (stat & SDHCI_INT_ERROR)
+			break;
+	} while ((stat & mask) != mask);
+
+	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
+		sdhci_cmd_done(host, cmd);
+		sdhci_writel(host, mask, SDHCI_INT_STATUS);
+	} else
+		ret = -1;
+
+	if (!ret && data)
+		ret = sdhci_transfer_data(host, data, start_addr);
+
+	stat = sdhci_readl(host, SDHCI_INT_STATUS);
+	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
+	if (!ret) {
+		if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
+				!is_aligned && (data->flags == MMC_DATA_READ))
+			memcpy(data->dest, aligned_buffer, trans_bytes);
+		return 0;
+	}
+
+	sdhci_reset(host, SDHCI_RESET_CMD);
+	sdhci_reset(host, SDHCI_RESET_DATA);
+	if (stat & SDHCI_INT_TIMEOUT)
+		return TIMEOUT;
+	else
+		return COMM_ERR;
+}
+
+static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
+{
+	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
+	unsigned int div, clk, timeout;
+
+	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
+
+	if (clock == 0)
+		return 0;
+
+	if (host->version >= SDHCI_SPEC_300) {
+		/* Version 3.00 divisors must be a multiple of 2. */
+		if (mmc->f_max <= clock)
+			div = 1;
+		else {
+			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
+				if ((mmc->f_max / div) <= clock)
+					break;
+			}
+		}
+	} else {
+		/* Version 2.00 divisors must be a power of 2. */
+		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
+			if ((mmc->f_max / div) <= clock)
+				break;
+		}
+	}
+	div >>= 1;
+
+	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
+	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
+		<< SDHCI_DIVIDER_HI_SHIFT;
+	clk |= SDHCI_CLOCK_INT_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 20 ms */
+	timeout = 20;
+	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+		& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			printf("Internal clock never stabilised.\n");
+			return -1;
+		}
+		timeout--;
+		udelay(1000);
+	}
+
+	clk |= SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	return 0;
+}
+
+static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
+{
+	u8 pwr = 0;
+
+	if (power != (unsigned short)-1) {
+		switch (1 << power) {
+		case MMC_VDD_165_195:
+			pwr = SDHCI_POWER_180;
+			break;
+		case MMC_VDD_29_30:
+		case MMC_VDD_30_31:
+			pwr = SDHCI_POWER_300;
+			break;
+		case MMC_VDD_32_33:
+		case MMC_VDD_33_34:
+			pwr = SDHCI_POWER_330;
+			break;
+		}
+	}
+
+	if (pwr == 0) {
+		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
+		return;
+	}
+
+	pwr |= SDHCI_POWER_ON;
+
+	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
+}
+
+void sdhci_set_ios(struct mmc *mmc)
+{
+	u32 ctrl;
+	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
+
+	if (mmc->clock != host->clock)
+		sdhci_set_clock(mmc, mmc->clock);
+
+	/* Set bus width */
+	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+	if (mmc->bus_width == 8) {
+		ctrl &= ~SDHCI_CTRL_4BITBUS;
+		if (host->version >= SDHCI_SPEC_300)
+			ctrl |= SDHCI_CTRL_8BITBUS;
+	} else {
+		if (host->version >= SDHCI_SPEC_300)
+			ctrl &= ~SDHCI_CTRL_8BITBUS;
+		if (mmc->bus_width == 4)
+			ctrl |= SDHCI_CTRL_4BITBUS;
+		else
+			ctrl &= ~SDHCI_CTRL_4BITBUS;
+	}
+
+	if (mmc->clock > 26000000)
+		ctrl |= SDHCI_CTRL_HISPD;
+	else
+		ctrl &= ~SDHCI_CTRL_HISPD;
+
+	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+}
+
+int sdhci_init(struct mmc *mmc)
+{
+	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
+
+	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
+		aligned_buffer = memalign(8, 512*1024);
+		if (!aligned_buffer) {
+			printf("Aligned buffer alloc failed!!!");
+			return -1;
+		}
+	}
+
+	/* Eable all state */
+	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_ENABLE);
+	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_SIGNAL_ENABLE);
+
+	sdhci_set_power(host, fls(mmc->voltages) - 1);
+
+	return 0;
+}
+
+int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
+{
+	struct mmc *mmc;
+	unsigned int caps;
+
+	mmc = malloc(sizeof(struct mmc));
+	if (!mmc) {
+		printf("mmc malloc fail!\n");
+		return -1;
+	}
+
+	mmc->priv = host;
+
+	sprintf(mmc->name, "%s", host->name);
+	mmc->send_cmd = sdhci_send_command;
+	mmc->set_ios = sdhci_set_ios;
+	mmc->init = sdhci_init;
+
+	caps = sdhci_readl(host, SDHCI_CAPABILITIES);
+#ifdef CONFIG_MMC_SDMA
+	if (!(caps & SDHCI_CAN_DO_SDMA)) {
+		printf("Your controller don't support sdma!!\n");
+		return -1;
+	}
+#endif
+
+	if (max_clk)
+		mmc->f_max = max_clk;
+	else {
+		if (host->version >= SDHCI_SPEC_300)
+			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
+				>> SDHCI_CLOCK_BASE_SHIFT;
+		else
+			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
+				>> SDHCI_CLOCK_BASE_SHIFT;
+		mmc->f_max *= 1000000;
+	}
+	if (mmc->f_max == 0) {
+		printf("Hardware doesn't specify base clock frequency\n");
+		return -1;
+	}
+	if (min_clk)
+		mmc->f_min = min_clk;
+	else {
+		if (host->version >= SDHCI_SPEC_300)
+			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
+		else
+			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
+	}
+
+	mmc->voltages = 0;
+	if (caps & SDHCI_CAN_VDD_330)
+		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
+	if (caps & SDHCI_CAN_VDD_300)
+		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
+	if (caps & SDHCI_CAN_VDD_180)
+		mmc->voltages |= MMC_VDD_165_195;
+	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
+	if (caps & SDHCI_CAN_DO_8BIT)
+		mmc->host_caps |= MMC_MODE_8BIT;
+
+	sdhci_reset(host, SDHCI_RESET_ALL);
+	mmc_register(mmc);
+
+	return 0;
+}
diff -urN u-boot-2011.06/drivers/mmc/sh_mmcif.c u-boot-HEAD/drivers/mmc/sh_mmcif.c
--- u-boot-2011.06/drivers/mmc/sh_mmcif.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/mmc/sh_mmcif.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,608 @@
+/*
+ * MMCIF driver.
+ *
+ * Copyright (C)  2011 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <watchdog.h>
+#include <command.h>
+#include <mmc.h>
+#include <malloc.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include "sh_mmcif.h"
+
+#define DRIVER_NAME	"sh_mmcif"
+
+static void *mmc_priv(struct mmc *mmc)
+{
+	return (void *)mmc->priv;
+}
+
+static int sh_mmcif_intr(void *dev_id)
+{
+	struct sh_mmcif_host *host = dev_id;
+	u32 state = 0;
+
+	state = sh_mmcif_read(&host->regs->ce_int);
+	state &= sh_mmcif_read(&host->regs->ce_int_mask);
+
+	if (state & INT_RBSYE) {
+		sh_mmcif_write(~(INT_RBSYE | INT_CRSPE), &host->regs->ce_int);
+		sh_mmcif_bitclr(MASK_MRBSYE, &host->regs->ce_int_mask);
+		goto end;
+	} else if (state & INT_CRSPE) {
+		sh_mmcif_write(~INT_CRSPE, &host->regs->ce_int);
+		sh_mmcif_bitclr(MASK_MCRSPE, &host->regs->ce_int_mask);
+		/* one more interrupt (INT_RBSYE) */
+		if (sh_mmcif_read(&host->regs->ce_cmd_set) & CMD_SET_RBSY)
+			return -EAGAIN;
+		goto end;
+	} else if (state & INT_BUFREN) {
+		sh_mmcif_write(~INT_BUFREN, &host->regs->ce_int);
+		sh_mmcif_bitclr(MASK_MBUFREN, &host->regs->ce_int_mask);
+		goto end;
+	} else if (state & INT_BUFWEN) {
+		sh_mmcif_write(~INT_BUFWEN, &host->regs->ce_int);
+		sh_mmcif_bitclr(MASK_MBUFWEN, &host->regs->ce_int_mask);
+		goto end;
+	} else if (state & INT_CMD12DRE) {
+		sh_mmcif_write(~(INT_CMD12DRE | INT_CMD12RBE | INT_CMD12CRE |
+				  INT_BUFRE), &host->regs->ce_int);
+		sh_mmcif_bitclr(MASK_MCMD12DRE, &host->regs->ce_int_mask);
+		goto end;
+	} else if (state & INT_BUFRE) {
+		sh_mmcif_write(~INT_BUFRE, &host->regs->ce_int);
+		sh_mmcif_bitclr(MASK_MBUFRE, &host->regs->ce_int_mask);
+		goto end;
+	} else if (state & INT_DTRANE) {
+		sh_mmcif_write(~INT_DTRANE, &host->regs->ce_int);
+		sh_mmcif_bitclr(MASK_MDTRANE, &host->regs->ce_int_mask);
+		goto end;
+	} else if (state & INT_CMD12RBE) {
+		sh_mmcif_write(~(INT_CMD12RBE | INT_CMD12CRE),
+				&host->regs->ce_int);
+		sh_mmcif_bitclr(MASK_MCMD12RBE, &host->regs->ce_int_mask);
+		goto end;
+	} else if (state & INT_ERR_STS) {
+		/* err interrupts */
+		sh_mmcif_write(~state, &host->regs->ce_int);
+		sh_mmcif_bitclr(state, &host->regs->ce_int_mask);
+		goto err;
+	} else
+		return -EAGAIN;
+
+err:
+	host->sd_error = 1;
+	debug("%s: int err state = %08x\n", DRIVER_NAME, state);
+end:
+	host->wait_int = 1;
+	return 0;
+}
+
+static int mmcif_wait_interrupt_flag(struct sh_mmcif_host *host)
+{
+	int timeout = 10000000;
+
+	while (1) {
+		timeout--;
+		if (timeout < 0) {
+			printf("timeout\n");
+			return 0;
+		}
+
+		if (!sh_mmcif_intr(host))
+			break;
+
+		udelay(1);	/* 1 usec */
+	}
+
+	return 1;	/* Return value: NOT 0 = complete waiting */
+}
+
+static void sh_mmcif_clock_control(struct sh_mmcif_host *host, unsigned int clk)
+{
+	int i;
+
+	sh_mmcif_bitclr(CLK_ENABLE, &host->regs->ce_clk_ctrl);
+	sh_mmcif_bitclr(CLK_CLEAR, &host->regs->ce_clk_ctrl);
+
+	if (!clk)
+		return;
+	if (clk == CLKDEV_EMMC_DATA) {
+		sh_mmcif_bitset(CLK_PCLK, &host->regs->ce_clk_ctrl);
+	} else {
+		for (i = 1; (unsigned int)host->clk / (1 << i) >= clk; i++)
+			;
+		sh_mmcif_bitset((i - 1) << 16, &host->regs->ce_clk_ctrl);
+	}
+	sh_mmcif_bitset(CLK_ENABLE, &host->regs->ce_clk_ctrl);
+}
+
+static void sh_mmcif_sync_reset(struct sh_mmcif_host *host)
+{
+	u32 tmp;
+
+	tmp = sh_mmcif_read(&host->regs->ce_clk_ctrl) & (CLK_ENABLE |
+							 CLK_CLEAR);
+
+	sh_mmcif_write(SOFT_RST_ON, &host->regs->ce_version);
+	sh_mmcif_write(SOFT_RST_OFF, &host->regs->ce_version);
+	sh_mmcif_bitset(tmp | SRSPTO_256 | SRBSYTO_29 | SRWDTO_29 | SCCSTO_29,
+			&host->regs->ce_clk_ctrl);
+	/* byte swap on */
+	sh_mmcif_bitset(BUF_ACC_ATYP, &host->regs->ce_buf_acc);
+}
+
+static int sh_mmcif_error_manage(struct sh_mmcif_host *host)
+{
+	u32 state1, state2;
+	int ret, timeout = 10000000;
+
+	host->sd_error = 0;
+	host->wait_int = 0;
+
+	state1 = sh_mmcif_read(&host->regs->ce_host_sts1);
+	state2 = sh_mmcif_read(&host->regs->ce_host_sts2);
+	debug("%s: ERR HOST_STS1 = %08x\n", \
+			DRIVER_NAME, sh_mmcif_read(&host->regs->ce_host_sts1));
+	debug("%s: ERR HOST_STS2 = %08x\n", \
+			DRIVER_NAME, sh_mmcif_read(&host->regs->ce_host_sts2));
+
+	if (state1 & STS1_CMDSEQ) {
+		debug("%s: Forced end of command sequence\n", DRIVER_NAME);
+		sh_mmcif_bitset(CMD_CTRL_BREAK, &host->regs->ce_cmd_ctrl);
+		sh_mmcif_bitset(~CMD_CTRL_BREAK, &host->regs->ce_cmd_ctrl);
+		while (1) {
+			timeout--;
+			if (timeout < 0) {
+				printf(DRIVER_NAME": Forceed end of " \
+					"command sequence timeout err\n");
+				return -EILSEQ;
+			}
+			if (!(sh_mmcif_read(&host->regs->ce_host_sts1)
+								& STS1_CMDSEQ))
+				break;
+		}
+		sh_mmcif_sync_reset(host);
+		return -EILSEQ;
+	}
+
+	if (state2 & STS2_CRC_ERR)
+		ret = -EILSEQ;
+	else if (state2 & STS2_TIMEOUT_ERR)
+		ret = TIMEOUT;
+	else
+		ret = -EILSEQ;
+	return ret;
+}
+
+static int sh_mmcif_single_read(struct sh_mmcif_host *host,
+				struct mmc_data *data)
+{
+	long time;
+	u32 blocksize, i;
+	unsigned long *p = (unsigned long *)data->dest;
+
+	if ((unsigned long)p & 0x00000001) {
+		printf("%s: The data pointer is unaligned.", __func__);
+		return -EIO;
+	}
+
+	host->wait_int = 0;
+
+	/* buf read enable */
+	sh_mmcif_bitset(MASK_MBUFREN, &host->regs->ce_int_mask);
+	time = mmcif_wait_interrupt_flag(host);
+	if (time == 0 || host->sd_error != 0)
+		return sh_mmcif_error_manage(host);
+
+	host->wait_int = 0;
+	blocksize = (BLOCK_SIZE_MASK &
+			sh_mmcif_read(&host->regs->ce_block_set)) + 3;
+	for (i = 0; i < blocksize / 4; i++)
+		*p++ = sh_mmcif_read(&host->regs->ce_data);
+
+	/* buffer read end */
+	sh_mmcif_bitset(MASK_MBUFRE, &host->regs->ce_int_mask);
+	time = mmcif_wait_interrupt_flag(host);
+	if (time == 0 || host->sd_error != 0)
+		return sh_mmcif_error_manage(host);
+
+	host->wait_int = 0;
+	return 0;
+}
+
+static int sh_mmcif_multi_read(struct sh_mmcif_host *host,
+				struct mmc_data *data)
+{
+	long time;
+	u32 blocksize, i, j;
+	unsigned long *p = (unsigned long *)data->dest;
+
+	if ((unsigned long)p & 0x00000001) {
+		printf("%s: The data pointer is unaligned.", __func__);
+		return -EIO;
+	}
+
+	host->wait_int = 0;
+	blocksize = BLOCK_SIZE_MASK & sh_mmcif_read(&host->regs->ce_block_set);
+	for (j = 0; j < data->blocks; j++) {
+		sh_mmcif_bitset(MASK_MBUFREN, &host->regs->ce_int_mask);
+		time = mmcif_wait_interrupt_flag(host);
+		if (time == 0 || host->sd_error != 0)
+			return sh_mmcif_error_manage(host);
+
+		host->wait_int = 0;
+		for (i = 0; i < blocksize / 4; i++)
+			*p++ = sh_mmcif_read(&host->regs->ce_data);
+
+		WATCHDOG_RESET();
+	}
+	return 0;
+}
+
+static int sh_mmcif_single_write(struct sh_mmcif_host *host,
+				 struct mmc_data *data)
+{
+	long time;
+	u32 blocksize, i;
+	const unsigned long *p = (unsigned long *)data->dest;
+
+	if ((unsigned long)p & 0x00000001) {
+		printf("%s: The data pointer is unaligned.", __func__);
+		return -EIO;
+	}
+
+	host->wait_int = 0;
+	sh_mmcif_bitset(MASK_MBUFWEN, &host->regs->ce_int_mask);
+
+	time = mmcif_wait_interrupt_flag(host);
+	if (time == 0 || host->sd_error != 0)
+		return sh_mmcif_error_manage(host);
+
+	host->wait_int = 0;
+	blocksize = (BLOCK_SIZE_MASK &
+			sh_mmcif_read(&host->regs->ce_block_set)) + 3;
+	for (i = 0; i < blocksize / 4; i++)
+		sh_mmcif_write(*p++, &host->regs->ce_data);
+
+	/* buffer write end */
+	sh_mmcif_bitset(MASK_MDTRANE, &host->regs->ce_int_mask);
+
+	time = mmcif_wait_interrupt_flag(host);
+	if (time == 0 || host->sd_error != 0)
+		return sh_mmcif_error_manage(host);
+
+	host->wait_int = 0;
+	return 0;
+}
+
+static int sh_mmcif_multi_write(struct sh_mmcif_host *host,
+				struct mmc_data *data)
+{
+	long time;
+	u32 i, j, blocksize;
+	const unsigned long *p = (unsigned long *)data->dest;
+
+	if ((unsigned long)p & 0x00000001) {
+		printf("%s: The data pointer is unaligned.", __func__);
+		return -EIO;
+	}
+
+	host->wait_int = 0;
+	blocksize = BLOCK_SIZE_MASK & sh_mmcif_read(&host->regs->ce_block_set);
+	for (j = 0; j < data->blocks; j++) {
+		sh_mmcif_bitset(MASK_MBUFWEN, &host->regs->ce_int_mask);
+
+		time = mmcif_wait_interrupt_flag(host);
+
+		if (time == 0 || host->sd_error != 0)
+			return sh_mmcif_error_manage(host);
+
+		host->wait_int = 0;
+		for (i = 0; i < blocksize / 4; i++)
+			sh_mmcif_write(*p++, &host->regs->ce_data);
+
+		WATCHDOG_RESET();
+	}
+	return 0;
+}
+
+static void sh_mmcif_get_response(struct sh_mmcif_host *host,
+					struct mmc_cmd *cmd)
+{
+	if (cmd->resp_type & MMC_RSP_136) {
+		cmd->response[0] = sh_mmcif_read(&host->regs->ce_resp3);
+		cmd->response[1] = sh_mmcif_read(&host->regs->ce_resp2);
+		cmd->response[2] = sh_mmcif_read(&host->regs->ce_resp1);
+		cmd->response[3] = sh_mmcif_read(&host->regs->ce_resp0);
+		debug(" RESP %08x, %08x, %08x, %08x\n", cmd->response[0],
+			 cmd->response[1], cmd->response[2], cmd->response[3]);
+	} else {
+		cmd->response[0] = sh_mmcif_read(&host->regs->ce_resp0);
+	}
+}
+
+static void sh_mmcif_get_cmd12response(struct sh_mmcif_host *host,
+					struct mmc_cmd *cmd)
+{
+	cmd->response[0] = sh_mmcif_read(&host->regs->ce_resp_cmd12);
+}
+
+static u32 sh_mmcif_set_cmd(struct sh_mmcif_host *host,
+				struct mmc_data *data, struct mmc_cmd *cmd)
+{
+	u32 tmp = 0;
+	u32 opc = cmd->cmdidx;
+
+	/* Response Type check */
+	switch (cmd->resp_type) {
+	case MMC_RSP_NONE:
+		tmp |= CMD_SET_RTYP_NO;
+		break;
+	case MMC_RSP_R1:
+	case MMC_RSP_R1b:
+	case MMC_RSP_R3:
+		tmp |= CMD_SET_RTYP_6B;
+		break;
+	case MMC_RSP_R2:
+		tmp |= CMD_SET_RTYP_17B;
+		break;
+	default:
+		printf(DRIVER_NAME": Not support type response.\n");
+		break;
+	}
+
+	/* RBSY */
+	if (opc == MMC_CMD_SWITCH)
+		tmp |= CMD_SET_RBSY;
+
+	/* WDAT / DATW */
+	if (host->data) {
+		tmp |= CMD_SET_WDAT;
+		switch (host->bus_width) {
+		case MMC_BUS_WIDTH_1:
+			tmp |= CMD_SET_DATW_1;
+			break;
+		case MMC_BUS_WIDTH_4:
+			tmp |= CMD_SET_DATW_4;
+			break;
+		case MMC_BUS_WIDTH_8:
+			tmp |= CMD_SET_DATW_8;
+			break;
+		default:
+			printf(DRIVER_NAME": Not support bus width.\n");
+			break;
+		}
+	}
+	/* DWEN */
+	if (opc == MMC_CMD_WRITE_SINGLE_BLOCK ||
+	    opc == MMC_CMD_WRITE_MULTIPLE_BLOCK)
+		tmp |= CMD_SET_DWEN;
+	/* CMLTE/CMD12EN */
+	if (opc == MMC_CMD_READ_MULTIPLE_BLOCK ||
+	    opc == MMC_CMD_WRITE_MULTIPLE_BLOCK) {
+		tmp |= CMD_SET_CMLTE | CMD_SET_CMD12EN;
+		sh_mmcif_bitset(data->blocks << 16, &host->regs->ce_block_set);
+	}
+	/* RIDXC[1:0] check bits */
+	if (opc == MMC_CMD_SEND_OP_COND || opc == MMC_CMD_ALL_SEND_CID ||
+	    opc == MMC_CMD_SEND_CSD || opc == MMC_CMD_SEND_CID)
+		tmp |= CMD_SET_RIDXC_BITS;
+	/* RCRC7C[1:0] check bits */
+	if (opc == MMC_CMD_SEND_OP_COND)
+		tmp |= CMD_SET_CRC7C_BITS;
+	/* RCRC7C[1:0] internal CRC7 */
+	if (opc == MMC_CMD_ALL_SEND_CID ||
+		opc == MMC_CMD_SEND_CSD || opc == MMC_CMD_SEND_CID)
+		tmp |= CMD_SET_CRC7C_INTERNAL;
+
+	return opc = ((opc << 24) | tmp);
+}
+
+static u32 sh_mmcif_data_trans(struct sh_mmcif_host *host,
+				struct mmc_data *data, u16 opc)
+{
+	u32 ret;
+
+	switch (opc) {
+	case MMC_CMD_READ_MULTIPLE_BLOCK:
+		ret = sh_mmcif_multi_read(host, data);
+		break;
+	case MMC_CMD_WRITE_MULTIPLE_BLOCK:
+		ret = sh_mmcif_multi_write(host, data);
+		break;
+	case MMC_CMD_WRITE_SINGLE_BLOCK:
+		ret = sh_mmcif_single_write(host, data);
+		break;
+	case MMC_CMD_READ_SINGLE_BLOCK:
+	case MMC_CMD_SEND_EXT_CSD:
+		ret = sh_mmcif_single_read(host, data);
+		break;
+	default:
+		printf(DRIVER_NAME": NOT SUPPORT CMD = d'%08d\n", opc);
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sh_mmcif_start_cmd(struct sh_mmcif_host *host,
+				struct mmc_data *data, struct mmc_cmd *cmd)
+{
+	long time;
+	int ret = 0, mask = 0;
+	u32 opc = cmd->cmdidx;
+
+	if (opc == MMC_CMD_STOP_TRANSMISSION) {
+		/* MMCIF sends the STOP command automatically */
+		if (host->last_cmd == MMC_CMD_READ_MULTIPLE_BLOCK)
+			sh_mmcif_bitset(MASK_MCMD12DRE,
+					&host->regs->ce_int_mask);
+		else
+			sh_mmcif_bitset(MASK_MCMD12RBE,
+					&host->regs->ce_int_mask);
+
+		time = mmcif_wait_interrupt_flag(host);
+		if (time == 0 || host->sd_error != 0)
+			return sh_mmcif_error_manage(host);
+
+		sh_mmcif_get_cmd12response(host, cmd);
+		return 0;
+	}
+	if (opc == MMC_CMD_SWITCH)
+		mask = MASK_MRBSYE;
+	else
+		mask = MASK_MCRSPE;
+
+	mask |=	MASK_MCMDVIO | MASK_MBUFVIO | MASK_MWDATERR |
+		MASK_MRDATERR | MASK_MRIDXERR | MASK_MRSPERR |
+		MASK_MCCSTO | MASK_MCRCSTO | MASK_MWDATTO |
+		MASK_MRDATTO | MASK_MRBSYTO | MASK_MRSPTO;
+
+	if (host->data) {
+		sh_mmcif_write(0, &host->regs->ce_block_set);
+		sh_mmcif_write(data->blocksize, &host->regs->ce_block_set);
+	}
+	opc = sh_mmcif_set_cmd(host, data, cmd);
+
+	sh_mmcif_write(INT_START_MAGIC, &host->regs->ce_int);
+	sh_mmcif_write(mask, &host->regs->ce_int_mask);
+
+	debug("CMD%d ARG:%08x\n", cmd->cmdidx, cmd->cmdarg);
+	/* set arg */
+	sh_mmcif_write(cmd->cmdarg, &host->regs->ce_arg);
+	host->wait_int = 0;
+	/* set cmd */
+	sh_mmcif_write(opc, &host->regs->ce_cmd_set);
+
+	time = mmcif_wait_interrupt_flag(host);
+	if (time == 0)
+		return sh_mmcif_error_manage(host);
+
+	if (host->sd_error) {
+		switch (cmd->cmdidx) {
+		case MMC_CMD_ALL_SEND_CID:
+		case MMC_CMD_SELECT_CARD:
+		case MMC_CMD_APP_CMD:
+			ret = TIMEOUT;
+			break;
+		default:
+			printf(DRIVER_NAME": Cmd(d'%d) err\n", cmd->cmdidx);
+			ret = sh_mmcif_error_manage(host);
+			break;
+		}
+		host->sd_error = 0;
+		host->wait_int = 0;
+		return ret;
+	}
+
+	/* if no response */
+	if (!(opc & 0x00C00000))
+		return 0;
+
+	if (host->wait_int == 1) {
+		sh_mmcif_get_response(host, cmd);
+		host->wait_int = 0;
+	}
+	if (host->data)
+		ret = sh_mmcif_data_trans(host, data, cmd->cmdidx);
+	host->last_cmd = cmd->cmdidx;
+
+	return ret;
+}
+
+static int sh_mmcif_request(struct mmc *mmc, struct mmc_cmd *cmd,
+			    struct mmc_data *data)
+{
+	struct sh_mmcif_host *host = mmc_priv(mmc);
+	int ret;
+
+	WATCHDOG_RESET();
+
+	switch (cmd->cmdidx) {
+	case MMC_CMD_APP_CMD:
+		return TIMEOUT;
+	case MMC_CMD_SEND_EXT_CSD: /* = SD_SEND_IF_COND (8) */
+		if (data)
+			/* ext_csd */
+			break;
+		else
+			/* send_if_cond cmd (not support) */
+			return TIMEOUT;
+	default:
+		break;
+	}
+	host->sd_error = 0;
+	host->data = data;
+	ret = sh_mmcif_start_cmd(host, data, cmd);
+	host->data = NULL;
+
+	return ret;
+}
+
+static void sh_mmcif_set_ios(struct mmc *mmc)
+{
+	struct sh_mmcif_host *host = mmc_priv(mmc);
+
+	if (mmc->clock)
+		sh_mmcif_clock_control(host, mmc->clock);
+
+	if (mmc->bus_width == 8)
+		host->bus_width = MMC_BUS_WIDTH_8;
+	else if (mmc->bus_width == 4)
+		host->bus_width = MMC_BUS_WIDTH_4;
+	else
+		host->bus_width = MMC_BUS_WIDTH_1;
+
+	debug("clock = %d, buswidth = %d\n", mmc->clock, mmc->bus_width);
+}
+
+static int sh_mmcif_init(struct mmc *mmc)
+{
+	struct sh_mmcif_host *host = mmc_priv(mmc);
+
+	sh_mmcif_sync_reset(host);
+	sh_mmcif_write(MASK_ALL, &host->regs->ce_int_mask);
+	return 0;
+}
+
+int mmcif_mmc_init(void)
+{
+	int ret = 0;
+	struct mmc *mmc;
+	struct sh_mmcif_host *host = NULL;
+
+	mmc = malloc(sizeof(struct mmc));
+	if (!mmc)
+		ret = -ENOMEM;
+	memset(mmc, 0, sizeof(*mmc));
+	host = malloc(sizeof(struct sh_mmcif_host));
+	if (!host)
+		ret = -ENOMEM;
+	memset(host, 0, sizeof(*host));
+
+	mmc->f_min = CLKDEV_MMC_INIT;
+	mmc->f_max = CLKDEV_EMMC_DATA;
+	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT |
+			 MMC_MODE_8BIT;
+	memcpy(mmc->name, DRIVER_NAME, sizeof(DRIVER_NAME));
+	mmc->send_cmd = sh_mmcif_request;
+	mmc->set_ios = sh_mmcif_set_ios;
+	mmc->init = sh_mmcif_init;
+	host->regs = (struct sh_mmcif_regs *)CONFIG_SH_MMCIF_ADDR;
+	host->clk = CONFIG_SH_MMCIF_CLK;
+	mmc->priv = host;
+
+	mmc_register(mmc);
+
+	return ret;
+}
diff -urN u-boot-2011.06/drivers/mmc/sh_mmcif.h u-boot-HEAD/drivers/mmc/sh_mmcif.h
--- u-boot-2011.06/drivers/mmc/sh_mmcif.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/mmc/sh_mmcif.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,238 @@
+/*
+ * MMCIF driver.
+ *
+ * Copyright (C)  2011 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ */
+
+#ifndef _SH_MMCIF_H_
+#define _SH_MMCIF_H_
+
+struct sh_mmcif_regs {
+	unsigned long ce_cmd_set;
+	unsigned long reserved;
+	unsigned long ce_arg;
+	unsigned long ce_arg_cmd12;
+	unsigned long ce_cmd_ctrl;
+	unsigned long ce_block_set;
+	unsigned long ce_clk_ctrl;
+	unsigned long ce_buf_acc;
+	unsigned long ce_resp3;
+	unsigned long ce_resp2;
+	unsigned long ce_resp1;
+	unsigned long ce_resp0;
+	unsigned long ce_resp_cmd12;
+	unsigned long ce_data;
+	unsigned long reserved2[2];
+	unsigned long ce_int;
+	unsigned long ce_int_mask;
+	unsigned long ce_host_sts1;
+	unsigned long ce_host_sts2;
+	unsigned long reserved3[11];
+	unsigned long ce_version;
+};
+
+/* CE_CMD_SET */
+#define CMD_MASK		0x3f000000
+#define CMD_SET_RTYP_NO		((0 << 23) | (0 << 22))
+/* R1/R1b/R3/R4/R5 */
+#define CMD_SET_RTYP_6B		((0 << 23) | (1 << 22))
+/* R2 */
+#define CMD_SET_RTYP_17B	((1 << 23) | (0 << 22))
+/* R1b */
+#define CMD_SET_RBSY		(1 << 21)
+#define CMD_SET_CCSEN		(1 << 20)
+/* 1: on data, 0: no data */
+#define CMD_SET_WDAT		(1 << 19)
+/* 1: write to card, 0: read from card */
+#define CMD_SET_DWEN		(1 << 18)
+/* 1: multi block trans, 0: single */
+#define CMD_SET_CMLTE		(1 << 17)
+/* 1: CMD12 auto issue */
+#define CMD_SET_CMD12EN		(1 << 16)
+/* index check */
+#define CMD_SET_RIDXC_INDEX	((0 << 15) | (0 << 14))
+/* check bits check */
+#define CMD_SET_RIDXC_BITS	((0 << 15) | (1 << 14))
+/* no check */
+#define CMD_SET_RIDXC_NO	((1 << 15) | (0 << 14))
+/* 1: CRC7 check*/
+#define CMD_SET_CRC7C		((0 << 13) | (0 << 12))
+/* 1: check bits check*/
+#define CMD_SET_CRC7C_BITS	((0 << 13) | (1 << 12))
+/* 1: internal CRC7 check*/
+#define CMD_SET_CRC7C_INTERNAL	((1 << 13) | (0 << 12))
+/* 1: CRC16 check*/
+#define CMD_SET_CRC16C		(1 << 10)
+/* 1: not receive CRC status */
+#define CMD_SET_CRCSTE		(1 << 8)
+/* 1: tran mission bit "Low" */
+#define CMD_SET_TBIT		(1 << 7)
+/* 1: open/drain */
+#define CMD_SET_OPDM		(1 << 6)
+#define CMD_SET_CCSH		(1 << 5)
+/* 1bit */
+#define CMD_SET_DATW_1		((0 << 1) | (0 << 0))
+/* 4bit */
+#define CMD_SET_DATW_4		((0 << 1) | (1 << 0))
+/* 8bit */
+#define CMD_SET_DATW_8		((1 << 1) | (0 << 0))
+
+/* CE_CMD_CTRL */
+#define CMD_CTRL_BREAK		(1 << 0)
+
+/* CE_BLOCK_SET */
+#define BLOCK_SIZE_MASK		0x0000ffff
+
+/* CE_CLK_CTRL */
+#define CLK_ENABLE		(1 << 24)
+#define CLK_CLEAR		((1 << 19) | (1 << 18) | (1 << 17) | (1 << 16))
+#define CLK_PCLK		((1 << 19) | (1 << 18) | (1 << 17) | (1 << 16))
+/* respons timeout */
+#define SRSPTO_256		((1 << 13) | (0 << 12))
+/* respons busy timeout */
+#define SRBSYTO_29		((1 << 11) | (1 << 10) | (1 << 9) | (1 << 8))
+/* read/write timeout */
+#define SRWDTO_29		((1 << 7) | (1 << 6) | (1 << 5) | (1 << 4))
+/* ccs timeout */
+#define SCCSTO_29		((1 << 3) | (1 << 2) | (1 << 1) | (1 << 0))
+
+/* CE_BUF_ACC */
+#define BUF_ACC_DMAWEN		(1 << 25)
+#define BUF_ACC_DMAREN		(1 << 24)
+#define BUF_ACC_BUSW_32		(0 << 17)
+#define BUF_ACC_BUSW_16		(1 << 17)
+#define BUF_ACC_ATYP		(1 << 16)
+
+/* CE_INT */
+#define INT_CCSDE		(1 << 29)
+#define INT_CMD12DRE		(1 << 26)
+#define INT_CMD12RBE		(1 << 25)
+#define INT_CMD12CRE		(1 << 24)
+#define INT_DTRANE		(1 << 23)
+#define INT_BUFRE		(1 << 22)
+#define INT_BUFWEN		(1 << 21)
+#define INT_BUFREN		(1 << 20)
+#define INT_CCSRCV		(1 << 19)
+#define INT_RBSYE		(1 << 17)
+#define INT_CRSPE		(1 << 16)
+#define INT_CMDVIO		(1 << 15)
+#define INT_BUFVIO		(1 << 14)
+#define INT_WDATERR		(1 << 11)
+#define INT_RDATERR		(1 << 10)
+#define INT_RIDXERR		(1 << 9)
+#define INT_RSPERR		(1 << 8)
+#define INT_CCSTO		(1 << 5)
+#define INT_CRCSTO		(1 << 4)
+#define INT_WDATTO		(1 << 3)
+#define INT_RDATTO		(1 << 2)
+#define INT_RBSYTO		(1 << 1)
+#define INT_RSPTO		(1 << 0)
+#define INT_ERR_STS		(INT_CMDVIO | INT_BUFVIO | INT_WDATERR |  \
+				 INT_RDATERR | INT_RIDXERR | INT_RSPERR | \
+				 INT_CCSTO | INT_CRCSTO | INT_WDATTO |	  \
+				 INT_RDATTO | INT_RBSYTO | INT_RSPTO)
+#define INT_START_MAGIC		0xD80430C0
+
+/* CE_INT_MASK */
+#define MASK_ALL		0x00000000
+#define MASK_MCCSDE		(1 << 29)
+#define MASK_MCMD12DRE		(1 << 26)
+#define MASK_MCMD12RBE		(1 << 25)
+#define MASK_MCMD12CRE		(1 << 24)
+#define MASK_MDTRANE		(1 << 23)
+#define MASK_MBUFRE		(1 << 22)
+#define MASK_MBUFWEN		(1 << 21)
+#define MASK_MBUFREN		(1 << 20)
+#define MASK_MCCSRCV		(1 << 19)
+#define MASK_MRBSYE		(1 << 17)
+#define MASK_MCRSPE		(1 << 16)
+#define MASK_MCMDVIO		(1 << 15)
+#define MASK_MBUFVIO		(1 << 14)
+#define MASK_MWDATERR		(1 << 11)
+#define MASK_MRDATERR		(1 << 10)
+#define MASK_MRIDXERR		(1 << 9)
+#define MASK_MRSPERR		(1 << 8)
+#define MASK_MCCSTO		(1 << 5)
+#define MASK_MCRCSTO		(1 << 4)
+#define MASK_MWDATTO		(1 << 3)
+#define MASK_MRDATTO		(1 << 2)
+#define MASK_MRBSYTO		(1 << 1)
+#define MASK_MRSPTO		(1 << 0)
+
+/* CE_HOST_STS1 */
+#define STS1_CMDSEQ		(1 << 31)
+
+/* CE_HOST_STS2 */
+#define STS2_CRCSTE		(1 << 31)
+#define STS2_CRC16E		(1 << 30)
+#define STS2_AC12CRCE		(1 << 29)
+#define STS2_RSPCRC7E		(1 << 28)
+#define STS2_CRCSTEBE		(1 << 27)
+#define STS2_RDATEBE		(1 << 26)
+#define STS2_AC12REBE		(1 << 25)
+#define STS2_RSPEBE		(1 << 24)
+#define STS2_AC12IDXE		(1 << 23)
+#define STS2_RSPIDXE		(1 << 22)
+#define STS2_CCSTO		(1 << 15)
+#define STS2_RDATTO		(1 << 14)
+#define STS2_DATBSYTO		(1 << 13)
+#define STS2_CRCSTTO		(1 << 12)
+#define STS2_AC12BSYTO		(1 << 11)
+#define STS2_RSPBSYTO		(1 << 10)
+#define STS2_AC12RSPTO		(1 << 9)
+#define STS2_RSPTO		(1 << 8)
+
+#define STS2_CRC_ERR		(STS2_CRCSTE | STS2_CRC16E |		\
+				 STS2_AC12CRCE | STS2_RSPCRC7E | STS2_CRCSTEBE)
+#define STS2_TIMEOUT_ERR	(STS2_CCSTO | STS2_RDATTO |		\
+				 STS2_DATBSYTO | STS2_CRCSTTO |		\
+				 STS2_AC12BSYTO | STS2_RSPBSYTO |	\
+				 STS2_AC12RSPTO | STS2_RSPTO)
+
+/* CE_VERSION */
+#define SOFT_RST_ON		(1 << 31)
+#define SOFT_RST_OFF		(0 << 31)
+
+#define CLKDEV_EMMC_DATA	52000000	/* 52MHz */
+#define	CLKDEV_MMC_INIT		400000		/* 100 - 400 KHz */
+
+#define MMC_BUS_WIDTH_1		0
+#define MMC_BUS_WIDTH_4		2
+#define MMC_BUS_WIDTH_8		3
+
+struct sh_mmcif_host {
+	struct mmc_data		*data;
+	struct sh_mmcif_regs	*regs;
+	unsigned int		clk;
+	int			bus_width;
+	u16			wait_int;
+	u16			sd_error;
+	u8			last_cmd;
+};
+
+static inline u32 sh_mmcif_read(unsigned long *reg)
+{
+	return readl(reg);
+}
+
+static inline void sh_mmcif_write(u32 val, unsigned long *reg)
+{
+	writel(val, reg);
+}
+
+static inline void sh_mmcif_bitset(u32 val, unsigned long *reg)
+{
+	sh_mmcif_write(val | sh_mmcif_read(reg), reg);
+}
+
+static inline void sh_mmcif_bitclr(u32 val, unsigned long *reg)
+{
+	sh_mmcif_write(~val & sh_mmcif_read(reg), reg);
+}
+
+#endif /* _SH_MMCIF_H_ */
diff -urN u-boot-2011.06/drivers/mmc/tegra2_mmc.c u-boot-HEAD/drivers/mmc/tegra2_mmc.c
--- u-boot-2011.06/drivers/mmc/tegra2_mmc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/mmc/tegra2_mmc.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,510 @@
+/*
+ * (C) Copyright 2009 SAMSUNG Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Jaehoon Chung <jh80.chung@samsung.com>
+ * Portions Copyright 2011 NVIDIA Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <mmc.h>
+#include <asm/io.h>
+#include <asm/arch/clk_rst.h>
+#include "tegra2_mmc.h"
+
+/* support 4 mmc hosts */
+struct mmc mmc_dev[4];
+struct mmc_host mmc_host[4];
+
+static inline struct tegra2_mmc *tegra2_get_base_mmc(int dev_index)
+{
+	unsigned long offset;
+	debug("tegra2_get_base_mmc: dev_index = %d\n", dev_index);
+
+	switch (dev_index) {
+	case 0:
+		offset = TEGRA2_SDMMC4_BASE;
+		break;
+	case 1:
+		offset = TEGRA2_SDMMC3_BASE;
+		break;
+	case 2:
+		offset = TEGRA2_SDMMC2_BASE;
+		break;
+	case 3:
+		offset = TEGRA2_SDMMC1_BASE;
+		break;
+	default:
+		offset = TEGRA2_SDMMC4_BASE;
+		break;
+	}
+
+	return (struct tegra2_mmc *)(offset);
+}
+
+static void mmc_prepare_data(struct mmc_host *host, struct mmc_data *data)
+{
+	unsigned char ctrl;
+
+	debug("data->dest: %08X, data->blocks: %u, data->blocksize: %u\n",
+	(u32)data->dest, data->blocks, data->blocksize);
+
+	writel((u32)data->dest, &host->reg->sysad);
+	/*
+	 * DMASEL[4:3]
+	 * 00 = Selects SDMA
+	 * 01 = Reserved
+	 * 10 = Selects 32-bit Address ADMA2
+	 * 11 = Selects 64-bit Address ADMA2
+	 */
+	ctrl = readb(&host->reg->hostctl);
+	ctrl &= ~(3 << 3);			/* SDMA */
+	writeb(ctrl, &host->reg->hostctl);
+
+	/* We do not handle DMA boundaries, so set it to max (512 KiB) */
+	writew((7 << 12) | (data->blocksize & 0xFFF), &host->reg->blksize);
+	writew(data->blocks, &host->reg->blkcnt);
+}
+
+static void mmc_set_transfer_mode(struct mmc_host *host, struct mmc_data *data)
+{
+	unsigned short mode;
+	debug(" mmc_set_transfer_mode called\n");
+	/*
+	 * TRNMOD
+	 * MUL1SIN0[5]	: Multi/Single Block Select
+	 * RD1WT0[4]	: Data Transfer Direction Select
+	 *	1 = read
+	 *	0 = write
+	 * ENACMD12[2]	: Auto CMD12 Enable
+	 * ENBLKCNT[1]	: Block Count Enable
+	 * ENDMA[0]	: DMA Enable
+	 */
+	mode = (1 << 1) | (1 << 0);
+	if (data->blocks > 1)
+		mode |= (1 << 5);
+	if (data->flags & MMC_DATA_READ)
+		mode |= (1 << 4);
+
+	writew(mode, &host->reg->trnmod);
+}
+
+static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
+			struct mmc_data *data)
+{
+	struct mmc_host *host = (struct mmc_host *)mmc->priv;
+	int flags, i;
+	unsigned int timeout;
+	unsigned int mask;
+	unsigned int retry = 0x100000;
+	debug(" mmc_send_cmd called\n");
+
+	/* Wait max 10 ms */
+	timeout = 10;
+
+	/*
+	 * PRNSTS
+	 * CMDINHDAT[1]	: Command Inhibit (DAT)
+	 * CMDINHCMD[0]	: Command Inhibit (CMD)
+	 */
+	mask = (1 << 0);
+	if ((data != NULL) || (cmd->resp_type & MMC_RSP_BUSY))
+		mask |= (1 << 1);
+
+	/*
+	 * We shouldn't wait for data inhibit for stop commands, even
+	 * though they might use busy signaling
+	 */
+	if (data)
+		mask &= ~(1 << 1);
+
+	while (readl(&host->reg->prnsts) & mask) {
+		if (timeout == 0) {
+			printf("%s: timeout error\n", __func__);
+			return -1;
+		}
+		timeout--;
+		udelay(1000);
+	}
+
+	if (data)
+		mmc_prepare_data(host, data);
+
+	debug("cmd->arg: %08x\n", cmd->cmdarg);
+	writel(cmd->cmdarg, &host->reg->argument);
+
+	if (data)
+		mmc_set_transfer_mode(host, data);
+
+	if ((cmd->resp_type & MMC_RSP_136) && (cmd->resp_type & MMC_RSP_BUSY))
+		return -1;
+
+	/*
+	 * CMDREG
+	 * CMDIDX[13:8]	: Command index
+	 * DATAPRNT[5]	: Data Present Select
+	 * ENCMDIDX[4]	: Command Index Check Enable
+	 * ENCMDCRC[3]	: Command CRC Check Enable
+	 * RSPTYP[1:0]
+	 *	00 = No Response
+	 *	01 = Length 136
+	 *	10 = Length 48
+	 *	11 = Length 48 Check busy after response
+	 */
+	if (!(cmd->resp_type & MMC_RSP_PRESENT))
+		flags = 0;
+	else if (cmd->resp_type & MMC_RSP_136)
+		flags = (1 << 0);
+	else if (cmd->resp_type & MMC_RSP_BUSY)
+		flags = (3 << 0);
+	else
+		flags = (2 << 0);
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		flags |= (1 << 3);
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		flags |= (1 << 4);
+	if (data)
+		flags |= (1 << 5);
+
+	debug("cmd: %d\n", cmd->cmdidx);
+
+	writew((cmd->cmdidx << 8) | flags, &host->reg->cmdreg);
+
+	for (i = 0; i < retry; i++) {
+		mask = readl(&host->reg->norintsts);
+		/* Command Complete */
+		if (mask & (1 << 0)) {
+			if (!data)
+				writel(mask, &host->reg->norintsts);
+			break;
+		}
+	}
+
+	if (i == retry) {
+		printf("%s: waiting for status update\n", __func__);
+		return TIMEOUT;
+	}
+
+	if (mask & (1 << 16)) {
+		/* Timeout Error */
+		debug("timeout: %08x cmd %d\n", mask, cmd->cmdidx);
+		return TIMEOUT;
+	} else if (mask & (1 << 15)) {
+		/* Error Interrupt */
+		debug("error: %08x cmd %d\n", mask, cmd->cmdidx);
+		return -1;
+	}
+
+	if (cmd->resp_type & MMC_RSP_PRESENT) {
+		if (cmd->resp_type & MMC_RSP_136) {
+			/* CRC is stripped so we need to do some shifting. */
+			for (i = 0; i < 4; i++) {
+				unsigned int offset =
+					(unsigned int)(&host->reg->rspreg3 - i);
+				cmd->response[i] = readl(offset) << 8;
+
+				if (i != 3) {
+					cmd->response[i] |=
+						readb(offset - 1);
+				}
+				debug("cmd->resp[%d]: %08x\n",
+						i, cmd->response[i]);
+			}
+		} else if (cmd->resp_type & MMC_RSP_BUSY) {
+			for (i = 0; i < retry; i++) {
+				/* PRNTDATA[23:20] : DAT[3:0] Line Signal */
+				if (readl(&host->reg->prnsts)
+					& (1 << 20))	/* DAT[0] */
+					break;
+			}
+
+			if (i == retry) {
+				printf("%s: card is still busy\n", __func__);
+				return TIMEOUT;
+			}
+
+			cmd->response[0] = readl(&host->reg->rspreg0);
+			debug("cmd->resp[0]: %08x\n", cmd->response[0]);
+		} else {
+			cmd->response[0] = readl(&host->reg->rspreg0);
+			debug("cmd->resp[0]: %08x\n", cmd->response[0]);
+		}
+	}
+
+	if (data) {
+		while (1) {
+			mask = readl(&host->reg->norintsts);
+
+			if (mask & (1 << 15)) {
+				/* Error Interrupt */
+				writel(mask, &host->reg->norintsts);
+				printf("%s: error during transfer: 0x%08x\n",
+						__func__, mask);
+				return -1;
+			} else if (mask & (1 << 3)) {
+				/* DMA Interrupt */
+				debug("DMA end\n");
+				break;
+			} else if (mask & (1 << 1)) {
+				/* Transfer Complete */
+				debug("r/w is done\n");
+				break;
+			}
+		}
+		writel(mask, &host->reg->norintsts);
+	}
+
+	udelay(1000);
+	return 0;
+}
+
+static void mmc_change_clock(struct mmc_host *host, uint clock)
+{
+	int div, hw_div;
+	unsigned short clk;
+	unsigned long timeout;
+	unsigned int reg, hostbase;
+	struct clk_rst_ctlr *clkrst = (struct clk_rst_ctlr *)NV_PA_CLK_RST_BASE;
+	debug(" mmc_change_clock called\n");
+
+	/* Change Tegra2 SDMMCx clock divisor here */
+	/* Source is 216MHz, PLLP_OUT0 */
+	if (clock == 0)
+		goto out;
+
+	div = 1;
+	if (clock <= 400000) {
+		hw_div = ((9-1)<<1);		/* Best match is 375KHz */
+		div = 64;
+	} else if (clock <= 20000000)
+		hw_div = ((11-1)<<1);		/* Best match is 19.6MHz */
+	else if (clock <= 26000000)
+		hw_div = ((9-1)<<1);		/* Use 24MHz */
+	else
+		hw_div = ((4-1)<<1) + 1;	/* 4.5 divisor for 48MHz */
+
+	debug("mmc_change_clock: hw_div = %d, card clock div = %d\n",
+		hw_div, div);
+
+	/* Change SDMMCx divisor */
+
+	hostbase = readl(&host->base);
+	debug("mmc_change_clock: hostbase = %08X\n", hostbase);
+
+	if (hostbase == TEGRA2_SDMMC1_BASE) {
+		reg = readl(&clkrst->crc_clk_src_sdmmc1);
+		reg &= 0xFFFFFF00;	/* divisor (7.1) = 00 */
+		reg |= hw_div;		/* n-1 */
+		writel(reg, &clkrst->crc_clk_src_sdmmc1);
+	} else if (hostbase == TEGRA2_SDMMC2_BASE) {
+		reg = readl(&clkrst->crc_clk_src_sdmmc2);
+		reg &= 0xFFFFFF00;	/* divisor (7.1) = 00 */
+		reg |= hw_div;		/* n-1 */
+		writel(reg, &clkrst->crc_clk_src_sdmmc2);
+	} else if (hostbase == TEGRA2_SDMMC3_BASE) {
+		reg = readl(&clkrst->crc_clk_src_sdmmc3);
+		reg &= 0xFFFFFF00;	/* divisor (7.1) = 00 */
+		reg |= hw_div;		/* n-1 */
+		writel(reg, &clkrst->crc_clk_src_sdmmc3);
+	} else {
+		reg = readl(&clkrst->crc_clk_src_sdmmc4);
+		reg &= 0xFFFFFF00;	/* divisor (7.1) = 00 */
+		reg |= hw_div;		/* n-1 */
+		writel(reg, &clkrst->crc_clk_src_sdmmc4);
+	}
+
+	writew(0, &host->reg->clkcon);
+
+	div >>= 1;
+	/*
+	 * CLKCON
+	 * SELFREQ[15:8]	: base clock divided by value
+	 * ENSDCLK[2]		: SD Clock Enable
+	 * STBLINTCLK[1]	: Internal Clock Stable
+	 * ENINTCLK[0]		: Internal Clock Enable
+	 */
+	clk = (div << 8) | (1 << 0);
+	writew(clk, &host->reg->clkcon);
+
+	/* Wait max 10 ms */
+	timeout = 10;
+	while (!(readw(&host->reg->clkcon) & (1 << 1))) {
+		if (timeout == 0) {
+			printf("%s: timeout error\n", __func__);
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+
+	clk |= (1 << 2);
+	writew(clk, &host->reg->clkcon);
+
+	debug("mmc_change_clock: clkcon = %08X\n", clk);
+	debug("mmc_change_clock: CLK_SOURCE_SDMMCx = %08X\n", reg);
+
+out:
+	host->clock = clock;
+}
+
+static void mmc_set_ios(struct mmc *mmc)
+{
+	struct mmc_host *host = mmc->priv;
+	unsigned char ctrl;
+	debug(" mmc_set_ios called\n");
+
+	debug("bus_width: %x, clock: %d\n", mmc->bus_width, mmc->clock);
+
+	/* Change clock first */
+
+	mmc_change_clock(host, mmc->clock);
+
+	ctrl = readb(&host->reg->hostctl);
+
+	/*
+	 * WIDE8[5]
+	 * 0 = Depend on WIDE4
+	 * 1 = 8-bit mode
+	 * WIDE4[1]
+	 * 1 = 4-bit mode
+	 * 0 = 1-bit mode
+	 */
+	if (mmc->bus_width == 8)
+		ctrl |= (1 << 5);
+	else if (mmc->bus_width == 4)
+		ctrl |= (1 << 1);
+	else
+		ctrl &= ~(1 << 1);
+
+	writeb(ctrl, &host->reg->hostctl);
+	debug("mmc_set_ios: hostctl = %08X\n", ctrl);
+}
+
+static void mmc_reset(struct mmc_host *host)
+{
+	unsigned int timeout;
+	debug(" mmc_reset called\n");
+
+	/*
+	 * RSTALL[0] : Software reset for all
+	 * 1 = reset
+	 * 0 = work
+	 */
+	writeb((1 << 0), &host->reg->swrst);
+
+	host->clock = 0;
+
+	/* Wait max 100 ms */
+	timeout = 100;
+
+	/* hw clears the bit when it's done */
+	while (readb(&host->reg->swrst) & (1 << 0)) {
+		if (timeout == 0) {
+			printf("%s: timeout error\n", __func__);
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+}
+
+static int mmc_core_init(struct mmc *mmc)
+{
+	struct mmc_host *host = (struct mmc_host *)mmc->priv;
+	unsigned int mask;
+	debug(" mmc_core_init called\n");
+
+	mmc_reset(host);
+
+	host->version = readw(&host->reg->hcver);
+	debug("host version = %x\n", host->version);
+
+	/* mask all */
+	writel(0xffffffff, &host->reg->norintstsen);
+	writel(0xffffffff, &host->reg->norintsigen);
+
+	writeb(0xe, &host->reg->timeoutcon);	/* TMCLK * 2^27 */
+	/*
+	 * NORMAL Interrupt Status Enable Register init
+	 * [5] ENSTABUFRDRDY : Buffer Read Ready Status Enable
+	 * [4] ENSTABUFWTRDY : Buffer write Ready Status Enable
+	 * [1] ENSTASTANSCMPLT : Transfre Complete Status Enable
+	 * [0] ENSTACMDCMPLT : Command Complete Status Enable
+	*/
+	mask = readl(&host->reg->norintstsen);
+	mask &= ~(0xffff);
+	mask |= (1 << 5) | (1 << 4) | (1 << 1) | (1 << 0);
+	writel(mask, &host->reg->norintstsen);
+
+	/*
+	 * NORMAL Interrupt Signal Enable Register init
+	 * [1] ENSTACMDCMPLT : Transfer Complete Signal Enable
+	 */
+	mask = readl(&host->reg->norintsigen);
+	mask &= ~(0xffff);
+	mask |= (1 << 1);
+	writel(mask, &host->reg->norintsigen);
+
+	return 0;
+}
+
+static int tegra2_mmc_initialize(int dev_index, int bus_width)
+{
+	struct mmc *mmc;
+
+	debug(" mmc_initialize called\n");
+
+	mmc = &mmc_dev[dev_index];
+
+	sprintf(mmc->name, "Tegra2 SD/MMC");
+	mmc->priv = &mmc_host[dev_index];
+	mmc->send_cmd = mmc_send_cmd;
+	mmc->set_ios = mmc_set_ios;
+	mmc->init = mmc_core_init;
+
+	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
+	if (bus_width == 8)
+		mmc->host_caps = MMC_MODE_8BIT;
+	else
+		mmc->host_caps = MMC_MODE_4BIT;
+	mmc->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+
+	/*
+	 * min freq is for card identification, and is the highest
+	 *  low-speed SDIO card frequency (actually 400KHz)
+	 * max freq is highest HS eMMC clock as per the SD/MMC spec
+	 *  (actually 52MHz)
+	 * Both of these are the closest equivalents w/216MHz source
+	 *  clock and Tegra2 SDMMC divisors.
+	 */
+	mmc->f_min = 375000;
+	mmc->f_max = 48000000;
+
+	mmc_host[dev_index].clock = 0;
+	mmc_host[dev_index].reg = tegra2_get_base_mmc(dev_index);
+	mmc_host[dev_index].base = (unsigned int)mmc_host[dev_index].reg;
+	mmc_register(mmc);
+
+	return 0;
+}
+
+int tegra2_mmc_init(int dev_index, int bus_width)
+{
+	debug(" tegra2_mmc_init: index %d, bus width %d\n",
+		dev_index, bus_width);
+	return tegra2_mmc_initialize(dev_index, bus_width);
+}
diff -urN u-boot-2011.06/drivers/mmc/tegra2_mmc.h u-boot-HEAD/drivers/mmc/tegra2_mmc.h
--- u-boot-2011.06/drivers/mmc/tegra2_mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/mmc/tegra2_mmc.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,81 @@
+/*
+ * (C) Copyright 2009 SAMSUNG Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Portions Copyright (C) 2011 NVIDIA Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __TEGRA2_MMC_H_
+#define __TEGRA2_MMC_H_
+
+#define TEGRA2_SDMMC1_BASE	0xC8000000
+#define TEGRA2_SDMMC2_BASE	0xC8000200
+#define TEGRA2_SDMMC3_BASE	0xC8000400
+#define TEGRA2_SDMMC4_BASE	0xC8000600
+
+#ifndef __ASSEMBLY__
+struct tegra2_mmc {
+	unsigned int	sysad;		/* _SYSTEM_ADDRESS_0 */
+	unsigned short	blksize;	/* _BLOCK_SIZE_BLOCK_COUNT_0 15:00 */
+	unsigned short	blkcnt;		/* _BLOCK_SIZE_BLOCK_COUNT_0 31:16 */
+	unsigned int	argument;	/* _ARGUMENT_0 */
+	unsigned short	trnmod;		/* _CMD_XFER_MODE_0 15:00 xfer mode */
+	unsigned short	cmdreg;		/* _CMD_XFER_MODE_0 31:16 cmd reg */
+	unsigned int	rspreg0;	/* _RESPONSE_R0_R1_0 CMD RESP 31:00 */
+	unsigned int	rspreg1;	/* _RESPONSE_R2_R3_0 CMD RESP 63:32 */
+	unsigned int	rspreg2;	/* _RESPONSE_R4_R5_0 CMD RESP 95:64 */
+	unsigned int	rspreg3;	/* _RESPONSE_R6_R7_0 CMD RESP 127:96 */
+	unsigned int	bdata;		/* _BUFFER_DATA_PORT_0 */
+	unsigned int	prnsts;		/* _PRESENT_STATE_0 */
+	unsigned char	hostctl;	/* _POWER_CONTROL_HOST_0 7:00 */
+	unsigned char	pwrcon;		/* _POWER_CONTROL_HOST_0 15:8 */
+	unsigned char	blkgap;		/* _POWER_CONTROL_HOST_9 23:16 */
+	unsigned char	wakcon;		/* _POWER_CONTROL_HOST_0 31:24 */
+	unsigned short	clkcon;		/* _CLOCK_CONTROL_0 15:00 */
+	unsigned char	timeoutcon;	/* _TIMEOUT_CTRL 23:16 */
+	unsigned char	swrst;		/* _SW_RESET_ 31:24 */
+	unsigned int	norintsts;	/* _INTERRUPT_STATUS_0 */
+	unsigned int	norintstsen;	/* _INTERRUPT_STATUS_ENABLE_0 */
+	unsigned int	norintsigen;	/* _INTERRUPT_SIGNAL_ENABLE_0 */
+	unsigned short	acmd12errsts;	/* _AUTO_CMD12_ERR_STATUS_0 15:00 */
+	unsigned char	res1[2];	/* _RESERVED 31:16 */
+	unsigned int	capareg;	/* _CAPABILITIES_0 */
+	unsigned char	res2[4];	/* RESERVED, offset 44h-47h */
+	unsigned int	maxcurr;	/* _MAXIMUM_CURRENT_0 */
+	unsigned char	res3[4];	/* RESERVED, offset 4Ch-4Fh */
+	unsigned short	setacmd12err;	/* offset 50h */
+	unsigned short	setinterr;	/* offset 52h */
+	unsigned char	admaerr;	/* offset 54h */
+	unsigned char	res4[3];	/* RESERVED, offset 55h-57h */
+	unsigned long	admaaddr;	/* offset 58h-5Fh */
+	unsigned char	res5[0x9c];	/* RESERVED, offset 60h-FBh */
+	unsigned short	slotintstatus;	/* offset FCh */
+	unsigned short	hcver;		/* HOST Version */
+	unsigned char	res6[0x100];	/* RESERVED, offset 100h-1FFh */
+};
+
+struct mmc_host {
+	struct tegra2_mmc *reg;
+	unsigned int version;	/* SDHCI spec. version */
+	unsigned int clock;	/* Current clock (MHz) */
+	unsigned int base;	/* Base address, SDMMC1/2/3/4 */
+};
+
+int tegra2_mmc_init(int dev_index, int bus_width);
+
+#endif	/* __ASSEMBLY__ */
+#endif	/* __TEGRA2_MMC_H_ */
diff -urN u-boot-2011.06/drivers/mtd/cfi_flash.c u-boot-HEAD/drivers/mtd/cfi_flash.c
--- u-boot-2011.06/drivers/mtd/cfi_flash.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/cfi_flash.c	2011-09-19 23:25:08.000000000 +0200
@@ -573,7 +573,9 @@
 #endif
 
 	/* Wait for command completion */
+#ifdef CONFIG_SYS_LOW_RES_TIMER
 	reset_timer();
+#endif
 	start = get_timer (0);
 	while (flash_is_busy (info, sector)) {
 		if (get_timer (start) > tout) {
@@ -662,7 +664,9 @@
 #endif
 
 	/* Wait for command completion */
+#ifdef CONFIG_SYS_LOW_RES_TIMER
 	reset_timer();
+#endif
 	start = get_timer(0);
 	while (1) {
 		switch (info->portwidth) {
@@ -1874,6 +1878,10 @@
 			    info->device_id == 0x22D7) { /* M29W800DT */
 				cfi_reverse_geometry(qry);
 			}
+		} else if (flash_read_uchar(info, info->ext_addr + 0xf) == 3) {
+			/* CFI >= 1.1, deduct from top/bottom flag */
+			/* note: ext_addr is valid since cfi_version > 0 */
+			cfi_reverse_geometry(qry);
 		}
 	}
 }
diff -urN u-boot-2011.06/drivers/mtd/nand/nand_base.c u-boot-HEAD/drivers/mtd/nand/nand_base.c
--- u-boot-2011.06/drivers/mtd/nand/nand_base.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/nand/nand_base.c	2011-09-19 23:25:08.000000000 +0200
@@ -1950,7 +1950,7 @@
 	struct nand_chip *chip = mtd->priv;
 	int ret;
 
-	/* Do not allow reads past end of device */
+	/* Do not allow writes past end of device */
 	if ((to + len) > mtd->size)
 		return -EINVAL;
 	if (!len)
diff -urN u-boot-2011.06/drivers/mtd/nand/nand_util.c u-boot-HEAD/drivers/mtd/nand/nand_util.c
--- u-boot-2011.06/drivers/mtd/nand/nand_util.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/nand/nand_util.c	2011-09-19 23:25:08.000000000 +0200
@@ -11,6 +11,9 @@
  *		nandwrite.c by Steven J. Hill (sjhill@realitydiluted.com)
  *			       and Thomas Gleixner (tglx@linutronix.de)
  *
+ * Copyright (C) 2008 Nokia Corporation: drop_ffs() function by
+ * Artem Bityutskiy <dedekind1@gmail.com> from mtd-utils
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -436,6 +439,29 @@
 	return ret;
 }
 
+#ifdef CONFIG_CMD_NAND_TRIMFFS
+static size_t drop_ffs(const nand_info_t *nand, const u_char *buf,
+			const size_t *len)
+{
+	size_t i, l = *len;
+
+	for (i = l - 1; i >= 0; i--)
+		if (buf[i] != 0xFF)
+			break;
+
+	/* The resulting length must be aligned to the minimum flash I/O size */
+	l = i + 1;
+	l = (l + nand->writesize - 1) / nand->writesize;
+	l *=  nand->writesize;
+
+	/*
+	 * since the input length may be unaligned, prevent access past the end
+	 * of the buffer
+	 */
+	return min(l, *len);
+}
+#endif
+
 /**
  * nand_write_skip_bad:
  *
@@ -448,11 +474,11 @@
  * @param offset	offset in flash
  * @param length	buffer length
  * @param buffer        buffer to read from
- * @param withoob	whether write with yaffs format
+ * @param flags		flags modifying the behaviour of the write to NAND
  * @return		0 in case of success
  */
 int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
-			u_char *buffer, int withoob)
+			u_char *buffer, int flags)
 {
 	int rval = 0, blocksize;
 	size_t left_to_write = *length;
@@ -460,7 +486,10 @@
 	int need_skip;
 
 #ifdef CONFIG_CMD_NAND_YAFFS
-	if (withoob) {
+	if (flags & WITH_YAFFS_OOB) {
+		if (flags & ~WITH_YAFFS_OOB)
+			return -EINVAL;
+
 		int pages;
 		pages = nand->erasesize / nand->writesize;
 		blocksize = (pages * nand->oobsize) + nand->erasesize;
@@ -499,7 +528,7 @@
 		return -EINVAL;
 	}
 
-	if (!need_skip) {
+	if (!need_skip && !(flags & WITH_DROP_FFS)) {
 		rval = nand_write (nand, offset, length, buffer);
 		if (rval == 0)
 			return 0;
@@ -512,7 +541,7 @@
 
 	while (left_to_write > 0) {
 		size_t block_offset = offset & (nand->erasesize - 1);
-		size_t write_size;
+		size_t write_size, truncated_write_size;
 
 		WATCHDOG_RESET ();
 
@@ -529,7 +558,7 @@
 			write_size = blocksize - block_offset;
 
 #ifdef CONFIG_CMD_NAND_YAFFS
-		if (withoob) {
+		if (flags & WITH_YAFFS_OOB) {
 			int page, pages;
 			size_t pagesize = nand->writesize;
 			size_t pagesize_oob = pagesize + nand->oobsize;
@@ -558,7 +587,15 @@
 		else
 #endif
 		{
-			rval = nand_write (nand, offset, &write_size, p_buffer);
+			truncated_write_size = write_size;
+#ifdef CONFIG_CMD_NAND_TRIMFFS
+			if (flags & WITH_DROP_FFS)
+				truncated_write_size = drop_ffs(nand, p_buffer,
+						&write_size);
+#endif
+
+			rval = nand_write(nand, offset, &truncated_write_size,
+					p_buffer);
 			offset += write_size;
 			p_buffer += write_size;
 		}
diff -urN u-boot-2011.06/drivers/mtd/nand/ndfc.c u-boot-HEAD/drivers/mtd/nand/ndfc.c
--- u-boot-2011.06/drivers/mtd/nand/ndfc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/nand/ndfc.c	2011-09-19 23:25:08.000000000 +0200
@@ -37,6 +37,13 @@
 #include <asm/io.h>
 #include <asm/ppc4xx.h>
 
+#ifndef CONFIG_SYS_NAND_BCR
+#define CONFIG_SYS_NAND_BCR 0x80002222
+#endif
+#ifndef CONFIG_SYS_NDFC_EBC0_CFG
+#define CONFIG_SYS_NDFC_EBC0_CFG 0xb8400000
+#endif
+
 /*
  * We need to store the info, which chip-select (CS) is used for the
  * chip number. For example on Sequoia NAND chip #0 uses
@@ -140,12 +147,25 @@
 
 	return 0;
 }
-#endif /* #ifndef CONFIG_NAND_SPL */
 
-#ifndef CONFIG_SYS_NAND_BCR
-#define CONFIG_SYS_NAND_BCR 0x80002222
+/*
+ * Read a byte from the NDFC.
+ */
+static uint8_t ndfc_read_byte(struct mtd_info *mtd)
+{
+
+	struct nand_chip *chip = mtd->priv;
+
+#ifdef CONFIG_SYS_NDFC_16BIT
+	return (uint8_t) readw(chip->IO_ADDR_R);
+#else
+	return readb(chip->IO_ADDR_R);
 #endif
 
+}
+
+#endif /* #ifndef CONFIG_NAND_SPL */
+
 void board_nand_select_device(struct nand_chip *nand, int chip)
 {
 	/*
@@ -198,16 +218,21 @@
 	nand->ecc.bytes = 3;
 	nand->select_chip = ndfc_select_chip;
 
+#ifdef CONFIG_SYS_NDFC_16BIT
+	nand->options |= NAND_BUSWIDTH_16;
+#endif
+
 #ifndef CONFIG_NAND_SPL
 	nand->write_buf  = ndfc_write_buf;
 	nand->verify_buf = ndfc_verify_buf;
+	nand->read_byte = ndfc_read_byte;
 
 	chip++;
 #else
 	/*
 	 * Setup EBC (CS0 only right now)
 	 */
-	mtebc(EBC0_CFG, 0xb8400000);
+	mtebc(EBC0_CFG, CONFIG_SYS_NDFC_EBC0_CFG);
 
 	mtebc(PB0CR, CONFIG_SYS_EBC_PB0CR);
 	mtebc(PB0AP, CONFIG_SYS_EBC_PB0AP);
diff -urN u-boot-2011.06/drivers/mtd/spi/eeprom_m95xxx.c u-boot-HEAD/drivers/mtd/spi/eeprom_m95xxx.c
--- u-boot-2011.06/drivers/mtd/spi/eeprom_m95xxx.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/eeprom_m95xxx.c	2011-09-19 23:25:08.000000000 +0200
@@ -75,6 +75,7 @@
 {
 	struct spi_slave *slave;
 	char buf[3];
+	ulong start;
 
 	slave = spi_setup_slave(CONFIG_DEFAULT_SPI_BUS, 1, 1000000,
 			CONFIG_DEFAULT_SPI_MODE);
@@ -102,7 +103,7 @@
 	if(spi_xfer(slave, len * 8, buffer, NULL, SPI_XFER_END))
 		return -1;
 
-	reset_timer_masked();
+	start = get_timer(0);
 	do {
 		buf[0] = SPI_EEPROM_RDSR;
 		buf[1] = 0;
@@ -111,7 +112,7 @@
 		if (!(buf[1] & 1))
 			break;
 
-	} while (get_timer_masked() < CONFIG_SYS_SPI_WRITE_TOUT);
+	} while (get_timer(start) < CONFIG_SYS_SPI_WRITE_TOUT);
 
 	if (buf[1] & 1)
 		printf ("*** spi_write: Time out while writing!\n");
diff -urN u-boot-2011.06/drivers/mtd/spi/eon.c u-boot-HEAD/drivers/mtd/spi/eon.c
--- u-boot-2011.06/drivers/mtd/spi/eon.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/eon.c	2011-09-19 23:25:08.000000000 +0200
@@ -23,8 +23,6 @@
 #define CMD_EN25Q128_DP		0xb9    /* Deep Power-down */
 #define CMD_EN25Q128_RES	0xab    /* Release from DP, and Read Signature */
 
-#define EON_ID_EN25Q128		0x18
-
 struct eon_spi_flash_params {
 	u8 idcode1;
 	u16 page_size;
@@ -34,20 +32,9 @@
 	const char *name;
 };
 
-/* spi_flash needs to be first so upper layers can free() it */
-struct eon_spi_flash {
-	struct spi_flash flash;
-	const struct eon_spi_flash_params *params;
-};
-
-static inline struct eon_spi_flash *to_eon_spi_flash(struct spi_flash *flash)
-{
-	return container_of(flash, struct eon_spi_flash, flash);
-}
-
 static const struct eon_spi_flash_params eon_spi_flash_table[] = {
 	{
-		.idcode1 = EON_ID_EN25Q128,
+		.idcode1 = 0x18,
 		.page_size = 256,
 		.pages_per_sector = 16,
 		.sectors_per_block = 16,
@@ -56,69 +43,6 @@
 	},
 };
 
-static int eon_write(struct spi_flash *flash,
-		     u32 offset, size_t len, const void *buf)
-{
-	struct eon_spi_flash *eon = to_eon_spi_flash(flash);
-	unsigned long page_addr;
-	unsigned long byte_addr;
-	unsigned long page_size;
-	size_t chunk_len;
-	size_t actual;
-	int ret;
-	u8 cmd[4];
-
-	page_size = eon->params->page_size;
-	page_addr = offset / page_size;
-	byte_addr = offset % page_size;
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	ret = 0;
-	for (actual = 0; actual < len; actual += chunk_len) {
-		chunk_len = min(len - actual, page_size - byte_addr);
-
-		cmd[0] = CMD_EN25Q128_PP;
-		cmd[1] = page_addr >> 8;
-		cmd[2] = page_addr;
-		cmd[3] = byte_addr;
-
-		debug
-		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
-		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
-
-		ret = spi_flash_cmd(flash->spi, CMD_EN25Q128_WREN, NULL, 0);
-		if (ret < 0) {
-			debug("SF: Enabling Write failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
-					  buf + actual, chunk_len);
-		if (ret < 0) {
-			debug("SF: EON Page Program failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret)
-			break;
-
-		page_addr++;
-		byte_addr = 0;
-	}
-
-	debug("SF: EON: Successfully programmed %u bytes @ 0x%x\n",
-	      len, offset);
-
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
 static int eon_erase(struct spi_flash *flash, u32 offset, size_t len)
 {
 	return spi_flash_cmd_erase(flash, CMD_EN25Q128_BE, offset, len);
@@ -127,7 +51,7 @@
 struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode)
 {
 	const struct eon_spi_flash_params *params;
-	struct eon_spi_flash *eon;
+	struct spi_flash *flash;
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(eon_spi_flash_table); ++i) {
@@ -141,23 +65,23 @@
 		return NULL;
 	}
 
-	eon = malloc(sizeof(*eon));
-	if (!eon) {
+	flash = malloc(sizeof(*flash));
+	if (!flash) {
 		debug("SF: Failed to allocate memory\n");
 		return NULL;
 	}
 
-	eon->params = params;
-	eon->flash.spi = spi;
-	eon->flash.name = params->name;
-
-	eon->flash.write = eon_write;
-	eon->flash.erase = eon_erase;
-	eon->flash.read = spi_flash_cmd_read_fast;
-	eon->flash.sector_size = params->page_size * params->pages_per_sector
+	flash->spi = spi;
+	flash->name = params->name;
+
+	flash->write = spi_flash_cmd_write_multi;
+	flash->erase = eon_erase;
+	flash->read = spi_flash_cmd_read_fast;
+	flash->page_size = params->page_size;
+	flash->sector_size = params->page_size * params->pages_per_sector
 	    * params->sectors_per_block;
-	eon->flash.size = params->page_size * params->pages_per_sector
+	flash->size = params->page_size * params->pages_per_sector
 	    * params->nr_sectors;
 
-	return &eon->flash;
+	return flash;
 }
diff -urN u-boot-2011.06/drivers/mtd/spi/macronix.c u-boot-HEAD/drivers/mtd/spi/macronix.c
--- u-boot-2011.06/drivers/mtd/spi/macronix.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/macronix.c	2011-09-19 23:25:08.000000000 +0200
@@ -58,19 +58,24 @@
 	const char *name;
 };
 
-struct macronix_spi_flash {
-	struct spi_flash flash;
-	const struct macronix_spi_flash_params *params;
-};
-
-static inline struct macronix_spi_flash *to_macronix_spi_flash(struct spi_flash
-							       *flash)
-{
-	return container_of(flash, struct macronix_spi_flash, flash);
-}
-
 static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 	{
+		.idcode = 0x2013,
+		.page_size = 256,
+		.pages_per_sector = 16,
+		.sectors_per_block = 16,
+		.nr_blocks = 8,
+		.name = "MX25L4005",
+	},
+	{
+		.idcode = 0x2014,
+		.page_size = 256,
+		.pages_per_sector = 16,
+		.sectors_per_block = 16,
+		.nr_blocks = 16,
+		.name = "MX25L8005",
+	},
+	{
 		.idcode = 0x2015,
 		.page_size = 256,
 		.pages_per_sector = 16,
@@ -112,66 +117,42 @@
 	},
 };
 
-static int macronix_write(struct spi_flash *flash,
-			  u32 offset, size_t len, const void *buf)
+static int macronix_write_status(struct spi_flash *flash, u8 sr)
 {
-	struct macronix_spi_flash *mcx = to_macronix_spi_flash(flash);
-	unsigned long page_addr;
-	unsigned long byte_addr;
-	unsigned long page_size;
-	size_t chunk_len;
-	size_t actual;
+	u8 cmd;
 	int ret;
-	u8 cmd[4];
 
-	page_size = mcx->params->page_size;
-	page_addr = offset / page_size;
-	byte_addr = offset % page_size;
+	ret = spi_flash_cmd_write_enable(flash);
+	if (ret < 0) {
+		debug("SF: enabling write failed\n");
+		return ret;
+	}
 
-	ret = spi_claim_bus(flash->spi);
+	cmd = CMD_MX25XX_WRSR;
+	ret = spi_flash_cmd_write(flash->spi, &cmd, 1, &sr, 1);
 	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
+		debug("SF: fail to write status register\n");
 		return ret;
 	}
 
-	ret = 0;
-	for (actual = 0; actual < len; actual += chunk_len) {
-		chunk_len = min(len - actual, page_size - byte_addr);
-
-		cmd[0] = CMD_MX25XX_PP;
-		cmd[1] = page_addr >> 8;
-		cmd[2] = page_addr;
-		cmd[3] = byte_addr;
-
-		debug
-		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
-		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
-
-		ret = spi_flash_cmd(flash->spi, CMD_MX25XX_WREN, NULL, 0);
-		if (ret < 0) {
-			debug("SF: Enabling Write failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
-					  buf + actual, chunk_len);
-		if (ret < 0) {
-			debug("SF: Macronix Page Program failed\n");
-			break;
-		}
+	ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+	if (ret < 0) {
+		debug("SF: write status register timed out\n");
+		return ret;
+	}
 
-		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret)
-			break;
+	return 0;
+}
 
-		page_addr++;
-		byte_addr = 0;
-	}
+static int macronix_unlock(struct spi_flash *flash)
+{
+	int ret;
 
-	debug("SF: Macronix: Successfully programmed %u bytes @ 0x%x\n",
-	      len, offset);
+	/* Enable status register writing and clear BP# bits */
+	ret = macronix_write_status(flash, 0);
+	if (ret)
+		debug("SF: fail to disable write protection\n");
 
-	spi_release_bus(flash->spi);
 	return ret;
 }
 
@@ -183,7 +164,7 @@
 struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode)
 {
 	const struct macronix_spi_flash_params *params;
-	struct macronix_spi_flash *mcx;
+	struct spi_flash *flash;
 	unsigned int i;
 	u16 id = idcode[2] | idcode[1] << 8;
 
@@ -198,22 +179,25 @@
 		return NULL;
 	}
 
-	mcx = malloc(sizeof(*mcx));
-	if (!mcx) {
+	flash = malloc(sizeof(*flash));
+	if (!flash) {
 		debug("SF: Failed to allocate memory\n");
 		return NULL;
 	}
 
-	mcx->params = params;
-	mcx->flash.spi = spi;
-	mcx->flash.name = params->name;
-
-	mcx->flash.write = macronix_write;
-	mcx->flash.erase = macronix_erase;
-	mcx->flash.read = spi_flash_cmd_read_fast;
-	mcx->flash.sector_size = params->page_size * params->pages_per_sector
+	flash->spi = spi;
+	flash->name = params->name;
+
+	flash->write = spi_flash_cmd_write_multi;
+	flash->erase = macronix_erase;
+	flash->read = spi_flash_cmd_read_fast;
+	flash->page_size = params->page_size;
+	flash->sector_size = params->page_size * params->pages_per_sector
 		* params->sectors_per_block;
-	mcx->flash.size = mcx->flash.sector_size * params->nr_blocks;
+	flash->size = flash->sector_size * params->nr_blocks;
+
+	/* Clear BP# bits for read-only flash */
+	macronix_unlock(flash);
 
-	return &mcx->flash;
+	return flash;
 }
diff -urN u-boot-2011.06/drivers/mtd/spi/ramtron.c u-boot-HEAD/drivers/mtd/spi/ramtron.c
--- u-boot-2011.06/drivers/mtd/spi/ramtron.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/ramtron.c	2011-09-19 23:25:08.000000000 +0200
@@ -198,7 +198,7 @@
 
 	if (command == CMD_RAMTRON_WRITE) {
 		/* send WREN */
-		ret = spi_flash_cmd(flash->spi, CMD_RAMTRON_WREN, NULL, 0);
+		ret = spi_flash_cmd_write_enable(flash);
 		if (ret < 0) {
 			debug("SF: Enabling Write failed\n");
 			goto releasebus;
diff -urN u-boot-2011.06/drivers/mtd/spi/spansion.c u-boot-HEAD/drivers/mtd/spi/spansion.c
--- u-boot-2011.06/drivers/mtd/spi/spansion.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/spansion.c	2011-09-19 23:25:08.000000000 +0200
@@ -53,6 +53,7 @@
 #define SPSN_EXT_ID_S25FL128P_256KB	0x0300
 #define SPSN_EXT_ID_S25FL128P_64KB	0x0301
 #define SPSN_EXT_ID_S25FL032P		0x4d00
+#define SPSN_EXT_ID_S25FL129P		0x4d01
 
 struct spansion_spi_flash_params {
 	u16 idcode1;
@@ -63,17 +64,6 @@
 	const char *name;
 };
 
-struct spansion_spi_flash {
-	struct spi_flash flash;
-	const struct spansion_spi_flash_params *params;
-};
-
-static inline struct spansion_spi_flash *to_spansion_spi_flash(struct spi_flash
-							     *flash)
-{
-	return container_of(flash, struct spansion_spi_flash, flash);
-}
-
 static const struct spansion_spi_flash_params spansion_spi_flash_table[] = {
 	{
 		.idcode1 = SPSN_ID_S25FL008A,
@@ -131,71 +121,16 @@
 		.nr_sectors = 64,
 		.name = "S25FL032P",
 	},
+	{
+		.idcode1 = SPSN_ID_S25FL128P,
+		.idcode2 = SPSN_EXT_ID_S25FL129P,
+		.page_size = 256,
+		.pages_per_sector = 256,
+		.nr_sectors = 256,
+		.name = "S25FL129P_64K",
+	},
 };
 
-static int spansion_write(struct spi_flash *flash,
-			 u32 offset, size_t len, const void *buf)
-{
-	struct spansion_spi_flash *spsn = to_spansion_spi_flash(flash);
-	unsigned long page_addr;
-	unsigned long byte_addr;
-	unsigned long page_size;
-	size_t chunk_len;
-	size_t actual;
-	int ret;
-	u8 cmd[4];
-
-	page_size = spsn->params->page_size;
-	page_addr = offset / page_size;
-	byte_addr = offset % page_size;
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	ret = 0;
-	for (actual = 0; actual < len; actual += chunk_len) {
-		chunk_len = min(len - actual, page_size - byte_addr);
-
-		cmd[0] = CMD_S25FLXX_PP;
-		cmd[1] = page_addr >> 8;
-		cmd[2] = page_addr;
-		cmd[3] = byte_addr;
-
-		debug
-		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
-		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
-
-		ret = spi_flash_cmd(flash->spi, CMD_S25FLXX_WREN, NULL, 0);
-		if (ret < 0) {
-			debug("SF: Enabling Write failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
-					  buf + actual, chunk_len);
-		if (ret < 0) {
-			debug("SF: SPANSION Page Program failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret)
-			break;
-
-		page_addr++;
-		byte_addr = 0;
-	}
-
-	debug("SF: SPANSION: Successfully programmed %u bytes @ 0x%x\n",
-	      len, offset);
-
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
 static int spansion_erase(struct spi_flash *flash, u32 offset, size_t len)
 {
 	return spi_flash_cmd_erase(flash, CMD_S25FLXX_SE, offset, len);
@@ -204,7 +139,7 @@
 struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode)
 {
 	const struct spansion_spi_flash_params *params;
-	struct spansion_spi_flash *spsn;
+	struct spi_flash *flash;
 	unsigned int i;
 	unsigned short jedec, ext_jedec;
 
@@ -224,21 +159,21 @@
 		return NULL;
 	}
 
-	spsn = malloc(sizeof(struct spansion_spi_flash));
-	if (!spsn) {
+	flash = malloc(sizeof(*flash));
+	if (!flash) {
 		debug("SF: Failed to allocate memory\n");
 		return NULL;
 	}
 
-	spsn->params = params;
-	spsn->flash.spi = spi;
-	spsn->flash.name = params->name;
-
-	spsn->flash.write = spansion_write;
-	spsn->flash.erase = spansion_erase;
-	spsn->flash.read = spi_flash_cmd_read_fast;
-	spsn->flash.sector_size = params->page_size * params->pages_per_sector;
-	spsn->flash.size = spsn->flash.sector_size * params->nr_sectors;
+	flash->spi = spi;
+	flash->name = params->name;
+
+	flash->write = spi_flash_cmd_write_multi;
+	flash->erase = spansion_erase;
+	flash->read = spi_flash_cmd_read_fast;
+	flash->page_size = params->page_size;
+	flash->sector_size = params->page_size * params->pages_per_sector;
+	flash->size = flash->sector_size * params->nr_sectors;
 
-	return &spsn->flash;
+	return flash;
 }
diff -urN u-boot-2011.06/drivers/mtd/spi/spi_flash.c u-boot-HEAD/drivers/mtd/spi/spi_flash.c
--- u-boot-2011.06/drivers/mtd/spi/spi_flash.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/spi_flash.c	2011-09-19 23:25:08.000000000 +0200
@@ -65,6 +65,63 @@
 	return spi_flash_read_write(spi, cmd, cmd_len, data, NULL, data_len);
 }
 
+int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
+		size_t len, const void *buf)
+{
+	unsigned long page_addr, byte_addr, page_size;
+	size_t chunk_len, actual;
+	int ret;
+	u8 cmd[4];
+
+	page_size = flash->page_size;
+	page_addr = offset / page_size;
+	byte_addr = offset % page_size;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: unable to claim SPI bus\n");
+		return ret;
+	}
+
+	cmd[0] = CMD_PAGE_PROGRAM;
+	for (actual = 0; actual < len; actual += chunk_len) {
+		chunk_len = min(len - actual, page_size - byte_addr);
+
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr;
+		cmd[3] = byte_addr;
+
+		debug("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %zu\n",
+		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+
+		ret = spi_flash_cmd_write_enable(flash);
+		if (ret < 0) {
+			debug("SF: enabling write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+					  buf + actual, chunk_len);
+		if (ret < 0) {
+			debug("SF: write failed\n");
+			break;
+		}
+
+		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
+		if (ret)
+			break;
+
+		page_addr++;
+		byte_addr = 0;
+	}
+
+	debug("SF: program %s %zu bytes @ %#x\n",
+	      ret ? "failure" : "success", len, offset);
+
+	spi_release_bus(flash->spi);
+	return ret;
+}
+
 int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
 		size_t cmd_len, void *data, size_t data_len)
 {
@@ -163,7 +220,7 @@
 		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
 		      cmd[2], cmd[3], offset);
 
-		ret = spi_flash_cmd(flash->spi, CMD_WRITE_ENABLE, NULL, 0);
+		ret = spi_flash_cmd_write_enable(flash);
 		if (ret)
 			goto out;
 
diff -urN u-boot-2011.06/drivers/mtd/spi/spi_flash_internal.h u-boot-HEAD/drivers/mtd/spi/spi_flash_internal.h
--- u-boot-2011.06/drivers/mtd/spi/spi_flash_internal.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/spi_flash_internal.h	2011-09-19 23:25:08.000000000 +0200
@@ -19,6 +19,8 @@
 #define CMD_READ_ARRAY_FAST		0x0b
 #define CMD_READ_ARRAY_LEGACY		0xe8
 
+#define CMD_PAGE_PROGRAM		0x02
+#define CMD_WRITE_DISABLE		0x04
 #define CMD_READ_STATUS			0x05
 #define CMD_WRITE_ENABLE		0x06
 
@@ -46,6 +48,29 @@
 		const void *data, size_t data_len);
 
 /*
+ * Write the requested data out breaking it up into multiple write
+ * commands as needed per the write size.
+ */
+int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
+		size_t len, const void *buf);
+
+/*
+ * Enable writing on the SPI flash.
+ */
+static inline int spi_flash_cmd_write_enable(struct spi_flash *flash)
+{
+	return spi_flash_cmd(flash->spi, CMD_WRITE_ENABLE, NULL, 0);
+}
+
+/*
+ * Disable writing on the SPI flash.
+ */
+static inline int spi_flash_cmd_write_disable(struct spi_flash *flash)
+{
+	return spi_flash_cmd(flash->spi, CMD_WRITE_DISABLE, NULL, 0);
+}
+
+/*
  * Same as spi_flash_cmd_read() except it also claims/releases the SPI
  * bus. Used as common part of the ->read() operation.
  */
diff -urN u-boot-2011.06/drivers/mtd/spi/sst.c u-boot-HEAD/drivers/mtd/spi/sst.c
--- u-boot-2011.06/drivers/mtd/spi/sst.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/sst.c	2011-09-19 23:25:08.000000000 +0200
@@ -36,8 +36,12 @@
 #define SST_SR_AAI		(1 << 6)	/* Addressing mode */
 #define SST_SR_BPL		(1 << 7)	/* BP bits lock */
 
+#define SST_FEAT_WP		(1 << 0)	/* Supports AAI word program */
+#define SST_FEAT_MBP		(1 << 1)	/* Supports multibyte program */
+
 struct sst_spi_flash_params {
 	u8 idcode1;
+	u8 flags;
 	u16 nr_sectors;
 	const char *name;
 };
@@ -53,41 +57,51 @@
 }
 
 #define SST_SECTOR_SIZE (4 * 1024)
+#define SST_PAGE_SIZE   256
 static const struct sst_spi_flash_params sst_spi_flash_table[] = {
 	{
 		.idcode1 = 0x8d,
+		.flags = SST_FEAT_WP,
 		.nr_sectors = 128,
 		.name = "SST25VF040B",
 	},{
 		.idcode1 = 0x8e,
+		.flags = SST_FEAT_WP,
 		.nr_sectors = 256,
 		.name = "SST25VF080B",
 	},{
 		.idcode1 = 0x41,
+		.flags = SST_FEAT_WP,
 		.nr_sectors = 512,
 		.name = "SST25VF016B",
 	},{
 		.idcode1 = 0x4a,
+		.flags = SST_FEAT_WP,
 		.nr_sectors = 1024,
 		.name = "SST25VF032B",
 	},{
 		.idcode1 = 0x4b,
+		.flags = SST_FEAT_MBP,
 		.nr_sectors = 2048,
 		.name = "SST25VF064C",
 	},{
 		.idcode1 = 0x01,
+		.flags = SST_FEAT_WP,
 		.nr_sectors = 16,
 		.name = "SST25WF512",
 	},{
 		.idcode1 = 0x02,
+		.flags = SST_FEAT_WP,
 		.nr_sectors = 32,
 		.name = "SST25WF010",
 	},{
 		.idcode1 = 0x03,
+		.flags = SST_FEAT_WP,
 		.nr_sectors = 64,
 		.name = "SST25WF020",
 	},{
 		.idcode1 = 0x04,
+		.flags = SST_FEAT_WP,
 		.nr_sectors = 128,
 		.name = "SST25WF040",
 	},
@@ -96,7 +110,7 @@
 static int
 sst_enable_writing(struct spi_flash *flash)
 {
-	int ret = spi_flash_cmd(flash->spi, CMD_SST_WREN, NULL, 0);
+	int ret = spi_flash_cmd_write_enable(flash);
 	if (ret)
 		debug("SF: Enabling Write failed\n");
 	return ret;
@@ -105,7 +119,7 @@
 static int
 sst_disable_writing(struct spi_flash *flash)
 {
-	int ret = spi_flash_cmd(flash->spi, CMD_SST_WRDI, NULL, 0);
+	int ret = spi_flash_cmd_write_disable(flash);
 	if (ret)
 		debug("SF: Disabling Write failed\n");
 	return ret;
@@ -137,7 +151,7 @@
 }
 
 static int
-sst_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
+sst_write_wp(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
 {
 	size_t actual, cmd_len;
 	int ret;
@@ -257,9 +271,13 @@
 	stm->flash.spi = spi;
 	stm->flash.name = params->name;
 
-	stm->flash.write = sst_write;
+	if (stm->params->flags & SST_FEAT_WP)
+		stm->flash.write = sst_write_wp;
+	else
+		stm->flash.write = spi_flash_cmd_write_multi;
 	stm->flash.erase = sst_erase;
 	stm->flash.read = spi_flash_cmd_read_fast;
+	stm->flash.page_size = SST_PAGE_SIZE;
 	stm->flash.sector_size = SST_SECTOR_SIZE;
 	stm->flash.size = stm->flash.sector_size * params->nr_sectors;
 
diff -urN u-boot-2011.06/drivers/mtd/spi/stmicro.c u-boot-HEAD/drivers/mtd/spi/stmicro.c
--- u-boot-2011.06/drivers/mtd/spi/stmicro.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/stmicro.c	2011-09-19 23:25:08.000000000 +0200
@@ -46,15 +46,6 @@
 #define CMD_M25PXX_DP		0xb9	/* Deep Power-down */
 #define CMD_M25PXX_RES		0xab	/* Release from DP, and Read Signature */
 
-#define STM_ID_M25P10		0x11
-#define STM_ID_M25P16		0x15
-#define STM_ID_M25P20		0x12
-#define STM_ID_M25P32		0x16
-#define STM_ID_M25P40		0x13
-#define STM_ID_M25P64		0x17
-#define STM_ID_M25P80		0x14
-#define STM_ID_M25P128		0x18
-
 struct stmicro_spi_flash_params {
 	u8 idcode1;
 	u16 page_size;
@@ -63,70 +54,58 @@
 	const char *name;
 };
 
-/* spi_flash needs to be first so upper layers can free() it */
-struct stmicro_spi_flash {
-	struct spi_flash flash;
-	const struct stmicro_spi_flash_params *params;
-};
-
-static inline struct stmicro_spi_flash *to_stmicro_spi_flash(struct spi_flash
-							     *flash)
-{
-	return container_of(flash, struct stmicro_spi_flash, flash);
-}
-
 static const struct stmicro_spi_flash_params stmicro_spi_flash_table[] = {
 	{
-		.idcode1 = STM_ID_M25P10,
+		.idcode1 = 0x11,
 		.page_size = 256,
 		.pages_per_sector = 128,
 		.nr_sectors = 4,
 		.name = "M25P10",
 	},
 	{
-		.idcode1 = STM_ID_M25P16,
+		.idcode1 = 0x15,
 		.page_size = 256,
 		.pages_per_sector = 256,
 		.nr_sectors = 32,
 		.name = "M25P16",
 	},
 	{
-		.idcode1 = STM_ID_M25P20,
+		.idcode1 = 0x12,
 		.page_size = 256,
 		.pages_per_sector = 256,
 		.nr_sectors = 4,
 		.name = "M25P20",
 	},
 	{
-		.idcode1 = STM_ID_M25P32,
+		.idcode1 = 0x16,
 		.page_size = 256,
 		.pages_per_sector = 256,
 		.nr_sectors = 64,
 		.name = "M25P32",
 	},
 	{
-		.idcode1 = STM_ID_M25P40,
+		.idcode1 = 0x13,
 		.page_size = 256,
 		.pages_per_sector = 256,
 		.nr_sectors = 8,
 		.name = "M25P40",
 	},
 	{
-		.idcode1 = STM_ID_M25P64,
+		.idcode1 = 0x17,
 		.page_size = 256,
 		.pages_per_sector = 256,
 		.nr_sectors = 128,
 		.name = "M25P64",
 	},
 	{
-		.idcode1 = STM_ID_M25P80,
+		.idcode1 = 0x14,
 		.page_size = 256,
 		.pages_per_sector = 256,
 		.nr_sectors = 16,
 		.name = "M25P80",
 	},
 	{
-		.idcode1 = STM_ID_M25P128,
+		.idcode1 = 0x18,
 		.page_size = 256,
 		.pages_per_sector = 1024,
 		.nr_sectors = 64,
@@ -134,69 +113,6 @@
 	},
 };
 
-static int stmicro_write(struct spi_flash *flash,
-			 u32 offset, size_t len, const void *buf)
-{
-	struct stmicro_spi_flash *stm = to_stmicro_spi_flash(flash);
-	unsigned long page_addr;
-	unsigned long byte_addr;
-	unsigned long page_size;
-	size_t chunk_len;
-	size_t actual;
-	int ret;
-	u8 cmd[4];
-
-	page_size = stm->params->page_size;
-	page_addr = offset / page_size;
-	byte_addr = offset % page_size;
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	ret = 0;
-	for (actual = 0; actual < len; actual += chunk_len) {
-		chunk_len = min(len - actual, page_size - byte_addr);
-
-		cmd[0] = CMD_M25PXX_PP;
-		cmd[1] = page_addr >> 8;
-		cmd[2] = page_addr;
-		cmd[3] = byte_addr;
-
-		debug
-		    ("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
-		     buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
-
-		ret = spi_flash_cmd(flash->spi, CMD_M25PXX_WREN, NULL, 0);
-		if (ret < 0) {
-			debug("SF: Enabling Write failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
-					  buf + actual, chunk_len);
-		if (ret < 0) {
-			debug("SF: STMicro Page Program failed\n");
-			break;
-		}
-
-		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret)
-			break;
-
-		page_addr++;
-		byte_addr = 0;
-	}
-
-	debug("SF: STMicro: Successfully programmed %u bytes @ 0x%x\n",
-	      len, offset);
-
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
 static int stmicro_erase(struct spi_flash *flash, u32 offset, size_t len)
 {
 	return spi_flash_cmd_erase(flash, CMD_M25PXX_SE, offset, len);
@@ -205,7 +121,7 @@
 struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 * idcode)
 {
 	const struct stmicro_spi_flash_params *params;
-	struct stmicro_spi_flash *stm;
+	struct spi_flash *flash;
 	unsigned int i;
 
 	if (idcode[0] == 0xff) {
@@ -233,21 +149,21 @@
 		return NULL;
 	}
 
-	stm = malloc(sizeof(struct stmicro_spi_flash));
-	if (!stm) {
+	flash = malloc(sizeof(*flash));
+	if (!flash) {
 		debug("SF: Failed to allocate memory\n");
 		return NULL;
 	}
 
-	stm->params = params;
-	stm->flash.spi = spi;
-	stm->flash.name = params->name;
-
-	stm->flash.write = stmicro_write;
-	stm->flash.erase = stmicro_erase;
-	stm->flash.read = spi_flash_cmd_read_fast;
-	stm->flash.sector_size = params->page_size * params->pages_per_sector;
-	stm->flash.size = stm->flash.sector_size * params->nr_sectors;
+	flash->spi = spi;
+	flash->name = params->name;
+
+	flash->write = spi_flash_cmd_write_multi;
+	flash->erase = stmicro_erase;
+	flash->read = spi_flash_cmd_read_fast;
+	flash->page_size = params->page_size;
+	flash->sector_size = params->page_size * params->pages_per_sector;
+	flash->size = flash->sector_size * params->nr_sectors;
 
-	return &stm->flash;
+	return flash;
 }
diff -urN u-boot-2011.06/drivers/mtd/spi/winbond.c u-boot-HEAD/drivers/mtd/spi/winbond.c
--- u-boot-2011.06/drivers/mtd/spi/winbond.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/mtd/spi/winbond.c	2011-09-19 23:25:08.000000000 +0200
@@ -34,20 +34,16 @@
 	const char	*name;
 };
 
-/* spi_flash needs to be first so upper layers can free() it */
-struct winbond_spi_flash {
-	struct spi_flash flash;
-	const struct winbond_spi_flash_params *params;
-};
-
-static inline struct winbond_spi_flash *
-to_winbond_spi_flash(struct spi_flash *flash)
-{
-	return container_of(flash, struct winbond_spi_flash, flash);
-}
-
 static const struct winbond_spi_flash_params winbond_spi_flash_table[] = {
 	{
+		.id			= 0x3013,
+		.l2_page_size		= 8,
+		.pages_per_sector	= 16,
+		.sectors_per_block	= 16,
+		.nr_blocks		= 8,
+		.name			= "W25X40",
+	},
+	{
 		.id			= 0x3015,
 		.l2_page_size		= 8,
 		.pages_per_sector	= 16,
@@ -105,71 +101,6 @@
 	},
 };
 
-static int winbond_write(struct spi_flash *flash,
-		u32 offset, size_t len, const void *buf)
-{
-	struct winbond_spi_flash *stm = to_winbond_spi_flash(flash);
-	unsigned long page_addr;
-	unsigned long byte_addr;
-	unsigned long page_size;
-	unsigned int page_shift;
-	size_t chunk_len;
-	size_t actual;
-	int ret;
-	u8 cmd[4];
-
-	page_shift = stm->params->l2_page_size;
-	page_size = (1 << page_shift);
-	page_addr = offset / page_size;
-	byte_addr = offset % page_size;
-
-	ret = spi_claim_bus(flash->spi);
-	if (ret) {
-		debug("SF: Unable to claim SPI bus\n");
-		return ret;
-	}
-
-	for (actual = 0; actual < len; actual += chunk_len) {
-		chunk_len = min(len - actual, page_size - byte_addr);
-
-		cmd[0] = CMD_W25_PP;
-		cmd[1] = page_addr >> (16 - page_shift);
-		cmd[2] = page_addr << (page_shift - 8) | (byte_addr >> 8);
-		cmd[3] = byte_addr;
-		debug("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %d\n",
-			buf + actual,
-			cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
-
-		ret = spi_flash_cmd(flash->spi, CMD_W25_WREN, NULL, 0);
-		if (ret < 0) {
-			debug("SF: Enabling Write failed\n");
-			goto out;
-		}
-
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
-				buf + actual, chunk_len);
-		if (ret < 0) {
-			debug("SF: Winbond Page Program failed\n");
-			goto out;
-		}
-
-		ret = spi_flash_cmd_wait_ready(flash, SPI_FLASH_PROG_TIMEOUT);
-		if (ret)
-			goto out;
-
-		page_addr++;
-		byte_addr = 0;
-	}
-
-	debug("SF: Winbond: Successfully programmed %u bytes @ 0x%x\n",
-			len, offset);
-	ret = 0;
-
-out:
-	spi_release_bus(flash->spi);
-	return ret;
-}
-
 static int winbond_erase(struct spi_flash *flash, u32 offset, size_t len)
 {
 	return spi_flash_cmd_erase(flash, CMD_W25_SE, offset, len);
@@ -178,9 +109,9 @@
 struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode)
 {
 	const struct winbond_spi_flash_params *params;
-	unsigned page_size;
-	struct winbond_spi_flash *stm;
+	struct spi_flash *flash;
 	unsigned int i;
+	unsigned page_size;
 
 	for (i = 0; i < ARRAY_SIZE(winbond_spi_flash_table); i++) {
 		params = &winbond_spi_flash_table[i];
@@ -194,27 +125,26 @@
 		return NULL;
 	}
 
-	stm = malloc(sizeof(struct winbond_spi_flash));
-	if (!stm) {
+	flash = malloc(sizeof(*flash));
+	if (!flash) {
 		debug("SF: Failed to allocate memory\n");
 		return NULL;
 	}
 
-	stm->params = params;
-	stm->flash.spi = spi;
-	stm->flash.name = params->name;
+	flash->spi = spi;
+	flash->name = params->name;
 
 	/* Assuming power-of-two page size initially. */
 	page_size = 1 << params->l2_page_size;
 
-	stm->flash.write = winbond_write;
-	stm->flash.erase = winbond_erase;
-	stm->flash.read = spi_flash_cmd_read_fast;
-	stm->flash.sector_size = (1 << stm->params->l2_page_size) *
-		stm->params->pages_per_sector;
-	stm->flash.size = page_size * params->pages_per_sector
+	flash->write = spi_flash_cmd_write_multi;
+	flash->erase = winbond_erase;
+	flash->read = spi_flash_cmd_read_fast;
+	flash->page_size = page_size;
+	flash->sector_size = page_size * params->pages_per_sector;
+	flash->size = page_size * params->pages_per_sector
 				* params->sectors_per_block
 				* params->nr_blocks;
 
-	return &stm->flash;
+	return flash;
 }
diff -urN u-boot-2011.06/drivers/net/4xx_enet.c u-boot-HEAD/drivers/net/4xx_enet.c
--- u-boot-2011.06/drivers/net/4xx_enet.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/4xx_enet.c	2011-09-19 23:25:08.000000000 +0200
@@ -1704,7 +1704,7 @@
 			rc = 0;
 		}
 
-		/* handle MAL RX EOB interupt from a receive */
+		/* handle MAL RX EOB interrupt from a receive */
 		/* check for EOB on valid channels	     */
 		if (uic_mal & UIC_MAL_RXEOB) {
 			mal_eob = mfdcr(MAL0_RXEOBISR);
@@ -2035,6 +2035,13 @@
 		dev->send = ppc_4xx_eth_send;
 		dev->recv = ppc_4xx_eth_rx;
 
+		eth_register(dev);
+
+#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
+		miiphy_register(dev->name,
+				emac4xx_miiphy_read, emac4xx_miiphy_write);
+#endif
+
 		if (0 == virgin) {
 			/* set the MAL IER ??? names may change with new spec ??? */
 #if defined(CONFIG_440SPE) || \
@@ -2072,13 +2079,6 @@
 					     dev);
 			virgin = 1;
 		}
-
-		eth_register (dev);
-
-#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
-		miiphy_register (dev->name,
-				 emac4xx_miiphy_read, emac4xx_miiphy_write);
-#endif
 	}			/* end for each supported device */
 
 	return 0;
diff -urN u-boot-2011.06/drivers/net/davinci_emac.c u-boot-HEAD/drivers/net/davinci_emac.c
--- u-boot-2011.06/drivers/net/davinci_emac.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/davinci_emac.c	2011-09-19 23:25:08.000000000 +0200
@@ -457,7 +457,7 @@
 
 	if (ch == EMAC_CH_TX) {
 		/* Init TX channel teardown */
-		writel(1, &adap_emac->TXTEARDOWN);
+		writel(0, &adap_emac->TXTEARDOWN);
 		do {
 			/*
 			 * Wait here for Tx teardown completion interrupt to
@@ -476,7 +476,7 @@
 		writel(0, &adap_emac->TX0HDP);
 	} else {
 		/* Init RX channel teardown */
-		writel(1, &adap_emac->RXTEARDOWN);
+		writel(0, &adap_emac->RXTEARDOWN);
 		do {
 			/*
 			 * Wait here for Rx teardown completion interrupt to
diff -urN u-boot-2011.06/drivers/net/designware.c u-boot-HEAD/drivers/net/designware.c
--- u-boot-2011.06/drivers/net/designware.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/designware.c	2011-09-19 23:25:08.000000000 +0200
@@ -368,11 +368,13 @@
 {
 	struct dw_eth_dev *priv = dev->priv;
 	int phy_addr;
-	u16 bmcr, ctrl;
+	u16 bmcr;
 #if defined(CONFIG_DW_AUTONEG)
 	u16 bmsr;
 	u32 timeout;
 	u16 anlpar, btsr;
+#else
+	u16 ctrl;
 #endif
 
 #if defined(CONFIG_DW_SEARCH_PHY)
@@ -381,6 +383,8 @@
 		priv->address = phy_addr;
 	else
 		return -1;
+#else
+	phy_addr = priv->address;
 #endif
 	if (dw_reset_phy(dev) < 0)
 		return -1;
@@ -500,7 +504,7 @@
 	dev->iobase = (int)base_addr;
 	dev->priv = priv;
 
-	eth_getenv_enetaddr_by_index(id, &dev->enetaddr[0]);
+	eth_getenv_enetaddr_by_index("eth", id, &dev->enetaddr[0]);
 
 	priv->dev = dev;
 	priv->mac_regs_p = (struct eth_mac_regs *)base_addr;
diff -urN u-boot-2011.06/drivers/net/fec_mxc.c u-boot-HEAD/drivers/net/fec_mxc.c
--- u-boot-2011.06/drivers/net/fec_mxc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/fec_mxc.c	2011-09-19 23:25:08.000000000 +0200
@@ -86,7 +86,7 @@
 	/*
 	 * wait for the related interrupt
 	 */
-	start = get_timer_masked();
+	start = get_timer(0);
 	while (!(readl(&fec->eth->ievent) & FEC_IEVENT_MII)) {
 		if (get_timer(start) > (CONFIG_SYS_HZ / 1000)) {
 			printf("Read MDIO failed...\n");
@@ -138,7 +138,7 @@
 	/*
 	 * wait for the MII interrupt
 	 */
-	start = get_timer_masked();
+	start = get_timer(0);
 	while (!(readl(&fec->eth->ievent) & FEC_IEVENT_MII)) {
 		if (get_timer(start) > (CONFIG_SYS_HZ / 1000)) {
 			printf("Write MDIO failed...\n");
@@ -189,7 +189,7 @@
 	/*
 	 * Wait for AN completion
 	 */
-	start = get_timer_masked();
+	start = get_timer(0);
 	do {
 		if (get_timer(start) > (CONFIG_SYS_HZ * 5)) {
 			printf("%s: Autonegotiation timeout\n", dev->name);
diff -urN u-boot-2011.06/drivers/net/greth.c u-boot-HEAD/drivers/net/greth.c
--- u-boot-2011.06/drivers/net/greth.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/greth.c	2011-09-19 23:25:08.000000000 +0200
@@ -576,7 +576,7 @@
 		GRETH_REGORIN(&regs->control, GRETH_RXEN);
 	}
       done:
-	/* return positive length of packet or 0 if non recieved */
+	/* return positive length of packet or 0 if non received */
 	return len;
 }
 
diff -urN u-boot-2011.06/drivers/net/ks8695eth.c u-boot-HEAD/drivers/net/ks8695eth.c
--- u-boot-2011.06/drivers/net/ks8695eth.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/ks8695eth.c	2011-09-19 23:25:08.000000000 +0200
@@ -99,7 +99,7 @@
 
 /****************************************************************************/
 
-void eth_reset(bd_t *bd)
+static int ks8695_eth_init(struct eth_device *dev, bd_t *bd)
 {
 	int i;
 
@@ -151,21 +151,12 @@
 	ks8695_write(KS8695_LAN_DMA_RX_START, 0x1);
 
 	printf("KS8695 ETHERNET: %pM\n", eth_mac);
-}
-
-/****************************************************************************/
-
-int eth_init(bd_t *bd)
-{
-	debug ("%s(%d): eth_init()\n", __FILE__, __LINE__);
-
-	eth_reset(bd);
 	return 0;
 }
 
 /****************************************************************************/
 
-void eth_halt(void)
+static void ks8695_eth_halt(struct eth_device *dev)
 {
 	debug ("%s(%d): eth_halt()\n", __FILE__, __LINE__);
 
@@ -176,7 +167,7 @@
 
 /****************************************************************************/
 
-int eth_rx(void)
+static int ks8695_eth_recv(struct eth_device *dev)
 {
 	volatile struct ks8695_rxdesc *dp;
 	int i, len = 0;
@@ -199,7 +190,8 @@
 
 /****************************************************************************/
 
-int eth_send(volatile void *packet, int len)
+static int ks8695_eth_send(struct eth_device *dev, volatile void *packet,
+	int len)
 {
 	volatile struct ks8695_txdesc *dp;
 	static int next = 0;
@@ -224,5 +216,27 @@
 	if (++next >= TXDESCS)
 		next = 0;
 
-	return len;
+	return 0;
+}
+
+/****************************************************************************/
+
+int ks8695_eth_initialize(void)
+{
+	struct eth_device *dev;
+
+	dev = malloc(sizeof(*dev));
+	if (dev == NULL)
+		return -1;
+	memset(dev, 0, sizeof(*dev));
+
+	dev->iobase = KS8695_IO_BASE + KS8695_LAN_DMA_TX;
+	dev->init = ks8695_eth_init;
+	dev->halt = ks8695_eth_halt;
+	dev->send = ks8695_eth_send;
+	dev->recv = ks8695_eth_recv;
+	strcpy(dev->name, "ks8695eth");
+
+	eth_register(dev);
+	return 0;
 }
diff -urN u-boot-2011.06/drivers/net/natsemi.c u-boot-HEAD/drivers/net/natsemi.c
--- u-boot-2011.06/drivers/net/natsemi.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/natsemi.c	2011-09-19 23:25:08.000000000 +0200
@@ -282,7 +282,7 @@
  * ready to send and receive packets.
  *
  * Side effects:
- *            leaves the natsemi initialized, and ready to recieve packets.
+ *            leaves the natsemi initialized, and ready to receive packets.
  *
  * Returns:   struct eth_device *:          pointer to NIC data structure
  */
diff -urN u-boot-2011.06/drivers/net/netarm_eth.c u-boot-HEAD/drivers/net/netarm_eth.c
--- u-boot-2011.06/drivers/net/netarm_eth.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/netarm_eth.c	2011-09-19 23:25:08.000000000 +0200
@@ -81,9 +81,10 @@
 
 static int na_mii_poll_busy (void)
 {
+	ulong start;
 	/* arm simple, non interrupt dependent timer */
-	reset_timer_masked ();
-	while (get_timer_masked () < NA_MII_POLL_BUSY_DELAY) {
+	start = get_timer(0));
+	while (get_timer(start) < NA_MII_POLL_BUSY_DELAY) {
 		if (!(GET_EADDR (NETARM_ETH_MII_IND) & NETARM_ETH_MIII_BUSY)) {
 			return 1;
 		}
@@ -164,19 +165,20 @@
 static int reset_eth (void)
 {
 	int pt;
+	ulong start;
 
 	na_get_mac_addr ();
 	pt = na_mii_identify_phy ();
 
 	/* reset the phy */
 	na_mii_write (MII_PHY_CONTROL, 0x8000);
-	reset_timer_masked ();
-	while (get_timer_masked () < NA_MII_NEGOTIATE_DELAY) {
+	start = get_timer(0);
+	while (get_timer(start) < NA_MII_NEGOTIATE_DELAY) {
 		if ((na_mii_read (MII_PHY_STATUS) & 0x8000) == 0) {
 			break;
 		}
 	}
-	if (get_timer_masked () >= NA_MII_NEGOTIATE_DELAY)
+	if (get_timer(start) >= NA_MII_NEGOTIATE_DELAY)
 		printf ("phy reset timeout\n");
 
 	/* set the PCS reg */
diff -urN u-boot-2011.06/drivers/net/ns8382x.c u-boot-HEAD/drivers/net/ns8382x.c
--- u-boot-2011.06/drivers/net/ns8382x.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/ns8382x.c	2011-09-19 23:25:08.000000000 +0200
@@ -299,7 +299,7 @@
  * Description: Retrieves the MAC address of the card, and sets up some
  *  globals required by other routines, and initializes the NIC, making it
  *  ready to send and receive packets.
- * Side effects: initializes ns8382xs, ready to recieve packets.
+ * Side effects: initializes ns8382xs, ready to receive packets.
  * Returns:   int:          number of cards found
  */
 
diff -urN u-boot-2011.06/drivers/net/phy/generic_10g.c u-boot-HEAD/drivers/net/phy/generic_10g.c
--- u-boot-2011.06/drivers/net/phy/generic_10g.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/phy/generic_10g.c	2011-09-19 23:25:08.000000000 +0200
@@ -36,7 +36,7 @@
 int gen10g_startup(struct phy_device *phydev)
 {
 	int devad, reg;
-	u32 mmd_mask = phydev->mmds;
+	u32 mmd_mask = phydev->mmds & MDIO_DEVS_LINK;
 
 	phydev->link = 1;
 
@@ -44,8 +44,12 @@
 	phydev->speed = SPEED_10000;
 	phydev->duplex = DUPLEX_FULL;
 
+	/*
+	 * Go through all the link-reporting devices, and make sure
+	 * they're all up and happy
+	 */
 	for (devad = 0; mmd_mask; devad++, mmd_mask = mmd_mask >> 1) {
-		if (!mmd_mask & 1)
+		if (!(mmd_mask & 1))
 			continue;
 
 		/* Read twice because link state is latched and a
diff -urN u-boot-2011.06/drivers/net/phy/phy.c u-boot-HEAD/drivers/net/phy/phy.c
--- u-boot-2011.06/drivers/net/phy/phy.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/phy/phy.c	2011-09-19 23:25:08.000000000 +0200
@@ -318,13 +318,10 @@
 		lpa = phy_read(phydev, MDIO_DEVAD_NONE, MII_ADVERTISE);
 		lpa &= phy_read(phydev, MDIO_DEVAD_NONE, MII_LPA);
 
-		if (lpa & (LPA_100FULL | LPA_100HALF)) {
+		if (lpa & (LPA_100FULL | LPA_100HALF))
 			phydev->speed = SPEED_100;
 
-			if (lpa & LPA_100FULL)
-				phydev->duplex = DUPLEX_FULL;
-
-		} else if (lpa & LPA_10FULL)
+		if (lpa & (LPA_100FULL | LPA_10FULL))
 			phydev->duplex = DUPLEX_FULL;
 	} else {
 		u32 bmcr = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
@@ -692,7 +689,8 @@
 	struct phy_device *phydev;
 
 	/* Reset the bus */
-	bus->reset(bus);
+	if (bus->reset)
+		bus->reset(bus);
 
 	/* Wait 15ms to make sure the PHY has come out of hard reset */
 	udelay(15000);
@@ -714,7 +712,7 @@
 
 	phydev->dev = dev;
 
-	printf("%s connected to %s\n", dev->name, phydev->drv->name);
+	debug("%s connected to %s\n", dev->name, phydev->drv->name);
 
 	return phydev;
 }
diff -urN u-boot-2011.06/drivers/net/smc911x.c u-boot-HEAD/drivers/net/smc911x.c
--- u-boot-2011.06/drivers/net/smc911x.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/smc911x.c	2011-09-19 23:25:08.000000000 +0200
@@ -50,7 +50,7 @@
 	printf(DRIVERNAME ": MAC %pM\n", m);
 }
 
-static int smc911x_miiphy_read(struct eth_device *dev,
+static int smc911x_eth_phy_read(struct eth_device *dev,
 				u8 phy, u8 reg, u16 *val)
 {
 	while (smc911x_get_mac_csr(dev, MII_ACC) & MII_ACC_MII_BUSY)
@@ -67,7 +67,7 @@
 	return 0;
 }
 
-static int smc911x_miiphy_write(struct eth_device *dev,
+static int smc911x_eth_phy_write(struct eth_device *dev,
 				u8 phy, u8 reg, u16  val)
 {
 	while (smc911x_get_mac_csr(dev, MII_ACC) & MII_ACC_MII_BUSY)
@@ -103,10 +103,10 @@
 
 	smc911x_phy_reset(dev);
 
-	smc911x_miiphy_write(dev, 1, MII_BMCR, BMCR_RESET);
+	smc911x_eth_phy_write(dev, 1, MII_BMCR, BMCR_RESET);
 	mdelay(1);
-	smc911x_miiphy_write(dev, 1, MII_ADVERTISE, 0x01e1);
-	smc911x_miiphy_write(dev, 1, MII_BMCR, BMCR_ANENABLE |
+	smc911x_eth_phy_write(dev, 1, MII_ADVERTISE, 0x01e1);
+	smc911x_eth_phy_write(dev, 1, MII_BMCR, BMCR_ANENABLE |
 				BMCR_ANRESTART);
 
 	timeout = 5000;
@@ -115,7 +115,7 @@
 		if ((timeout--) == 0)
 			goto err_out;
 
-		if (smc911x_miiphy_read(dev, 1, MII_BMSR, &status) != 0)
+		if (smc911x_eth_phy_read(dev, 1, MII_BMSR, &status) != 0)
 			goto err_out;
 	} while (!(status & BMSR_LSTATUS));
 
@@ -235,6 +235,25 @@
 	return 0;
 }
 
+#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
+/* wrapper for smc911x_eth_phy_read */
+static int smc911x_miiphy_read(const char *devname, u8 phy, u8 reg, u16 *val)
+{
+	struct eth_device *dev = eth_get_dev_by_name(devname);
+	if (dev)
+		return smc911x_eth_phy_read(dev, phy, reg, val);
+	return -1;
+}
+/* wrapper for smc911x_eth_phy_write */
+static int smc911x_miiphy_write(const char *devname, u8 phy, u8 reg, u16 val)
+{
+	struct eth_device *dev = eth_get_dev_by_name(devname);
+	if (dev)
+		return smc911x_eth_phy_write(dev, phy, reg, val);
+	return -1;
+}
+#endif
+
 int smc911x_initialize(u8 dev_num, int base_addr)
 {
 	unsigned long addrl, addrh;
@@ -273,5 +292,10 @@
 	sprintf(dev->name, "%s-%hu", DRIVERNAME, dev_num);
 
 	eth_register(dev);
+
+#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
+	miiphy_register(dev->name, smc911x_miiphy_read, smc911x_miiphy_write);
+#endif
+
 	return 1;
 }
diff -urN u-boot-2011.06/drivers/net/smc911x.h u-boot-HEAD/drivers/net/smc911x.h
--- u-boot-2011.06/drivers/net/smc911x.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/net/smc911x.h	2011-09-19 23:25:08.000000000 +0200
@@ -384,6 +384,7 @@
 #define WUCSR_MPEN			0x00000002
 
 /* Chip ID values */
+#define CHIP_89218	0x218a
 #define CHIP_9115	0x115
 #define CHIP_9116	0x116
 #define CHIP_9117	0x117
@@ -402,6 +403,7 @@
 };
 
 static const struct chip_id chip_ids[] =  {
+	{ CHIP_89218, "LAN89218" },
 	{ CHIP_9115, "LAN9115" },
 	{ CHIP_9116, "LAN9116" },
 	{ CHIP_9117, "LAN9117" },
diff -urN u-boot-2011.06/drivers/pci/fsl_pci_init.c u-boot-HEAD/drivers/pci/fsl_pci_init.c
--- u-boot-2011.06/drivers/pci/fsl_pci_init.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/pci/fsl_pci_init.c	2011-09-19 23:25:08.000000000 +0200
@@ -316,7 +316,7 @@
 	hose->current_busno = hose->first_busno;
 
 	out_be32(&pci->pedr, 0xffffffff);	/* Clear any errors */
-	out_be32(&pci->peer, ~0x20140);	/* Enable All Error Interupts except
+	out_be32(&pci->peer, ~0x20140);	/* Enable All Error Interrupts except
 					 * - Master abort (pci)
 					 * - Master PERR (pci)
 					 * - ICCA (PCIe)
diff -urN u-boot-2011.06/drivers/pcmcia/ti_pci1410a.c u-boot-HEAD/drivers/pcmcia/ti_pci1410a.c
--- u-boot-2011.06/drivers/pcmcia/ti_pci1410a.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/pcmcia/ti_pci1410a.c	2011-09-19 23:25:08.000000000 +0200
@@ -2,7 +2,7 @@
  * (C) Copyright 2000-2002
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  * (C) Copyright 2002
- * Daniel Engström, Omicron Ceti AB
+ * Daniel EngstrÃ¶m, Omicron Ceti AB
  *
  * See file CREDITS for list of people who contributed to this
  * project.
diff -urN u-boot-2011.06/drivers/rtc/Makefile u-boot-HEAD/drivers/rtc/Makefile
--- u-boot-2011.06/drivers/rtc/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/rtc/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -55,6 +55,7 @@
 COBJS-$(CONFIG_RTC_MK48T59) += mk48t59.o
 COBJS-$(CONFIG_RTC_MPC5200) += mpc5xxx.o
 COBJS-$(CONFIG_RTC_MPC8xx) += mpc8xx.o
+COBJS-$(CONFIG_RTC_MV) += mvrtc.o
 COBJS-$(CONFIG_RTC_PCF8563) += pcf8563.o
 COBJS-$(CONFIG_RTC_PL031) += pl031.o
 COBJS-$(CONFIG_RTC_PT7C4338) += pt7c4338.o
diff -urN u-boot-2011.06/drivers/rtc/mpc5xxx.c u-boot-HEAD/drivers/rtc/mpc5xxx.c
--- u-boot-2011.06/drivers/rtc/mpc5xxx.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/rtc/mpc5xxx.c	2011-09-19 23:25:08.000000000 +0200
@@ -44,7 +44,7 @@
 	volatile ulong	aier;	/* MBAR+0x80C: alarm and interrupt enable register */
 	volatile ulong	ctr;	/* MBAR+0x810: current time register */
 	volatile ulong	cdr;	/* MBAR+0x814: current data register */
-	volatile ulong	asir;	/* MBAR+0x818: alarm and stopwatch interupt register */
+	volatile ulong	asir;	/* MBAR+0x818: alarm and stopwatch interrupt register */
 	volatile ulong	piber;	/* MBAR+0x81C: periodic interrupt and bus error register */
 	volatile ulong	trdr;	/* MBAR+0x820: test register/divides register */
 } RTC5200;
diff -urN u-boot-2011.06/drivers/rtc/mvrtc.c u-boot-HEAD/drivers/rtc/mvrtc.c
--- u-boot-2011.06/drivers/rtc/mvrtc.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/rtc/mvrtc.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2011
+ * Jason Cooper <u-boot@lakedaemon.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Date & Time support for Marvell Integrated RTC
+ */
+
+#include <common.h>
+#include <command.h>
+#include <rtc.h>
+#include "mvrtc.h"
+
+/* This RTC does not support century, so we assume 20 */
+#define CENTURY 20
+
+int rtc_get(struct rtc_time *t)
+{
+	u32 time;
+	u32 date;
+	struct mvrtc_registers *mvrtc_regs;
+
+	mvrtc_regs = (struct mvrtc_registers *)KW_RTC_BASE;
+
+	/* read the time register */
+	time = readl(&mvrtc_regs->time);
+
+	/* read the date register */
+	date = readl(&mvrtc_regs->date);
+
+	/* test for 12 hour clock (can't tell if it's am/pm) */
+	if (time & MVRTC_HRFMT_MSK) {
+		printf("Error: RTC in 12 hour mode, can't determine AM/PM.\n");
+		return -1;
+	}
+
+	/* time */
+	t->tm_sec  = bcd2bin((time >> MVRTC_SEC_SFT)  & MVRTC_SEC_MSK);
+	t->tm_min  = bcd2bin((time >> MVRTC_MIN_SFT)  & MVRTC_MIN_MSK);
+	t->tm_hour = bcd2bin((time >> MVRTC_HOUR_SFT) & MVRTC_HOUR_MSK);
+	t->tm_wday = bcd2bin((time >> MVRTC_DAY_SFT)  & MVRTC_DAY_MSK);
+	t->tm_wday--;
+
+	/* date */
+	t->tm_mday = bcd2bin((date >> MVRTC_DATE_SFT) & MVRTC_DATE_MSK);
+	t->tm_mon  = bcd2bin((date >> MVRTC_MON_SFT)  & MVRTC_MON_MSK);
+	t->tm_year = bcd2bin((date >> MVRTC_YEAR_SFT) & MVRTC_YEAR_MSK);
+	t->tm_year += CENTURY * 100;
+
+	/* not supported in this RTC */
+	t->tm_yday  = 0;
+	t->tm_isdst = 0;
+
+	return 0;
+}
+
+int rtc_set(struct rtc_time *t)
+{
+	u32 time = 0; /* sets hour format bit to zero, 24hr format. */
+	u32 date = 0;
+	struct mvrtc_registers *mvrtc_regs;
+
+	mvrtc_regs = (struct mvrtc_registers *)KW_RTC_BASE;
+
+	/* check that this code isn't 80+ years old ;-) */
+	if ((t->tm_year / 100) != CENTURY)
+		printf("Warning: Only century %d supported.\n", CENTURY);
+
+	/* time */
+	time |= (bin2bcd(t->tm_sec)      & MVRTC_SEC_MSK)  << MVRTC_SEC_SFT;
+	time |= (bin2bcd(t->tm_min)      & MVRTC_MIN_MSK)  << MVRTC_MIN_SFT;
+	time |= (bin2bcd(t->tm_hour)     & MVRTC_HOUR_MSK) << MVRTC_HOUR_SFT;
+	time |= (bin2bcd(t->tm_wday + 1) & MVRTC_DAY_MSK)  << MVRTC_DAY_SFT;
+
+	/* date */
+	date |= (bin2bcd(t->tm_mday)       & MVRTC_DATE_MSK) << MVRTC_DATE_SFT;
+	date |= (bin2bcd(t->tm_mon)        & MVRTC_MON_MSK)  << MVRTC_MON_SFT;
+	date |= (bin2bcd(t->tm_year % 100) & MVRTC_YEAR_MSK) << MVRTC_YEAR_SFT;
+
+	/* write the time register */
+	writel(time, &mvrtc_regs->time);
+
+	/* write the date register */
+	writel(date, &mvrtc_regs->date);
+
+	return 0;
+}
+
+void rtc_reset(void)
+{
+	u32 time;
+	u32 sec;
+	struct mvrtc_registers *mvrtc_regs;
+
+	mvrtc_regs = (struct mvrtc_registers *)KW_RTC_BASE;
+
+	/* no init routine for this RTC needed, just check that it's working */
+	time = readl(&mvrtc_regs->time);
+	sec  = bcd2bin((time >> MVRTC_SEC_SFT) & MVRTC_SEC_MSK);
+	udelay(1000000);
+	time = readl(&mvrtc_regs->time);
+
+	if (sec == bcd2bin((time >> MVRTC_SEC_SFT) & MVRTC_SEC_MSK))
+		printf("Error: RTC did not increment.\n");
+}
diff -urN u-boot-2011.06/drivers/rtc/mvrtc.h u-boot-HEAD/drivers/rtc/mvrtc.h
--- u-boot-2011.06/drivers/rtc/mvrtc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/rtc/mvrtc.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2011
+ * Jason Cooper <u-boot@lakedaemon.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Date & Time support for Marvell Integrated RTC
+ */
+
+#ifndef _MVRTC_H_
+#define _MVRTC_H_
+
+#include <asm/arch/kirkwood.h>
+#include <compiler.h>
+
+/* RTC registers */
+struct mvrtc_registers {
+	u32 time;
+	u32 date;
+};
+
+/* time register */
+#define MVRTC_SEC_SFT		0
+#define MVRTC_SEC_MSK		0x7f
+#define MVRTC_MIN_SFT		8
+#define MVRTC_MIN_MSK		0x7f
+#define MVRTC_HOUR_SFT		16
+#define MVRTC_HOUR_MSK		0x3f
+#define MVRTC_DAY_SFT		24
+#define MVRTC_DAY_MSK		0x7
+
+/*
+ * Hour format bit
+ *   1 = 12 hour clock
+ *   0 = 24 hour clock
+ */
+#define MVRTC_HRFMT_MSK		0x00400000
+
+/* date register */
+#define MVRTC_DATE_SFT		0
+#define MVRTC_DATE_MSK		0x3f
+#define MVRTC_MON_SFT		8
+#define MVRTC_MON_MSK		0x1f
+#define MVRTC_YEAR_SFT		16
+#define MVRTC_YEAR_MSK		0xff
+
+#endif
diff -urN u-boot-2011.06/drivers/rtc/s3c24x0_rtc.c u-boot-HEAD/drivers/rtc/s3c24x0_rtc.c
--- u-boot-2011.06/drivers/rtc/s3c24x0_rtc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/rtc/s3c24x0_rtc.c	2011-09-19 23:25:08.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2003
- * David Müller ELSOFT AG Switzerland. d.mueller@elsoft.ch
+ * David MÃ¼ller ELSOFT AG Switzerland. d.mueller@elsoft.ch
  *
  * See file CREDITS for list of people who contributed to this
  * project.

  diff -urN u-boot-2011.06/drivers/serial/serial.c u-boot-HEAD/drivers/serial/serial.c
--- u-boot-2011.06/drivers/serial/serial.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/serial/serial.c	2011-09-19 23:25:08.000000000 +0200
@@ -22,6 +22,7 @@
  */
 
 #include <common.h>
+#include <linux/compiler.h>
 
 #include <ns16550.h>
 #ifdef CONFIG_NS87308
@@ -117,9 +118,8 @@
 	serial_puts_dev(port, s);}
 
 /* Serial device descriptor */
-#define INIT_ESERIAL_STRUCTURE(port,name,bus) {\
+#define INIT_ESERIAL_STRUCTURE(port, name) {\
 	name,\
-	bus,\
 	eserial##port##_init,\
 	NULL,\
 	eserial##port##_setbrg,\
@@ -325,14 +325,30 @@
 
 DECLARE_ESERIAL_FUNCTIONS(1);
 struct serial_device eserial1_device =
-	INIT_ESERIAL_STRUCTURE(1,"eserial0","EUART1");
+	INIT_ESERIAL_STRUCTURE(1, "eserial0");
 DECLARE_ESERIAL_FUNCTIONS(2);
 struct serial_device eserial2_device =
-	INIT_ESERIAL_STRUCTURE(2,"eserial1","EUART2");
+	INIT_ESERIAL_STRUCTURE(2, "eserial1");
 DECLARE_ESERIAL_FUNCTIONS(3);
 struct serial_device eserial3_device =
-	INIT_ESERIAL_STRUCTURE(3,"eserial2","EUART3");
+	INIT_ESERIAL_STRUCTURE(3, "eserial2");
 DECLARE_ESERIAL_FUNCTIONS(4);
 struct serial_device eserial4_device =
-	INIT_ESERIAL_STRUCTURE(4,"eserial3","EUART4");
+	INIT_ESERIAL_STRUCTURE(4, "eserial3");
+
+__weak struct serial_device *default_serial_console(void)
+{
+#if CONFIG_CONS_INDEX == 1
+	return &eserial1_device;
+#elif CONFIG_CONS_INDEX == 2
+	return &eserial2_device;
+#elif CONFIG_CONS_INDEX == 3
+	return &eserial3_device;
+#elif CONFIG_CONS_INDEX == 4
+	return &eserial4_device;
+#else
+#error "Bad CONFIG_CONS_INDEX."
+#endif
+}
+
 #endif /* CONFIG_SERIAL_MULTI */
diff -urN u-boot-2011.06/drivers/serial/serial_pxa.c u-boot-HEAD/drivers/serial/serial_pxa.c
--- u-boot-2011.06/drivers/serial/serial_pxa.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/serial/serial_pxa.c	2011-09-19 23:25:08.000000000 +0200
@@ -268,7 +268,6 @@
 struct serial_device serial_ffuart_device =
 {
 	"serial_ffuart",
-	"PXA",
 	ffuart_init,
 	NULL,
 	ffuart_setbrg,
@@ -313,7 +312,6 @@
 struct serial_device serial_btuart_device =
 {
 	"serial_btuart",
-	"PXA",
 	btuart_init,
 	NULL,
 	btuart_setbrg,
@@ -358,7 +356,6 @@
 struct serial_device serial_stuart_device =
 {
 	"serial_stuart",
-	"PXA",
 	stuart_init,
 	NULL,
 	stuart_setbrg,
diff -urN u-boot-2011.06/drivers/serial/serial_s3c24x0.c u-boot-HEAD/drivers/serial/serial_s3c24x0.c
--- u-boot-2011.06/drivers/serial/serial_s3c24x0.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/serial/serial_s3c24x0.c	2011-09-19 23:25:08.000000000 +0200
@@ -19,6 +19,7 @@
  */
 
 #include <common.h>
+#include <linux/compiler.h>
 #include <asm/arch/s3c24x0_cpu.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -68,9 +69,8 @@
 		serial_puts_dev(port, s); \
 	}
 
-#define INIT_S3C_SERIAL_STRUCTURE(port, name, bus) { \
+#define INIT_S3C_SERIAL_STRUCTURE(port, name) { \
 	name, \
-	bus, \
 	s3serial##port##_init, \
 	NULL,\
 	s3serial##port##_setbrg, \
@@ -303,11 +303,24 @@
 #if defined(CONFIG_SERIAL_MULTI)
 DECLARE_S3C_SERIAL_FUNCTIONS(0);
 struct serial_device s3c24xx_serial0_device =
-INIT_S3C_SERIAL_STRUCTURE(0, "s3ser0", "S3UART1");
+INIT_S3C_SERIAL_STRUCTURE(0, "s3ser0");
 DECLARE_S3C_SERIAL_FUNCTIONS(1);
 struct serial_device s3c24xx_serial1_device =
-INIT_S3C_SERIAL_STRUCTURE(1, "s3ser1", "S3UART2");
+INIT_S3C_SERIAL_STRUCTURE(1, "s3ser1");
 DECLARE_S3C_SERIAL_FUNCTIONS(2);
 struct serial_device s3c24xx_serial2_device =
-INIT_S3C_SERIAL_STRUCTURE(2, "s3ser2", "S3UART3");
+INIT_S3C_SERIAL_STRUCTURE(2, "s3ser2");
+
+__weak struct serial_device *default_serial_console(void)
+{
+#if defined(CONFIG_SERIAL1)
+	return &s3c24xx_serial0_device;
+#elif defined(CONFIG_SERIAL2)
+	return &s3c24xx_serial1_device;
+#elif defined(CONFIG_SERIAL3)
+	return &s3c24xx_serial2_device;
+#else
+#error "CONFIG_SERIAL? missing."
+#endif
+}
 #endif /* CONFIG_SERIAL_MULTI */
diff -urN u-boot-2011.06/drivers/serial/serial_s5p.c u-boot-HEAD/drivers/serial/serial_s5p.c
--- u-boot-2011.06/drivers/serial/serial_s5p.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/serial/serial_s5p.c	2011-09-19 23:25:08.000000000 +0200
@@ -22,6 +22,7 @@
  */
 
 #include <common.h>
+#include <linux/compiler.h>
 #include <asm/io.h>
 #include <asm/arch/uart.h>
 #include <asm/arch/clk.h>
@@ -182,9 +183,8 @@
 void s5p_serial##port##_putc(const char c) { serial_putc_dev(c, port); } \
 void s5p_serial##port##_puts(const char *s) { serial_puts_dev(s, port); }
 
-#define INIT_S5P_SERIAL_STRUCTURE(port, name, bus) { \
+#define INIT_S5P_SERIAL_STRUCTURE(port, name) { \
 	name, \
-	bus, \
 	s5p_serial##port##_init, \
 	NULL, \
 	s5p_serial##port##_setbrg, \
@@ -195,13 +195,28 @@
 
 DECLARE_S5P_SERIAL_FUNCTIONS(0);
 struct serial_device s5p_serial0_device =
-	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0", "S5PUART0");
+	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
 DECLARE_S5P_SERIAL_FUNCTIONS(1);
 struct serial_device s5p_serial1_device =
-	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1", "S5PUART1");
+	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
 DECLARE_S5P_SERIAL_FUNCTIONS(2);
 struct serial_device s5p_serial2_device =
-	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2", "S5PUART2");
+	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
 DECLARE_S5P_SERIAL_FUNCTIONS(3);
 struct serial_device s5p_serial3_device =
-	INIT_S5P_SERIAL_STRUCTURE(3, "s5pser3", "S5PUART3");
+	INIT_S5P_SERIAL_STRUCTURE(3, "s5pser3");
+
+__weak struct serial_device *default_serial_console(void)
+{
+#if defined(CONFIG_SERIAL0)
+	return &s5p_serial0_device;
+#elif defined(CONFIG_SERIAL1)
+	return &s5p_serial1_device;
+#elif defined(CONFIG_SERIAL2)
+	return &s5p_serial2_device;
+#elif defined(CONFIG_SERIAL3)
+	return &s5p_serial3_device;
+#else
+#error "CONFIG_SERIAL? missing."
+#endif
+}
diff -urN u-boot-2011.06/drivers/serial/serial_sh.h u-boot-HEAD/drivers/serial/serial_sh.h
--- u-boot-2011.06/drivers/serial/serial_sh.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/serial/serial_sh.h	2011-09-19 23:25:08.000000000 +0200
@@ -177,7 +177,8 @@
 #elif defined(CONFIG_CPU_SH7201) || \
 	defined(CONFIG_CPU_SH7203) || \
 	defined(CONFIG_CPU_SH7206) || \
-	defined(CONFIG_CPU_SH7263)
+	defined(CONFIG_CPU_SH7263) || \
+	defined(CONFIG_CPU_SH7264)
 # define SCSPTR0 0xfffe8020 /* 16 bit SCIF */
 # define SCSPTR1 0xfffe8820 /* 16 bit SCIF */
 # define SCSPTR2 0xfffe9020 /* 16 bit SCIF */
@@ -685,6 +686,8 @@
 #define SCBRR_VALUE(bps, clk) scbrr_calc(sh_sci, bps, clk)
 #elif defined(__H8300H__) || defined(__H8300S__)
 #define SCBRR_VALUE(bps, clk) (((clk*1000/32)/bps)-1)
+#elif defined(CONFIG_CPU_SH7264)
+#define SCBRR_VALUE(bps, clk) ((clk+16*bps)/(32*bps))
 #else /* Generic SH */
 #define SCBRR_VALUE(bps, clk) ((clk+16*bps)/(32*bps)-1)
 #endif
diff -urN u-boot-2011.06/drivers/spi/andes_spi.c u-boot-HEAD/drivers/spi/andes_spi.c
--- u-boot-2011.06/drivers/spi/andes_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/spi/andes_spi.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,302 @@
+/*
+ * Driver of Andes SPI Controller
+ *
+ * (C) Copyright 2011 Andes Technology
+ * Macpaul Lin <macpaul@andestech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+
+#include <asm/io.h>
+#include "andes_spi.h"
+
+void spi_init(void)
+{
+	/* do nothing */
+}
+
+static void andes_spi_spit_en(struct andes_spi_slave *ds)
+{
+	unsigned int dcr = readl(&ds->regs->dcr);
+
+	debug("%s: dcr: %x, write value: %x\n",
+			__func__, dcr, (dcr | ANDES_SPI_DCR_SPIT));
+
+	writel((dcr | ANDES_SPI_DCR_SPIT), &ds->regs->dcr);
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+			unsigned int max_hz, unsigned int mode)
+{
+	struct andes_spi_slave	*ds;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	ds = malloc(sizeof(*ds));
+	if (!ds)
+		return NULL;
+
+	ds->slave.bus = bus;
+	ds->slave.cs = cs;
+	ds->regs = (struct andes_spi_regs *)CONFIG_SYS_SPI_BASE;
+
+	/*
+	 * The hardware of andes_spi will set its frequency according
+	 * to APB/AHB bus clock. Hence the hardware doesn't allow changing of
+	 * requency and so the user requested speed is always ignored.
+	 */
+	ds->freq = max_hz;
+
+	return &ds->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct andes_spi_slave *ds = to_andes_spi(slave);
+
+	free(ds);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct andes_spi_slave *ds = to_andes_spi(slave);
+	unsigned int apb;
+	unsigned int baud;
+
+	/* Enable the SPI hardware */
+	writel(ANDES_SPI_CR_SPIRST, &ds->regs->cr);
+	udelay(1000);
+
+	/* setup format */
+	baud = ((CONFIG_SYS_CLK_FREQ / CONFIG_SYS_SPI_CLK / 2) - 1) & 0xFF;
+
+	/*
+	 * SPI_CLK = AHB bus clock / ((BAUD + 1)*2)
+	 * BAUD = AHB bus clock / SPI_CLK / 2) - 1
+	 */
+	apb = (readl(&ds->regs->apb) & 0xffffff00) | baud;
+	writel(apb, &ds->regs->apb);
+
+	/* no interrupts */
+	writel(0, &ds->regs->ie);
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	struct andes_spi_slave *ds = to_andes_spi(slave);
+
+	/* Disable the SPI hardware */
+	writel(ANDES_SPI_CR_SPIRST, &ds->regs->cr);
+}
+
+static int andes_spi_read(struct spi_slave *slave, unsigned int len,
+			    u8 *rxp, unsigned long flags)
+{
+	struct andes_spi_slave *ds = to_andes_spi(slave);
+	unsigned int i, left;
+	unsigned int data;
+
+	debug("%s: slave: %x, len: %d, rxp: %x, flags: %d\n",
+		__func__, slave, len, rxp, flags);
+
+	debug("%s: data: ", __func__);
+	while (len > 0) {
+		left = min(len, 4);
+		data = readl(&ds->regs->data);
+
+		debug(" ");
+		for (i = 0; i < left; i++) {
+			debug("%02x ", data & 0xff);
+			*rxp++ = data;
+			data >>= 8;
+			len--;
+		}
+	}
+	debug("\n");
+
+	return 0;
+}
+
+static int andes_spi_write(struct spi_slave *slave, unsigned int wlen,
+			unsigned int rlen, const u8 *txp, unsigned long flags)
+{
+	struct andes_spi_slave *ds = to_andes_spi(slave);
+	unsigned int data;
+	unsigned int i, left;
+	unsigned int spit_enabled = 0;
+
+	debug("%s: slave: %x, wlen: %d, rlen: %d, txp: %x, flags: %x\n",
+		__func__, slave, wlen, rlen, txp, flags);
+
+	/* The value of wlen and rlen wrote to register must minus 1 */
+	if (rlen == 0)					/* write only */
+		writel(ANDES_SPI_DCR_MODE_WO | ANDES_SPI_DCR_WCNT(wlen-1) |
+				ANDES_SPI_DCR_RCNT(0), &ds->regs->dcr);
+	else						/* write then read */
+		writel(ANDES_SPI_DCR_MODE_WR | ANDES_SPI_DCR_WCNT(wlen-1) |
+				ANDES_SPI_DCR_RCNT(rlen-1), &ds->regs->dcr);
+
+	/* wait till SPIBSY is cleared */
+	while (readl(&ds->regs->st) & ANDES_SPI_ST_SPIBSY)
+		;
+
+	/* data write process */
+	debug("%s: txp: ", __func__);
+	while (wlen > 0) {
+		/* clear the data */
+		data = 0;
+
+		/* data are usually be read 32bits once a time */
+		left = min(wlen, 4);
+
+		for (i = 0; i < left; i++) {
+			debug("%x ", *txp);
+			data |= *txp++ << (i * 8);
+			wlen--;
+		}
+		debug("\n");
+
+		debug("data: %08x\n", data);
+		debug("streg before write: %08x\n", readl(&ds->regs->st));
+		/* wait till TXFULL is deasserted */
+		while (readl(&ds->regs->st) & ANDES_SPI_ST_TXFEL)
+			;
+		writel(data, &ds->regs->data);
+		debug("streg after write: %08x\n", readl(&ds->regs->st));
+
+
+		if (spit_enabled == 0) {
+			/* enable SPIT bit -  trigger the tx and rx progress */
+			andes_spi_spit_en(ds);
+			spit_enabled = 1;
+		}
+
+	}
+	debug("\n");
+
+	return 0;
+}
+
+/*
+ * spi_xfer:
+ *	Since andes_spi doesn't support independent command transaction,
+ *	that is, write and than read must be operated in continuous
+ *	execution, there is no need to set dcr and trigger spit again in
+ *	RX process.
+ */
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+	     const void *dout, void *din, unsigned long flags)
+{
+	unsigned int len;
+	static int op_nextime;
+	static u8 tmp_cmd[5];
+	static int tmp_wlen;
+	unsigned int i;
+
+	if (bitlen == 0)
+		/* Finish any previously submitted transfers */
+		goto out;
+
+	if (bitlen % 8) {
+		/* Errors always terminate an ongoing transfer */
+		flags |= SPI_XFER_END;
+		goto out;
+	}
+
+	len = bitlen / 8;
+
+	debug("%s: slave: %08x, bitlen: %d, dout: "
+		"%08x, din: %08x, flags: %d, len: %d\n",
+		__func__, slave, bitlen, dout, din, flags, len);
+
+	/*
+	 * Important:
+	 *	andes_spi's hardware doesn't support 2 data channel. The read
+	 *	and write cmd/data share the same register (data register).
+	 *
+	 *	If a command has write and read transaction, you cannot do write
+	 *	this time and then do read on next time.
+	 *
+	 *	A command writes first with a read response must indicating
+	 *	the read length in write operation. Hence the write action must
+	 *	be stored temporary and wait until the next read action has been
+	 *	arrived. Then we flush the write and read action out together.
+	 */
+	if (!dout) {
+		if (op_nextime == 1) {
+			/* flags should be SPI_XFER_END, value is 2 */
+			op_nextime = 0;
+			andes_spi_write(slave, tmp_wlen, len, tmp_cmd, flags);
+		}
+		return andes_spi_read(slave, len, din, flags);
+	} else if (!din) {
+		if (flags == SPI_XFER_BEGIN) {
+			/* store the write command and do operation next time */
+			op_nextime = 1;
+			memset(tmp_cmd, 0, sizeof(tmp_cmd));
+			memcpy(tmp_cmd, dout, len);
+
+			debug("%s: tmp_cmd: ", __func__);
+			for (i = 0; i < len; i++)
+				debug("%x ", *(tmp_cmd + i));
+			debug("\n");
+
+			tmp_wlen = len;
+		} else {
+			/*
+			 * flags should be (SPI_XFER_BEGIN | SPI_XFER_END),
+			 * the value is 3.
+			 */
+			if (op_nextime == 1) {
+				/* flags should be SPI_XFER_END, value is 2 */
+				op_nextime = 0;
+				/* flags 3 implies write only */
+				andes_spi_write(slave, tmp_wlen, 0, tmp_cmd, 3);
+			}
+
+			debug("flags: %x\n", flags);
+			return andes_spi_write(slave, len, 0, dout, flags);
+		}
+	}
+
+out:
+	return 0;
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return bus == 0 && cs == 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	/* do nothing */
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	/* do nothing */
+}
diff -urN u-boot-2011.06/drivers/spi/andes_spi.h u-boot-HEAD/drivers/spi/andes_spi.h
--- u-boot-2011.06/drivers/spi/andes_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/spi/andes_spi.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,128 @@
+/*
+ * Register definitions for the Andes SPI Controller
+ *
+ * (C) Copyright 2011 Andes Technology
+ * Macpaul Lin <macpaul@andestech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ANDES_SPI_H
+#define __ANDES_SPI_H
+
+struct andes_spi_regs {
+	unsigned int	apb;		/* 0x00 - APB SPI interface setting */
+	unsigned int	pio;		/* 0x04 - PIO reg */
+	unsigned int	cr;		/* 0x08 - SPI Control reg */
+	unsigned int	st;		/* 0x0c - SPI Status reg */
+	unsigned int	ie;		/* 0x10 - Interrupt Enable reg */
+	unsigned int	ist;		/* 0x14 - Interrupt Status reg */
+	unsigned int	dcr;		/* 0x18 - data control reg */
+	unsigned int	data;		/* 0x1c - data register */
+	unsigned int	ahb;		/* 0x20 - AHB SPI interface setting */
+	unsigned int	ver;		/* 0x3c - SPI version reg */
+};
+
+#define BIT(x)			(1 << (x))
+
+/* 0x00 - APB SPI interface setting register */
+#define ANDES_SPI_APB_BAUD(x)	(((x) & 0xff) < 0)
+#define ANDES_SPI_APB_CSHT(x)	(((x) & 0xf) < 16)
+#define ANDES_SPI_APB_SPNTS	BIT(20)		/* 0: normal, 1: delay */
+#define ANDES_SPI_APB_CPHA	BIT(24)		/* 0: Sampling at odd edges */
+#define ANDES_SPI_APB_CPOL	BIT(25)		/* 0: SCK low, 1: SCK high */
+#define ANDES_SPI_APB_MSSL	BIT(26)		/* 0: SPI Master, 1: slave */
+
+/* 0x04 - PIO register */
+#define ANDES_SPI_PIO_MISO	BIT(0)		/* input value of pin MISO */
+#define ANDES_SPI_PIO_MOSI	BIT(1)		/* I/O value of pin MOSI */
+#define ANDES_SPI_PIO_SCK	BIT(2)		/* I/O value of pin SCK */
+#define ANDES_SPI_PIO_CS	BIT(3)		/* I/O value of pin CS */
+#define ANDES_SPI_PIO_PIOE	BIT(4)		/* Programming IO Enable */
+
+/* 0x08 - SPI Control register */
+#define ANDES_SPI_CR_SPIRST	BIT(0)		/* SPI mode reset */
+#define ANDES_SPI_CR_RXFRST	BIT(1)		/* RxFIFO reset */
+#define ANDES_SPI_CR_TXFRST	BIT(2)		/* TxFIFO reset */
+#define ANDES_SPI_CR_RXFTH(x)	(((x) & 0x1f) << 10)	/* RxFIFO Threshold */
+#define ANDES_SPI_CR_TXFTH(x)	(((x) & 0x1f) << 18)	/* TxFIFO Threshold */
+
+/* 0x0c - SPI Status register */
+#define ANDES_SPI_ST_SPIBSY	BIT(0)		/* SPI Transfer is active */
+#define ANDES_SPI_ST_RXFEM	BIT(8)		/* RxFIFO Empty Flag */
+#define ANDES_SPI_ST_RXFEL	BIT(9)		/* RxFIFO Full Flag */
+#define ANDES_SPI_ST_RXFVE(x)	(((x) >> 10) & 0x1f)
+#define ANDES_SPI_ST_TXFEM	BIT(16)		/* TxFIFO Empty Flag */
+#define ANDES_SPI_ST_TXFEL	BIT(7)		/* TxFIFO Full Flag */
+#define ANDES_SPI_ST_TXFVE(x)	(((x) >> 18) & 0x1f)
+
+/* 0x10 - Interrupt Enable register */
+#define ANDES_SPI_IE_RXFORIE	BIT(0)		/* RxFIFO overrun intr */
+#define ANDES_SPI_IE_TXFURIE	BIT(1)		/* TxFOFO underrun intr */
+#define ANDES_SPI_IE_RXFTHIE	BIT(2)		/* RxFIFO threshold intr */
+#define ANDES_SPI_IE_TXFTHIE	BIT(3)		/* TxFIFO threshold intr */
+#define ANDES_SPI_IE_SPIEIE	BIT(4)		/* SPI transmit END intr */
+#define ANDES_SPI_IE_SPCFIE	BIT(5)		/* AHB/APB TxReq conflict */
+
+/* 0x14 - Interrupt Status Register */
+#define ANDES_SPI_IST_RXFORI	BIT(0)		/* has RxFIFO overrun */
+#define ANDES_SPI_IST_TXFURI	BIT(1)		/* has TxFOFO underrun */
+#define ANDES_SPI_IST_RXFTHI	BIT(2)		/* has RxFIFO threshold */
+#define ANDES_SPI_IST_TXFTHI	BIT(3)		/* has TxFIFO threshold */
+#define ANDES_SPI_IST_SPIEI	BIT(4)		/* has SPI transmit END */
+#define ANDES_SPI_IST_SPCFI	BIT(5)		/* has AHB/APB TxReq conflict */
+
+/* 0x18 - Data Control Register */
+#define ANDES_SPI_DCR_RCNT(x)		(((x) & 0x3ff) << 0)
+#define ANDES_SPI_DCR_DYCNT(x)		(((x) & 0x7) << 12)
+#define ANDES_SPI_DCR_WCNT(x)		(((x) & 0x3ff) << 16)
+#define ANDES_SPI_DCR_TRAMODE(x)	(((x) & 0x7) << 28)
+#define ANDES_SPI_DCR_SPIT		BIT(31)		/* SPI bus trigger */
+
+#define ANDES_SPI_DCR_MODE_WRCON	ANDES_SPI_DCR_TRAMODE(0)	/* w/r at the same time */
+#define ANDES_SPI_DCR_MODE_WO		ANDES_SPI_DCR_TRAMODE(1)	/* write only		*/
+#define ANDES_SPI_DCR_MODE_RO		ANDES_SPI_DCR_TRAMODE(2)	/* read only		*/
+#define ANDES_SPI_DCR_MODE_WR		ANDES_SPI_DCR_TRAMODE(3)	/* write, read		*/
+#define ANDES_SPI_DCR_MODE_RW		ANDES_SPI_DCR_TRAMODE(4)	/* read, write		*/
+#define ANDES_SPI_DCR_MODE_WDR		ANDES_SPI_DCR_TRAMODE(5)	/* write, dummy, read	*/
+#define ANDES_SPI_DCR_MODE_RDW		ANDES_SPI_DCR_TRAMODE(6)	/* read, dummy, write	*/
+#define ANDES_SPI_DCR_MODE_RECEIVE	ANDES_SPI_DCR_TRAMODE(7)	/* receive		*/
+
+/* 0x20 - AHB SPI interface setting register */
+#define ANDES_SPI_AHB_BAUD(x)	(((x) & 0xff) < 0)
+#define ANDES_SPI_AHB_CSHT(x)	(((x) & 0xf) < 16)
+#define ANDES_SPI_AHB_SPNTS	BIT(20)		/* 0: normal, 1: delay */
+#define ANDES_SPI_AHB_CPHA	BIT(24)		/* 0: Sampling at odd edges */
+#define ANDES_SPI_AHB_CPOL	BIT(25)		/* 0: SCK low, 1: SCK high */
+#define ANDES_SPI_AHB_MSSL	BIT(26)		/* only Master mode */
+
+/* 0x3c - Version Register - (Year V.MAJOR.MINOR) */
+#define ANDES_SPI_VER_MINOR(x)	(((x) >> 0) & 0xf)
+#define ANDES_SPI_VER_MAJOR(x)	(((x) >> 8) & 0xf)
+#define ANDES_SPI_VER_YEAR(x)	(((x) >> 16) & 0xf)
+
+struct andes_spi_slave {
+	struct spi_slave slave;
+	struct andes_spi_regs *regs;
+	unsigned int freq;
+};
+
+static inline struct andes_spi_slave *to_andes_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct andes_spi_slave, slave);
+}
+
+#endif /* __ANDES_SPI_H */

diff -urN u-boot-2011.06/drivers/spi/Makefile u-boot-HEAD/drivers/spi/Makefile
--- u-boot-2011.06/drivers/spi/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/spi/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -26,6 +26,7 @@
 LIB	:= $(obj)libspi.o
 
 COBJS-$(CONFIG_ALTERA_SPI) += altera_spi.o
+COBJS-$(CONFIG_ANDES_SPI) += andes_spi.o
 COBJS-$(CONFIG_ATMEL_DATAFLASH_SPI) += atmel_dataflash_spi.o
 COBJS-$(CONFIG_ATMEL_SPI) += atmel_spi.o
 COBJS-$(CONFIG_BFIN_SPI) += bfin_spi.o
diff -urN u-boot-2011.06/drivers/spi/mxc_spi.c u-boot-HEAD/drivers/spi/mxc_spi.c
--- u-boot-2011.06/drivers/spi/mxc_spi.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/spi/mxc_spi.c	2011-09-19 23:25:08.000000000 +0200
@@ -23,7 +23,7 @@
 #include <spi.h>
 #include <asm/errno.h>
 #include <asm/io.h>
-#include <mxc_gpio.h>
+#include <asm/gpio.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/clock.h>
 
@@ -60,8 +60,6 @@
 	0x53f84000,
 };
 
-#define mxc_get_clock(x)	mx31_get_ipg_clk()
-
 #elif defined(CONFIG_MX51)
 
 #define MXC_CSPICTRL_EN		(1 << 0)
@@ -147,14 +145,14 @@
 {
 	struct mxc_spi_slave *mxcs = to_mxc_spi_slave(slave);
 	if (mxcs->gpio > 0)
-		mxc_gpio_set(mxcs->gpio, mxcs->ss_pol);
+		gpio_set_value(mxcs->gpio, mxcs->ss_pol);
 }
 
 void spi_cs_deactivate(struct spi_slave *slave)
 {
 	struct mxc_spi_slave *mxcs = to_mxc_spi_slave(slave);
 	if (mxcs->gpio > 0)
-		mxc_gpio_set(mxcs->gpio,
+		gpio_set_value(mxcs->gpio,
 			      !(mxcs->ss_pol));
 }
 
@@ -470,7 +468,7 @@
 	if (cs > 3) {
 		mxcs->gpio = cs >> 8;
 		cs &= 3;
-		ret = mxc_gpio_direction(mxcs->gpio, OUT);
+		ret = gpio_direction_output(mxcs->gpio, 0);
 		if (ret) {
 			printf("mxc_spi: cannot setup gpio %d\n", mxcs->gpio);
 			return -EINVAL;
diff -urN u-boot-2011.06/drivers/usb/eth/Makefile u-boot-HEAD/drivers/usb/eth/Makefile
--- u-boot-2011.06/drivers/usb/eth/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/usb/eth/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -28,6 +28,7 @@
 ifdef CONFIG_USB_ETHER_ASIX
 COBJS-y += asix.o
 endif
+COBJS-$(CONFIG_USB_ETHER_SMSC95XX) += smsc95xx.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff -urN u-boot-2011.06/drivers/usb/eth/smsc95xx.c u-boot-HEAD/drivers/usb/eth/smsc95xx.c
--- u-boot-2011.06/drivers/usb/eth/smsc95xx.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/usb/eth/smsc95xx.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,879 @@
+/*
+ * Copyright (c) 2011 The Chromium OS Authors.
+ * Copyright (C) 2009 NVIDIA, Corporation
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <usb.h>
+#include <linux/mii.h>
+#include "usb_ether.h"
+
+/* SMSC LAN95xx based USB 2.0 Ethernet Devices */
+
+/* Tx command words */
+#define TX_CMD_A_FIRST_SEG_		0x00002000
+#define TX_CMD_A_LAST_SEG_		0x00001000
+
+/* Rx status word */
+#define RX_STS_FL_			0x3FFF0000	/* Frame Length */
+#define RX_STS_ES_			0x00008000	/* Error Summary */
+
+/* SCSRs */
+#define ID_REV				0x00
+
+#define INT_STS				0x08
+
+#define TX_CFG				0x10
+#define TX_CFG_ON_			0x00000004
+
+#define HW_CFG				0x14
+#define HW_CFG_BIR_			0x00001000
+#define HW_CFG_RXDOFF_			0x00000600
+#define HW_CFG_MEF_			0x00000020
+#define HW_CFG_BCE_			0x00000002
+#define HW_CFG_LRST_			0x00000008
+
+#define PM_CTRL				0x20
+#define PM_CTL_PHY_RST_			0x00000010
+
+#define AFC_CFG				0x2C
+
+/*
+ * Hi watermark = 15.5Kb (~10 mtu pkts)
+ * low watermark = 3k (~2 mtu pkts)
+ * backpressure duration = ~ 350us
+ * Apply FC on any frame.
+ */
+#define AFC_CFG_DEFAULT			0x00F830A1
+
+#define E2P_CMD				0x30
+#define E2P_CMD_BUSY_			0x80000000
+#define E2P_CMD_READ_			0x00000000
+#define E2P_CMD_TIMEOUT_		0x00000400
+#define E2P_CMD_LOADED_			0x00000200
+#define E2P_CMD_ADDR_			0x000001FF
+
+#define E2P_DATA			0x34
+
+#define BURST_CAP			0x38
+
+#define INT_EP_CTL			0x68
+#define INT_EP_CTL_PHY_INT_		0x00008000
+
+#define BULK_IN_DLY			0x6C
+
+/* MAC CSRs */
+#define MAC_CR				0x100
+#define MAC_CR_MCPAS_			0x00080000
+#define MAC_CR_PRMS_			0x00040000
+#define MAC_CR_HPFILT_			0x00002000
+#define MAC_CR_TXEN_			0x00000008
+#define MAC_CR_RXEN_			0x00000004
+
+#define ADDRH				0x104
+
+#define ADDRL				0x108
+
+#define MII_ADDR			0x114
+#define MII_WRITE_			0x02
+#define MII_BUSY_			0x01
+#define MII_READ_			0x00 /* ~of MII Write bit */
+
+#define MII_DATA			0x118
+
+#define FLOW				0x11C
+
+#define VLAN1				0x120
+
+#define COE_CR				0x130
+#define Tx_COE_EN_			0x00010000
+#define Rx_COE_EN_			0x00000001
+
+/* Vendor-specific PHY Definitions */
+#define PHY_INT_SRC			29
+
+#define PHY_INT_MASK			30
+#define PHY_INT_MASK_ANEG_COMP_		((u16)0x0040)
+#define PHY_INT_MASK_LINK_DOWN_		((u16)0x0010)
+#define PHY_INT_MASK_DEFAULT_		(PHY_INT_MASK_ANEG_COMP_ | \
+					 PHY_INT_MASK_LINK_DOWN_)
+
+/* USB Vendor Requests */
+#define USB_VENDOR_REQUEST_WRITE_REGISTER	0xA0
+#define USB_VENDOR_REQUEST_READ_REGISTER	0xA1
+
+/* Some extra defines */
+#define HS_USB_PKT_SIZE			512
+#define FS_USB_PKT_SIZE			64
+#define DEFAULT_HS_BURST_CAP_SIZE	(16 * 1024 + 5 * HS_USB_PKT_SIZE)
+#define DEFAULT_FS_BURST_CAP_SIZE	(6 * 1024 + 33 * FS_USB_PKT_SIZE)
+#define DEFAULT_BULK_IN_DELAY		0x00002000
+#define MAX_SINGLE_PACKET_SIZE		2048
+#define EEPROM_MAC_OFFSET		0x01
+#define SMSC95XX_INTERNAL_PHY_ID	1
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+
+/* local defines */
+#define SMSC95XX_BASE_NAME "sms"
+#define USB_CTRL_SET_TIMEOUT 5000
+#define USB_CTRL_GET_TIMEOUT 5000
+#define USB_BULK_SEND_TIMEOUT 5000
+#define USB_BULK_RECV_TIMEOUT 5000
+
+#define AX_RX_URB_SIZE 2048
+#define PHY_CONNECT_TIMEOUT 5000
+
+#define TURBO_MODE
+
+/* local vars */
+static int curr_eth_dev; /* index for name of next device detected */
+
+
+/*
+ * Smsc95xx infrastructure commands
+ */
+static int smsc95xx_write_reg(struct ueth_data *dev, u32 index, u32 data)
+{
+	int len;
+
+	cpu_to_le32s(&data);
+
+	len = usb_control_msg(dev->pusb_dev, usb_sndctrlpipe(dev->pusb_dev, 0),
+		USB_VENDOR_REQUEST_WRITE_REGISTER,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		00, index, &data, sizeof(data), USB_CTRL_SET_TIMEOUT);
+	if (len != sizeof(data)) {
+		debug("smsc95xx_write_reg failed: index=%d, data=%d, len=%d",
+		      index, data, len);
+		return -1;
+	}
+	return 0;
+}
+
+static int smsc95xx_read_reg(struct ueth_data *dev, u32 index, u32 *data)
+{
+	int len;
+
+	len = usb_control_msg(dev->pusb_dev, usb_rcvctrlpipe(dev->pusb_dev, 0),
+		USB_VENDOR_REQUEST_READ_REGISTER,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		00, index, data, sizeof(data), USB_CTRL_GET_TIMEOUT);
+	if (len != sizeof(data)) {
+		debug("smsc95xx_read_reg failed: index=%d, len=%d",
+		      index, len);
+		return -1;
+	}
+
+	le32_to_cpus(data);
+	return 0;
+}
+
+/* Loop until the read is completed with timeout */
+static int smsc95xx_phy_wait_not_busy(struct ueth_data *dev)
+{
+	unsigned long start_time = get_timer(0);
+	u32 val;
+
+	do {
+		smsc95xx_read_reg(dev, MII_ADDR, &val);
+		if (!(val & MII_BUSY_))
+			return 0;
+	} while (get_timer(start_time) < 1 * 1000 * 1000);
+
+	return -1;
+}
+
+static int smsc95xx_mdio_read(struct ueth_data *dev, int phy_id, int idx)
+{
+	u32 val, addr;
+
+	/* confirm MII not busy */
+	if (smsc95xx_phy_wait_not_busy(dev)) {
+		debug("MII is busy in smsc95xx_mdio_read\n");
+		return -1;
+	}
+
+	/* set the address, index & direction (read from PHY) */
+	addr = (phy_id << 11) | (idx << 6) | MII_READ_;
+	smsc95xx_write_reg(dev, MII_ADDR, addr);
+
+	if (smsc95xx_phy_wait_not_busy(dev)) {
+		debug("Timed out reading MII reg %02X\n", idx);
+		return -1;
+	}
+
+	smsc95xx_read_reg(dev, MII_DATA, &val);
+
+	return (u16)(val & 0xFFFF);
+}
+
+static void smsc95xx_mdio_write(struct ueth_data *dev, int phy_id, int idx,
+				int regval)
+{
+	u32 val, addr;
+
+	/* confirm MII not busy */
+	if (smsc95xx_phy_wait_not_busy(dev)) {
+		debug("MII is busy in smsc95xx_mdio_write\n");
+		return;
+	}
+
+	val = regval;
+	smsc95xx_write_reg(dev, MII_DATA, val);
+
+	/* set the address, index & direction (write to PHY) */
+	addr = (phy_id << 11) | (idx << 6) | MII_WRITE_;
+	smsc95xx_write_reg(dev, MII_ADDR, addr);
+
+	if (smsc95xx_phy_wait_not_busy(dev))
+		debug("Timed out writing MII reg %02X\n", idx);
+}
+
+static int smsc95xx_eeprom_confirm_not_busy(struct ueth_data *dev)
+{
+	unsigned long start_time = get_timer(0);
+	u32 val;
+
+	do {
+		smsc95xx_read_reg(dev, E2P_CMD, &val);
+		if (!(val & E2P_CMD_LOADED_)) {
+			debug("No EEPROM present\n");
+			return -1;
+		}
+		if (!(val & E2P_CMD_BUSY_))
+			return 0;
+		udelay(40);
+	} while (get_timer(start_time) < 1 * 1000 * 1000);
+
+	debug("EEPROM is busy\n");
+	return -1;
+}
+
+static int smsc95xx_wait_eeprom(struct ueth_data *dev)
+{
+	unsigned long start_time = get_timer(0);
+	u32 val;
+
+	do {
+		smsc95xx_read_reg(dev, E2P_CMD, &val);
+		if (!(val & E2P_CMD_BUSY_) || (val & E2P_CMD_TIMEOUT_))
+			break;
+		udelay(40);
+	} while (get_timer(start_time) < 1 * 1000 * 1000);
+
+	if (val & (E2P_CMD_TIMEOUT_ | E2P_CMD_BUSY_)) {
+		debug("EEPROM read operation timeout\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int smsc95xx_read_eeprom(struct ueth_data *dev, u32 offset, u32 length,
+				u8 *data)
+{
+	u32 val;
+	int i, ret;
+
+	ret = smsc95xx_eeprom_confirm_not_busy(dev);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < length; i++) {
+		val = E2P_CMD_BUSY_ | E2P_CMD_READ_ | (offset & E2P_CMD_ADDR_);
+		smsc95xx_write_reg(dev, E2P_CMD, val);
+
+		ret = smsc95xx_wait_eeprom(dev);
+		if (ret < 0)
+			return ret;
+
+		smsc95xx_read_reg(dev, E2P_DATA, &val);
+		data[i] = val & 0xFF;
+		offset++;
+	}
+	return 0;
+}
+
+/*
+ * mii_nway_restart - restart NWay (autonegotiation) for this interface
+ *
+ * Returns 0 on success, negative on error.
+ */
+static int mii_nway_restart(struct ueth_data *dev)
+{
+	int bmcr;
+	int r = -1;
+
+	/* if autoneg is off, it's an error */
+	bmcr = smsc95xx_mdio_read(dev, dev->phy_id, MII_BMCR);
+
+	if (bmcr & BMCR_ANENABLE) {
+		bmcr |= BMCR_ANRESTART;
+		smsc95xx_mdio_write(dev, dev->phy_id, MII_BMCR, bmcr);
+		r = 0;
+	}
+	return r;
+}
+
+static int smsc95xx_phy_initialize(struct ueth_data *dev)
+{
+	smsc95xx_mdio_write(dev, dev->phy_id, MII_BMCR, BMCR_RESET);
+	smsc95xx_mdio_write(dev, dev->phy_id, MII_ADVERTISE,
+		ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP |
+		ADVERTISE_PAUSE_ASYM);
+
+	/* read to clear */
+	smsc95xx_mdio_read(dev, dev->phy_id, PHY_INT_SRC);
+
+	smsc95xx_mdio_write(dev, dev->phy_id, PHY_INT_MASK,
+		PHY_INT_MASK_DEFAULT_);
+	mii_nway_restart(dev);
+
+	debug("phy initialised succesfully\n");
+	return 0;
+}
+
+static int smsc95xx_init_mac_address(struct eth_device *eth,
+		struct ueth_data *dev)
+{
+	/* try reading mac address from EEPROM */
+	if (smsc95xx_read_eeprom(dev, EEPROM_MAC_OFFSET, ETH_ALEN,
+			eth->enetaddr) == 0) {
+		if (is_valid_ether_addr(eth->enetaddr)) {
+			/* eeprom values are valid so use them */
+			debug("MAC address read from EEPROM\n");
+			return 0;
+		}
+	}
+
+	/*
+	 * No eeprom, or eeprom values are invalid. Generating a random MAC
+	 * address is not safe. Just return an error.
+	 */
+	return -1;
+}
+
+static int smsc95xx_write_hwaddr(struct eth_device *eth)
+{
+	struct ueth_data *dev = (struct ueth_data *)eth->priv;
+	u32 addr_lo, addr_hi;
+	int ret;
+
+	/* set hardware address */
+	debug("** %s()\n", __func__);
+	addr_lo = cpu_to_le32(*((u32 *)eth->enetaddr));
+	addr_hi = cpu_to_le16(*((u16 *)(eth->enetaddr + 4)));
+	ret = smsc95xx_write_reg(dev, ADDRL, addr_lo);
+	if (ret < 0) {
+		debug("Failed to write ADDRL: %d\n", ret);
+		return ret;
+	}
+
+	ret = smsc95xx_write_reg(dev, ADDRH, addr_hi);
+	if (ret < 0)
+		return ret;
+	debug("MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
+		eth->enetaddr[0], eth->enetaddr[1],
+		eth->enetaddr[2], eth->enetaddr[3],
+		eth->enetaddr[4], eth->enetaddr[5]);
+	dev->have_hwaddr = 1;
+	return 0;
+}
+
+/* Enable or disable Tx & Rx checksum offload engines */
+static int smsc95xx_set_csums(struct ueth_data *dev,
+		int use_tx_csum, int use_rx_csum)
+{
+	u32 read_buf;
+	int ret = smsc95xx_read_reg(dev, COE_CR, &read_buf);
+	if (ret < 0)
+		return ret;
+
+	if (use_tx_csum)
+		read_buf |= Tx_COE_EN_;
+	else
+		read_buf &= ~Tx_COE_EN_;
+
+	if (use_rx_csum)
+		read_buf |= Rx_COE_EN_;
+	else
+		read_buf &= ~Rx_COE_EN_;
+
+	ret = smsc95xx_write_reg(dev, COE_CR, read_buf);
+	if (ret < 0)
+		return ret;
+
+	debug("COE_CR = 0x%08x\n", read_buf);
+	return 0;
+}
+
+static void smsc95xx_set_multicast(struct ueth_data *dev)
+{
+	/* No multicast in u-boot */
+	dev->mac_cr &= ~(MAC_CR_PRMS_ | MAC_CR_MCPAS_ | MAC_CR_HPFILT_);
+}
+
+/* starts the TX path */
+static void smsc95xx_start_tx_path(struct ueth_data *dev)
+{
+	u32 reg_val;
+
+	/* Enable Tx at MAC */
+	dev->mac_cr |= MAC_CR_TXEN_;
+
+	smsc95xx_write_reg(dev, MAC_CR, dev->mac_cr);
+
+	/* Enable Tx at SCSRs */
+	reg_val = TX_CFG_ON_;
+	smsc95xx_write_reg(dev, TX_CFG, reg_val);
+}
+
+/* Starts the Receive path */
+static void smsc95xx_start_rx_path(struct ueth_data *dev)
+{
+	dev->mac_cr |= MAC_CR_RXEN_;
+	smsc95xx_write_reg(dev, MAC_CR, dev->mac_cr);
+}
+
+/*
+ * Smsc95xx callbacks
+ */
+static int smsc95xx_init(struct eth_device *eth, bd_t *bd)
+{
+	int ret;
+	u32 write_buf;
+	u32 read_buf;
+	u32 burst_cap;
+	int timeout;
+	struct ueth_data *dev = (struct ueth_data *)eth->priv;
+#define TIMEOUT_RESOLUTION 50	/* ms */
+	int link_detected;
+
+	debug("** %s()\n", __func__);
+	dev->phy_id = SMSC95XX_INTERNAL_PHY_ID; /* fixed phy id */
+
+	write_buf = HW_CFG_LRST_;
+	ret = smsc95xx_write_reg(dev, HW_CFG, write_buf);
+	if (ret < 0)
+		return ret;
+
+	timeout = 0;
+	do {
+		ret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);
+		if (ret < 0)
+			return ret;
+		udelay(10 * 1000);
+		timeout++;
+	} while ((read_buf & HW_CFG_LRST_) && (timeout < 100));
+
+	if (timeout >= 100) {
+		debug("timeout waiting for completion of Lite Reset\n");
+		return -1;
+	}
+
+	write_buf = PM_CTL_PHY_RST_;
+	ret = smsc95xx_write_reg(dev, PM_CTRL, write_buf);
+	if (ret < 0)
+		return ret;
+
+	timeout = 0;
+	do {
+		ret = smsc95xx_read_reg(dev, PM_CTRL, &read_buf);
+		if (ret < 0)
+			return ret;
+		udelay(10 * 1000);
+		timeout++;
+	} while ((read_buf & PM_CTL_PHY_RST_) && (timeout < 100));
+	if (timeout >= 100) {
+		debug("timeout waiting for PHY Reset\n");
+		return -1;
+	}
+	if (!dev->have_hwaddr && smsc95xx_init_mac_address(eth, dev) == 0)
+		dev->have_hwaddr = 1;
+	if (!dev->have_hwaddr) {
+		puts("Error: SMSC95xx: No MAC address set - set usbethaddr\n");
+		return -1;
+	}
+	if (smsc95xx_write_hwaddr(eth) < 0)
+		return -1;
+
+	ret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);
+	if (ret < 0)
+		return ret;
+	debug("Read Value from HW_CFG : 0x%08x\n", read_buf);
+
+	read_buf |= HW_CFG_BIR_;
+	ret = smsc95xx_write_reg(dev, HW_CFG, read_buf);
+	if (ret < 0)
+		return ret;
+
+	ret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);
+	if (ret < 0)
+		return ret;
+	debug("Read Value from HW_CFG after writing "
+		"HW_CFG_BIR_: 0x%08x\n", read_buf);
+
+#ifdef TURBO_MODE
+	if (dev->pusb_dev->speed == USB_SPEED_HIGH) {
+		burst_cap = DEFAULT_HS_BURST_CAP_SIZE / HS_USB_PKT_SIZE;
+		dev->rx_urb_size = DEFAULT_HS_BURST_CAP_SIZE;
+	} else {
+		burst_cap = DEFAULT_FS_BURST_CAP_SIZE / FS_USB_PKT_SIZE;
+		dev->rx_urb_size = DEFAULT_FS_BURST_CAP_SIZE;
+	}
+#else
+	burst_cap = 0;
+	dev->rx_urb_size = MAX_SINGLE_PACKET_SIZE;
+#endif
+	debug("rx_urb_size=%ld\n", (ulong)dev->rx_urb_size);
+
+	ret = smsc95xx_write_reg(dev, BURST_CAP, burst_cap);
+	if (ret < 0)
+		return ret;
+
+	ret = smsc95xx_read_reg(dev, BURST_CAP, &read_buf);
+	if (ret < 0)
+		return ret;
+	debug("Read Value from BURST_CAP after writing: 0x%08x\n", read_buf);
+
+	read_buf = DEFAULT_BULK_IN_DELAY;
+	ret = smsc95xx_write_reg(dev, BULK_IN_DLY, read_buf);
+	if (ret < 0)
+		return ret;
+
+	ret = smsc95xx_read_reg(dev, BULK_IN_DLY, &read_buf);
+	if (ret < 0)
+		return ret;
+	debug("Read Value from BULK_IN_DLY after writing: "
+			"0x%08x\n", read_buf);
+
+	ret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);
+	if (ret < 0)
+		return ret;
+	debug("Read Value from HW_CFG: 0x%08x\n", read_buf);
+
+#ifdef TURBO_MODE
+	read_buf |= (HW_CFG_MEF_ | HW_CFG_BCE_);
+#endif
+	read_buf &= ~HW_CFG_RXDOFF_;
+
+#define NET_IP_ALIGN 0
+	read_buf |= NET_IP_ALIGN << 9;
+
+	ret = smsc95xx_write_reg(dev, HW_CFG, read_buf);
+	if (ret < 0)
+		return ret;
+
+	ret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);
+	if (ret < 0)
+		return ret;
+	debug("Read Value from HW_CFG after writing: 0x%08x\n", read_buf);
+
+	write_buf = 0xFFFFFFFF;
+	ret = smsc95xx_write_reg(dev, INT_STS, write_buf);
+	if (ret < 0)
+		return ret;
+
+	ret = smsc95xx_read_reg(dev, ID_REV, &read_buf);
+	if (ret < 0)
+		return ret;
+	debug("ID_REV = 0x%08x\n", read_buf);
+
+	/* Init Tx */
+	write_buf = 0;
+	ret = smsc95xx_write_reg(dev, FLOW, write_buf);
+	if (ret < 0)
+		return ret;
+
+	read_buf = AFC_CFG_DEFAULT;
+	ret = smsc95xx_write_reg(dev, AFC_CFG, read_buf);
+	if (ret < 0)
+		return ret;
+
+	ret = smsc95xx_read_reg(dev, MAC_CR, &dev->mac_cr);
+	if (ret < 0)
+		return ret;
+
+	/* Init Rx. Set Vlan */
+	write_buf = (u32)ETH_P_8021Q;
+	ret = smsc95xx_write_reg(dev, VLAN1, write_buf);
+	if (ret < 0)
+		return ret;
+
+	/* Disable checksum offload engines */
+	ret = smsc95xx_set_csums(dev, 0, 0);
+	if (ret < 0) {
+		debug("Failed to set csum offload: %d\n", ret);
+		return ret;
+	}
+	smsc95xx_set_multicast(dev);
+
+	if (smsc95xx_phy_initialize(dev) < 0)
+		return -1;
+	ret = smsc95xx_read_reg(dev, INT_EP_CTL, &read_buf);
+	if (ret < 0)
+		return ret;
+
+	/* enable PHY interrupts */
+	read_buf |= INT_EP_CTL_PHY_INT_;
+
+	ret = smsc95xx_write_reg(dev, INT_EP_CTL, read_buf);
+	if (ret < 0)
+		return ret;
+
+	smsc95xx_start_tx_path(dev);
+	smsc95xx_start_rx_path(dev);
+
+	timeout = 0;
+	do {
+		link_detected = smsc95xx_mdio_read(dev, dev->phy_id, MII_BMSR)
+			& BMSR_LSTATUS;
+		if (!link_detected) {
+			if (timeout == 0)
+				printf("Waiting for Ethernet connection... ");
+			udelay(TIMEOUT_RESOLUTION * 1000);
+			timeout += TIMEOUT_RESOLUTION;
+		}
+	} while (!link_detected && timeout < PHY_CONNECT_TIMEOUT);
+	if (link_detected) {
+		if (timeout != 0)
+			printf("done.\n");
+	} else {
+		printf("unable to connect.\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int smsc95xx_send(struct eth_device *eth, volatile void* packet,
+			 int length)
+{
+	struct ueth_data *dev = (struct ueth_data *)eth->priv;
+	int err;
+	int actual_len;
+	u32 tx_cmd_a;
+	u32 tx_cmd_b;
+	unsigned char msg[PKTSIZE + sizeof(tx_cmd_a) + sizeof(tx_cmd_b)];
+
+	debug("** %s(), len %d, buf %#x\n", __func__, length, (int)msg);
+	if (length > PKTSIZE)
+		return -1;
+
+	tx_cmd_a = (u32)length | TX_CMD_A_FIRST_SEG_ | TX_CMD_A_LAST_SEG_;
+	tx_cmd_b = (u32)length;
+	cpu_to_le32s(&tx_cmd_a);
+	cpu_to_le32s(&tx_cmd_b);
+
+	/* prepend cmd_a and cmd_b */
+	memcpy(msg, &tx_cmd_a, sizeof(tx_cmd_a));
+	memcpy(msg + sizeof(tx_cmd_a), &tx_cmd_b, sizeof(tx_cmd_b));
+	memcpy(msg + sizeof(tx_cmd_a) + sizeof(tx_cmd_b), (void *)packet,
+	       length);
+	err = usb_bulk_msg(dev->pusb_dev,
+				usb_sndbulkpipe(dev->pusb_dev, dev->ep_out),
+				(void *)msg,
+				length + sizeof(tx_cmd_a) + sizeof(tx_cmd_b),
+				&actual_len,
+				USB_BULK_SEND_TIMEOUT);
+	debug("Tx: len = %u, actual = %u, err = %d\n",
+	      length + sizeof(tx_cmd_a) + sizeof(tx_cmd_b),
+	      actual_len, err);
+	return err;
+}
+
+static int smsc95xx_recv(struct eth_device *eth)
+{
+	struct ueth_data *dev = (struct ueth_data *)eth->priv;
+	static unsigned char  recv_buf[AX_RX_URB_SIZE];
+	unsigned char *buf_ptr;
+	int err;
+	int actual_len;
+	u32 packet_len;
+	int cur_buf_align;
+
+	debug("** %s()\n", __func__);
+	err = usb_bulk_msg(dev->pusb_dev,
+				usb_rcvbulkpipe(dev->pusb_dev, dev->ep_in),
+				(void *)recv_buf,
+				AX_RX_URB_SIZE,
+				&actual_len,
+				USB_BULK_RECV_TIMEOUT);
+	debug("Rx: len = %u, actual = %u, err = %d\n", AX_RX_URB_SIZE,
+	      actual_len, err);
+	if (err != 0) {
+		debug("Rx: failed to receive\n");
+		return -1;
+	}
+	if (actual_len > AX_RX_URB_SIZE) {
+		debug("Rx: received too many bytes %d\n", actual_len);
+		return -1;
+	}
+
+	buf_ptr = recv_buf;
+	while (actual_len > 0) {
+		/*
+		 * 1st 4 bytes contain the length of the actual data plus error
+		 * info. Extract data length.
+		 */
+		if (actual_len < sizeof(packet_len)) {
+			debug("Rx: incomplete packet length\n");
+			return -1;
+		}
+		memcpy(&packet_len, buf_ptr, sizeof(packet_len));
+		le32_to_cpus(&packet_len);
+		if (packet_len & RX_STS_ES_) {
+			debug("Rx: Error header=%#x", packet_len);
+			return -1;
+		}
+		packet_len = ((packet_len & RX_STS_FL_) >> 16);
+
+		if (packet_len > actual_len - sizeof(packet_len)) {
+			debug("Rx: too large packet: %d\n", packet_len);
+			return -1;
+		}
+
+		/* Notify net stack */
+		NetReceive(buf_ptr + sizeof(packet_len), packet_len - 4);
+
+		/* Adjust for next iteration */
+		actual_len -= sizeof(packet_len) + packet_len;
+		buf_ptr += sizeof(packet_len) + packet_len;
+		cur_buf_align = (int)buf_ptr - (int)recv_buf;
+
+		if (cur_buf_align & 0x03) {
+			int align = 4 - (cur_buf_align & 0x03);
+
+			actual_len -= align;
+			buf_ptr += align;
+		}
+	}
+	return err;
+}
+
+static void smsc95xx_halt(struct eth_device *eth)
+{
+	debug("** %s()\n", __func__);
+}
+
+/*
+ * SMSC probing functions
+ */
+void smsc95xx_eth_before_probe(void)
+{
+	curr_eth_dev = 0;
+}
+
+struct smsc95xx_dongle {
+	unsigned short vendor;
+	unsigned short product;
+};
+
+static const struct smsc95xx_dongle smsc95xx_dongles[] = {
+	{ 0x0424, 0xec00 },	/* LAN9512/LAN9514 Ethernet */
+	{ 0x0424, 0x9500 },	/* LAN9500 Ethernet */
+	{ 0x0000, 0x0000 }	/* END - Do not remove */
+};
+
+/* Probe to see if a new device is actually an SMSC device */
+int smsc95xx_eth_probe(struct usb_device *dev, unsigned int ifnum,
+		      struct ueth_data *ss)
+{
+	struct usb_interface *iface;
+	struct usb_interface_descriptor *iface_desc;
+	int i;
+
+	/* let's examine the device now */
+	iface = &dev->config.if_desc[ifnum];
+	iface_desc = &dev->config.if_desc[ifnum].desc;
+
+	for (i = 0; smsc95xx_dongles[i].vendor != 0; i++) {
+		if (dev->descriptor.idVendor == smsc95xx_dongles[i].vendor &&
+		    dev->descriptor.idProduct == smsc95xx_dongles[i].product)
+			/* Found a supported dongle */
+			break;
+	}
+	if (smsc95xx_dongles[i].vendor == 0)
+		return 0;
+
+	/* At this point, we know we've got a live one */
+	debug("\n\nUSB Ethernet device detected\n");
+	memset(ss, '\0', sizeof(struct ueth_data));
+
+	/* Initialize the ueth_data structure with some useful info */
+	ss->ifnum = ifnum;
+	ss->pusb_dev = dev;
+	ss->subclass = iface_desc->bInterfaceSubClass;
+	ss->protocol = iface_desc->bInterfaceProtocol;
+
+	/*
+	 * We are expecting a minimum of 3 endpoints - in, out (bulk), and int.
+	 * We will ignore any others.
+	 */
+	for (i = 0; i < iface_desc->bNumEndpoints; i++) {
+		/* is it an BULK endpoint? */
+		if ((iface->ep_desc[i].bmAttributes &
+		     USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK) {
+			if (iface->ep_desc[i].bEndpointAddress & USB_DIR_IN)
+				ss->ep_in =
+					iface->ep_desc[i].bEndpointAddress &
+					USB_ENDPOINT_NUMBER_MASK;
+			else
+				ss->ep_out =
+					iface->ep_desc[i].bEndpointAddress &
+					USB_ENDPOINT_NUMBER_MASK;
+		}
+
+		/* is it an interrupt endpoint? */
+		if ((iface->ep_desc[i].bmAttributes &
+		    USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT) {
+			ss->ep_int = iface->ep_desc[i].bEndpointAddress &
+				USB_ENDPOINT_NUMBER_MASK;
+			ss->irqinterval = iface->ep_desc[i].bInterval;
+		}
+	}
+	debug("Endpoints In %d Out %d Int %d\n",
+		  ss->ep_in, ss->ep_out, ss->ep_int);
+
+	/* Do some basic sanity checks, and bail if we find a problem */
+	if (usb_set_interface(dev, iface_desc->bInterfaceNumber, 0) ||
+	    !ss->ep_in || !ss->ep_out || !ss->ep_int) {
+		debug("Problems with device\n");
+		return 0;
+	}
+	dev->privptr = (void *)ss;
+	return 1;
+}
+
+int smsc95xx_eth_get_info(struct usb_device *dev, struct ueth_data *ss,
+				struct eth_device *eth)
+{
+	debug("** %s()\n", __func__);
+	if (!eth) {
+		debug("%s: missing parameter.\n", __func__);
+		return 0;
+	}
+	sprintf(eth->name, "%s%d", SMSC95XX_BASE_NAME, curr_eth_dev++);
+	eth->init = smsc95xx_init;
+	eth->send = smsc95xx_send;
+	eth->recv = smsc95xx_recv;
+	eth->halt = smsc95xx_halt;
+	eth->write_hwaddr = smsc95xx_write_hwaddr;
+	eth->priv = ss;
+	return 1;
+}
diff -urN u-boot-2011.06/drivers/usb/eth/usb_ether.c u-boot-HEAD/drivers/usb/eth/usb_ether.c
--- u-boot-2011.06/drivers/usb/eth/usb_ether.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/usb/eth/usb_ether.c	2011-09-19 23:25:08.000000000 +0200
@@ -45,6 +45,13 @@
 		.get_info = asix_eth_get_info,
 	},
 #endif
+#ifdef CONFIG_USB_ETHER_SMSC95XX
+	{
+		.before_probe = smsc95xx_eth_before_probe,
+		.probe = smsc95xx_eth_probe,
+		.get_info = smsc95xx_eth_get_info,
+	},
+#endif
 	{ },		/* END */
 };
 
@@ -73,6 +80,7 @@
  */
 static void probe_valid_drivers(struct usb_device *dev)
 {
+	struct eth_device *eth;
 	int j;
 
 	for (j = 0; prob_dev[j].probe && prob_dev[j].get_info; j++) {
@@ -81,9 +89,10 @@
 		/*
 		 * ok, it is a supported eth device. Get info and fill it in
 		 */
+		eth = &usb_eth[usb_max_eth_dev].eth_dev;
 		if (prob_dev[j].get_info(dev,
 			&usb_eth[usb_max_eth_dev],
-			&usb_eth[usb_max_eth_dev].eth_dev)) {
+			eth)) {
 			/* found proper driver */
 			/* register with networking stack */
 			usb_max_eth_dev++;
@@ -93,7 +102,10 @@
 			 * call since eth_current_changed (internally called)
 			 * relies on it
 			 */
-			eth_register(&usb_eth[usb_max_eth_dev - 1].eth_dev);
+			eth_register(eth);
+			if (eth_write_hwaddr(eth, "usbeth",
+					usb_max_eth_dev - 1))
+				puts("Warning: failed to set MAC address\n");
 			break;
 			}
 		}
diff -urN u-boot-2011.06/drivers/usb/host/ehci.h u-boot-HEAD/drivers/usb/host/ehci.h
--- u-boot-2011.06/drivers/usb/host/ehci.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/usb/host/ehci.h	2011-09-19 23:25:08.000000000 +0200
@@ -55,7 +55,7 @@
 #define HCS_N_PORTS(p)		(((p) >> 0) & 0xf)
 	uint32_t cr_hccparams;
 	uint8_t cr_hcsp_portrt[8];
-} __attribute__ ((packed));
+} __attribute__ ((packed, aligned(4)));
 
 struct ehci_hcor {
 	uint32_t or_usbcmd;
@@ -85,7 +85,7 @@
 #define FLAG_CF		(1 << 0)	/* true:  we'll support "high speed" */
 	uint32_t or_portsc[CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS];
 	uint32_t or_systune;
-} __attribute__ ((packed));
+} __attribute__ ((packed, aligned(4)));
 
 #define USBMODE		0x68		/* USB Device mode */
 #define USBMODE_SDIS	(1 << 3)	/* Stream disable */
diff -urN u-boot-2011.06/drivers/usb/host/ehci-hcd.c u-boot-HEAD/drivers/usb/host/ehci-hcd.c
--- u-boot-2011.06/drivers/usb/host/ehci-hcd.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/usb/host/ehci-hcd.c	2011-09-19 23:25:08.000000000 +0200
@@ -461,7 +461,6 @@
 	/* Check that the TD processing happened */
 	if (token & 0x80) {
 		printf("EHCI timed out on TD - token=%#x\n", token);
-		goto fail;
 	}
 
 	/* Disable async schedule. */
diff -urN u-boot-2011.06/drivers/usb/host/ehci-mxc.c u-boot-HEAD/drivers/usb/host/ehci-mxc.c
--- u-boot-2011.06/drivers/usb/host/ehci-mxc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/usb/host/ehci-mxc.c	2011-09-19 23:25:08.000000000 +0200
@@ -29,6 +29,14 @@
 
 #define USBCTRL_OTGBASE_OFFSET	0x600
 
+#ifdef CONFIG_MX25
+#define MX25_USB_CTRL_IP_PUE_DOWN_BIT	(1<<6)
+#define MX25_USB_CTRL_HSTD_BIT		(1<<5)
+#define MX25_USB_CTRL_USBTE_BIT		(1<<4)
+#define MX25_USB_CTRL_OCPOL_OTG_BIT	(1<<3)
+#endif
+
+#ifdef CONFIG_MX31
 #define MX31_OTG_SIC_SHIFT	29
 #define MX31_OTG_SIC_MASK	(0x3 << MX31_OTG_SIC_SHIFT)
 #define MX31_OTG_PM_BIT		(1 << 24)
@@ -42,12 +50,19 @@
 #define MX31_H1_SIC_MASK	(0x3 << MX31_H1_SIC_SHIFT)
 #define MX31_H1_PM_BIT		(1 << 8)
 #define MX31_H1_DT_BIT		(1 << 4)
+#endif
 
 static int mxc_set_usbcontrol(int port, unsigned int flags)
 {
 	unsigned int v;
+
+#ifdef CONFIG_MX25
+	v = MX25_USB_CTRL_IP_PUE_DOWN_BIT | MX25_USB_CTRL_HSTD_BIT |
+		MX25_USB_CTRL_USBTE_BIT | MX25_USB_CTRL_OCPOL_OTG_BIT;
+#endif
+
 #ifdef CONFIG_MX31
-		v = readl(MX31_OTG_BASE_ADDR + USBCTRL_OTGBASE_OFFSET);
+		v = readl(IMX_USB_BASE + USBCTRL_OTGBASE_OFFSET);
 
 		switch (port) {
 		case 0:	/* OTG port */
@@ -85,36 +100,38 @@
 		default:
 			return -EINVAL;
 		}
-
-		writel(v, MX31_OTG_BASE_ADDR +
-				     USBCTRL_OTGBASE_OFFSET);
 #endif
-		return 0;
+
+	writel(v, IMX_USB_BASE + USBCTRL_OTGBASE_OFFSET);
+	return 0;
 }
 
 int ehci_hcd_init(void)
 {
-	u32 tmp;
 	struct usb_ehci *ehci;
+#ifdef CONFIG_MX31
+	u32 tmp;
 	struct clock_control_regs *sc_regs =
 		(struct clock_control_regs *)CCM_BASE;
 
 	tmp = __raw_readl(&sc_regs->ccmr);
 	__raw_writel(__raw_readl(&sc_regs->ccmr) | (1 << 9), &sc_regs->ccmr) ;
+#endif
 
 	udelay(80);
 
 	/* Take USB2 */
-	ehci = (struct usb_ehci *)(MX31_OTG_BASE_ADDR +
+	ehci = (struct usb_ehci *)(IMX_USB_BASE +
 		(0x200 * CONFIG_MXC_USB_PORT));
 	hccr = (struct ehci_hccr *)((uint32_t)&ehci->caplength);
 	hcor = (struct ehci_hcor *)((uint32_t) hccr +
 			HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
 	setbits_le32(&ehci->usbmode, CM_HOST);
+#ifdef CONFIG_MX31
 	setbits_le32(&ehci->control, USB_EN);
 
 	__raw_writel(CONFIG_MXC_USB_PORTSC, &ehci->portsc);
-
+#endif
 	mxc_set_usbcontrol(CONFIG_MXC_USB_PORT, CONFIG_MXC_USB_FLAGS);
 
 	udelay(10000);
diff -urN u-boot-2011.06/drivers/usb/host/r8a66597.h u-boot-HEAD/drivers/usb/host/r8a66597.h
--- u-boot-2011.06/drivers/usb/host/r8a66597.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/usb/host/r8a66597.h	2011-09-19 23:25:08.000000000 +0200
@@ -438,7 +438,7 @@
 
 	count = len / 4;
 	for (i = 0; i < count; i++)
-		inl(p[i], r8a66597->reg + offset);
+		p[i] = inl(r8a66597->reg + offset);
 
 	if (len & 0x00000003) {
 		unsigned long tmp = inl(fifoaddr);
diff -urN u-boot-2011.06/drivers/usb/musb/da8xx.h u-boot-HEAD/drivers/usb/musb/da8xx.h
--- u-boot-2011.06/drivers/usb/musb/da8xx.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/usb/musb/da8xx.h	2011-09-19 23:25:08.000000000 +0200
@@ -25,7 +25,7 @@
 #define __DA8XX_MUSB_H__
 
 #include <asm/arch/hardware.h>
-#include <asm/arch/gpio_defs.h>
+#include <asm/arch/gpio.h>
 #include "musb_core.h"
 
 /* Base address of da8xx usb0 wrapper */
diff -urN u-boot-2011.06/drivers/video/cfb_console.c u-boot-HEAD/drivers/video/cfb_console.c
--- u-boot-2011.06/drivers/video/cfb_console.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/video/cfb_console.c	2011-09-19 23:25:08.000000000 +0200
@@ -29,75 +29,83 @@
  * At the moment only the 8x16 font is tested and the font fore- and
  * background color is limited to black/white/gray colors. The Linux
  * logo can be placed in the upper left corner and additional board
- * information strings (that normaly goes to serial port) can be drawed.
+ * information strings (that normally goes to serial port) can be drawn.
  *
  * The console driver can use the standard PC keyboard interface (i8042)
  * for character input. Character output goes to a memory mapped video
  * framebuffer with little or big-endian organisation.
  * With environment setting 'console=serial' the console i/o can be
  * forced to serial port.
-
- The driver uses graphic specific defines/parameters/functions:
-
- (for SMI LynxE graphic chip)
-
- CONFIG_VIDEO_SMI_LYNXEM - use graphic driver for SMI 710,712,810
- VIDEO_FB_LITTLE_ENDIAN	 - framebuffer organisation default: big endian
- VIDEO_HW_RECTFILL	 - graphic driver supports hardware rectangle fill
- VIDEO_HW_BITBLT	 - graphic driver supports hardware bit blt
-
- Console Parameters are set by graphic drivers global struct:
-
- VIDEO_VISIBLE_COLS	     - x resolution
- VIDEO_VISIBLE_ROWS	     - y resolution
- VIDEO_PIXEL_SIZE	     - storage size in byte per pixel
- VIDEO_DATA_FORMAT	     - graphical data format GDF
- VIDEO_FB_ADRS		     - start of video memory
-
- CONFIG_I8042_KBD	     - AT Keyboard driver for i8042
- VIDEO_KBD_INIT_FCT	     - init function for keyboard
- VIDEO_TSTC_FCT		     - keyboard_tstc function
- VIDEO_GETC_FCT		     - keyboard_getc function
-
- CONFIG_CONSOLE_CURSOR	     - on/off drawing cursor is done with delay
-			       loop in VIDEO_TSTC_FCT (i8042)
- CONFIG_SYS_CONSOLE_BLINK_COUNT     - value for delay loop - blink rate
- CONFIG_CONSOLE_TIME	     - display time/date in upper right corner,
-			       needs CONFIG_CMD_DATE and CONFIG_CONSOLE_CURSOR
- CONFIG_VIDEO_LOGO	     - display Linux Logo in upper left corner
- CONFIG_VIDEO_BMP_LOGO	     - use bmp_logo instead of linux_logo
- CONFIG_CONSOLE_EXTRA_INFO   - display additional board information strings
-			       that normaly goes to serial port. This define
-			       requires a board specific function:
-			       video_drawstring (VIDEO_INFO_X,
-						 VIDEO_INFO_Y + i*VIDEO_FONT_HEIGHT,
-						 info);
-			       that fills a info buffer at i=row.
-			       s.a: board/eltec/bab7xx.
-CONFIG_VGA_AS_SINGLE_DEVICE  - If set the framebuffer device will be initialised
-			       as an output only device. The Keyboard driver
-			       will not be set-up. This may be used, if you
-			       have none or more than one Keyboard devices
-			       (USB Keyboard, AT Keyboard).
-
-CONFIG_VIDEO_SW_CURSOR:	     - Draws a cursor after the last character. No
-			       blinking is provided. Uses the macros CURSOR_SET
-			       and CURSOR_OFF.
-CONFIG_VIDEO_HW_CURSOR:	     - Uses the hardware cursor capability of the
-			       graphic chip. Uses the macro CURSOR_SET.
-			       ATTENTION: If booting an OS, the display driver
-			       must disable the hardware register of the graphic
-			       chip. Otherwise a blinking field is displayed
-*/
+ *
+ * The driver uses graphic specific defines/parameters/functions:
+ *
+ * (for SMI LynxE graphic chip)
+ *
+ * CONFIG_VIDEO_SMI_LYNXEM    - use graphic driver for SMI 710,712,810
+ * VIDEO_FB_LITTLE_ENDIAN     - framebuffer organisation default: big endian
+ * VIDEO_HW_RECTFILL	      - graphic driver supports hardware rectangle fill
+ * VIDEO_HW_BITBLT	      - graphic driver supports hardware bit blt
+ *
+ * Console Parameters are set by graphic drivers global struct:
+ *
+ * VIDEO_VISIBLE_COLS	      - x resolution
+ * VIDEO_VISIBLE_ROWS	      - y resolution
+ * VIDEO_PIXEL_SIZE	      - storage size in byte per pixel
+ * VIDEO_DATA_FORMAT	      - graphical data format GDF
+ * VIDEO_FB_ADRS	      - start of video memory
+ *
+ * CONFIG_I8042_KBD	      - AT Keyboard driver for i8042
+ * VIDEO_KBD_INIT_FCT	      - init function for keyboard
+ * VIDEO_TSTC_FCT	      - keyboard_tstc function
+ * VIDEO_GETC_FCT	      - keyboard_getc function
+ *
+ * CONFIG_CONSOLE_CURSOR      - on/off drawing cursor is done with
+ *				delay loop in VIDEO_TSTC_FCT (i8042)
+ *
+ * CONFIG_SYS_CONSOLE_BLINK_COUNT - value for delay loop - blink rate
+ * CONFIG_CONSOLE_TIME	      - display time/date in upper right
+ *				corner, needs CONFIG_CMD_DATE and
+ *				CONFIG_CONSOLE_CURSOR
+ * CONFIG_VIDEO_LOGO	      - display Linux Logo in upper left corner
+ * CONFIG_VIDEO_BMP_LOGO      - use bmp_logo instead of linux_logo
+ * CONFIG_CONSOLE_EXTRA_INFO  - display additional board information
+ *				strings that normaly goes to serial
+ *				port.  This define requires a board
+ *				specific function:
+ *				video_drawstring (VIDEO_INFO_X,
+ *					VIDEO_INFO_Y + i*VIDEO_FONT_HEIGHT,
+ *					info);
+ *				that fills a info buffer at i=row.
+ *				s.a: board/eltec/bab7xx.
+ * CONFIG_VGA_AS_SINGLE_DEVICE - If set the framebuffer device will be
+ *				initialized as an output only device.
+ *				The Keyboard driver will not be
+ *				set-up.  This may be used, if you have
+ *				no or more than one Keyboard devices
+ *				(USB Keyboard, AT Keyboard).
+ *
+ * CONFIG_VIDEO_SW_CURSOR:    - Draws a cursor after the last
+ *				character. No blinking is provided.
+ *				Uses the macros CURSOR_SET and
+ *				CURSOR_OFF.
+ *
+ * CONFIG_VIDEO_HW_CURSOR:    - Uses the hardware cursor capability
+ *				of the graphic chip. Uses the macro
+ *				CURSOR_SET. ATTENTION: If booting an
+ *				OS, the display driver must disable
+ *				the hardware register of the graphic
+ *				chip. Otherwise a blinking field is
+ *				displayed.
+ */
 
 #include <common.h>
-
+#include <version.h>
 #include <malloc.h>
 
-/*****************************************************************************/
-/* Console device defines with SMI graphic				     */
-/* Any other graphic must change this section				     */
-/*****************************************************************************/
+/*
+ * Console device defines with SMI graphic
+ * Any other graphic must change this section
+ */
 
 #ifdef	CONFIG_VIDEO_SMI_LYNXEM
 
@@ -106,9 +114,9 @@
 #define VIDEO_HW_BITBLT
 #endif
 
-/*****************************************************************************/
-/* Defines for the CT69000 driver					     */
-/*****************************************************************************/
+/*
+ * Defines for the CT69000 driver
+ */
 #ifdef	CONFIG_VIDEO_CT69000
 
 #define VIDEO_FB_LITTLE_ENDIAN
@@ -116,9 +124,9 @@
 #define VIDEO_HW_BITBLT
 #endif
 
-/*****************************************************************************/
-/* Defines for the SED13806 driver					     */
-/*****************************************************************************/
+/*
+ * Defines for the SED13806 driver
+ */
 #ifdef CONFIG_VIDEO_SED13806
 
 #ifndef CONFIG_TOTAL5200
@@ -128,9 +136,9 @@
 #define VIDEO_HW_BITBLT
 #endif
 
-/*****************************************************************************/
-/* Defines for the SED13806 driver					     */
-/*****************************************************************************/
+/*
+ * Defines for the SED13806 driver
+ */
 #ifdef CONFIG_VIDEO_SM501
 
 #ifdef CONFIG_HH405
@@ -138,9 +146,9 @@
 #endif
 #endif
 
-/*****************************************************************************/
-/* Defines for the MB862xx driver					     */
-/*****************************************************************************/
+/*
+ * Defines for the MB862xx driver
+ */
 #ifdef CONFIG_VIDEO_MB862xx
 
 #ifdef CONFIG_VIDEO_CORALP
@@ -152,24 +160,24 @@
 #endif
 #endif
 
-/*****************************************************************************/
-/* Include video_fb.h after definitions of VIDEO_HW_RECTFILL etc	     */
-/*****************************************************************************/
+/*
+ * Include video_fb.h after definitions of VIDEO_HW_RECTFILL etc.
+ */
 #include <video_fb.h>
 
-/*****************************************************************************/
-/* some Macros								     */
-/*****************************************************************************/
+/*
+ * some Macros
+ */
 #define VIDEO_VISIBLE_COLS	(pGD->winSizeX)
 #define VIDEO_VISIBLE_ROWS	(pGD->winSizeY)
 #define VIDEO_PIXEL_SIZE	(pGD->gdfBytesPP)
 #define VIDEO_DATA_FORMAT	(pGD->gdfIndex)
 #define VIDEO_FB_ADRS		(pGD->frameAdrs)
 
-/*****************************************************************************/
-/* Console device defines with i8042 keyboard controller		     */
-/* Any other keyboard controller must change this section		     */
-/*****************************************************************************/
+/*
+ * Console device defines with i8042 keyboard controller
+ * Any other keyboard controller must change this section
+ */
 
 #ifdef	CONFIG_I8042_KBD
 #include <i8042.h>
@@ -179,9 +187,9 @@
 #define VIDEO_GETC_FCT		i8042_getc
 #endif
 
-/*****************************************************************************/
-/* Console device							     */
-/*****************************************************************************/
+/*
+ * Console device
+ */
 
 #include <version.h>
 #include <linux/types.h>
@@ -202,20 +210,20 @@
 
 #endif
 
-/*****************************************************************************/
-/* Cursor definition:							     */
-/* CONFIG_CONSOLE_CURSOR:  Uses a timer function (see drivers/input/i8042.c) */
-/*                         to let the cursor blink. Uses the macros	     */
-/*                         CURSOR_OFF and CURSOR_ON.			     */
-/* CONFIG_VIDEO_SW_CURSOR: Draws a cursor after the last character. No	     */
-/*			   blinking is provided. Uses the macros CURSOR_SET  */
-/*			   and CURSOR_OFF.				     */
-/* CONFIG_VIDEO_HW_CURSOR: Uses the hardware cursor capability of the	     */
-/*			   graphic chip. Uses the macro CURSOR_SET.	     */
-/*			   ATTENTION: If booting an OS, the display driver   */
-/*			   must disable the hardware register of the graphic */
-/*			   chip. Otherwise a blinking field is displayed     */
-/*****************************************************************************/
+/*
+ * Cursor definition:
+ * CONFIG_CONSOLE_CURSOR:  Uses a timer function (see drivers/input/i8042.c)
+ *			   to let the cursor blink. Uses the macros
+ *			   CURSOR_OFF and CURSOR_ON.
+ * CONFIG_VIDEO_SW_CURSOR: Draws a cursor after the last character. No
+ *			   blinking is provided. Uses the macros CURSOR_SET
+ *			   and CURSOR_OFF.
+ * CONFIG_VIDEO_HW_CURSOR: Uses the hardware cursor capability of the
+ *			   graphic chip. Uses the macro CURSOR_SET.
+ *			   ATTENTION: If booting an OS, the display driver
+ *			   must disable the hardware register of the graphic
+ *			   chip. Otherwise a blinking field is displayed
+ */
 #if !defined(CONFIG_CONSOLE_CURSOR) && \
     !defined(CONFIG_VIDEO_SW_CURSOR) && \
     !defined(CONFIG_VIDEO_HW_CURSOR)
@@ -227,9 +235,11 @@
 
 #ifdef	CONFIG_CONSOLE_CURSOR
 #ifdef	CURSOR_ON
-#error	only one of CONFIG_CONSOLE_CURSOR,CONFIG_VIDEO_SW_CURSOR,CONFIG_VIDEO_HW_CURSOR can be defined
+#error	only one of CONFIG_CONSOLE_CURSOR, CONFIG_VIDEO_SW_CURSOR, \
+	or CONFIG_VIDEO_HW_CURSOR can be defined
 #endif
-void	console_cursor (int state);
+void console_cursor(int state);
+
 #define CURSOR_ON  console_cursor(1)
 #define CURSOR_OFF console_cursor(0)
 #define CURSOR_SET
@@ -244,7 +254,8 @@
 
 #ifdef	CONFIG_VIDEO_SW_CURSOR
 #ifdef	CURSOR_ON
-#error	only one of CONFIG_CONSOLE_CURSOR,CONFIG_VIDEO_SW_CURSOR,CONFIG_VIDEO_HW_CURSOR can be defined
+#error	only one of CONFIG_CONSOLE_CURSOR, CONFIG_VIDEO_SW_CURSOR, \
+	or CONFIG_VIDEO_HW_CURSOR can be defined
 #endif
 #define CURSOR_ON
 #define CURSOR_OFF video_putchar(console_col * VIDEO_FONT_WIDTH,\
@@ -255,13 +266,14 @@
 
 #ifdef CONFIG_VIDEO_HW_CURSOR
 #ifdef	CURSOR_ON
-#error	only one of CONFIG_CONSOLE_CURSOR,CONFIG_VIDEO_SW_CURSOR,CONFIG_VIDEO_HW_CURSOR can be defined
+#error	only one of CONFIG_CONSOLE_CURSOR, CONFIG_VIDEO_SW_CURSOR, \
+	or CONFIG_VIDEO_HW_CURSOR can be defined
 #endif
 #define CURSOR_ON
 #define CURSOR_OFF
 #define CURSOR_SET video_set_hw_cursor(console_col * VIDEO_FONT_WIDTH, \
 		  (console_row * VIDEO_FONT_HEIGHT) + video_logo_height)
-#endif	/* CONFIG_VIDEO_HW_CURSOR */
+#endif /* CONFIG_VIDEO_HW_CURSOR */
 
 #ifdef	CONFIG_VIDEO_LOGO
 #ifdef	CONFIG_VIDEO_BMP_LOGO
@@ -271,7 +283,7 @@
 #define VIDEO_LOGO_LUT_OFFSET	BMP_LOGO_OFFSET
 #define VIDEO_LOGO_COLORS	BMP_LOGO_COLORS
 
-#else	/* CONFIG_VIDEO_BMP_LOGO */
+#else  /* CONFIG_VIDEO_BMP_LOGO */
 #define LINUX_LOGO_WIDTH	80
 #define LINUX_LOGO_HEIGHT	80
 #define LINUX_LOGO_COLORS	214
@@ -282,13 +294,13 @@
 #define VIDEO_LOGO_HEIGHT	LINUX_LOGO_HEIGHT
 #define VIDEO_LOGO_LUT_OFFSET	LINUX_LOGO_LUT_OFFSET
 #define VIDEO_LOGO_COLORS	LINUX_LOGO_COLORS
-#endif	/* CONFIG_VIDEO_BMP_LOGO */
+#endif /* CONFIG_VIDEO_BMP_LOGO */
 #define VIDEO_INFO_X		(VIDEO_LOGO_WIDTH)
 #define VIDEO_INFO_Y		(VIDEO_FONT_HEIGHT/2)
-#else	/* CONFIG_VIDEO_LOGO */
+#else  /* CONFIG_VIDEO_LOGO */
 #define VIDEO_LOGO_WIDTH	0
 #define VIDEO_LOGO_HEIGHT	0
-#endif	/* CONFIG_VIDEO_LOGO */
+#endif /* CONFIG_VIDEO_LOGO */
 
 #define VIDEO_COLS		VIDEO_VISIBLE_COLS
 #define VIDEO_ROWS		VIDEO_VISIBLE_ROWS
@@ -313,101 +325,107 @@
 
 /* Macros */
 #ifdef	VIDEO_FB_LITTLE_ENDIAN
-#define SWAP16(x)	 ((((x) & 0x00ff) << 8) | ( (x) >> 8))
-#define SWAP32(x)	 ((((x) & 0x000000ff) << 24) | (((x) & 0x0000ff00) << 8)|\
-			  (((x) & 0x00ff0000) >>  8) | (((x) & 0xff000000) >> 24) )
-#define SHORTSWAP32(x)	 ((((x) & 0x000000ff) <<  8) | (((x) & 0x0000ff00) >> 8)|\
-			  (((x) & 0x00ff0000) <<  8) | (((x) & 0xff000000) >> 8) )
+#define SWAP16(x)		((((x) & 0x00ff) << 8) | \
+				  ((x) >> 8) \
+				)
+#define SWAP32(x)		((((x) & 0x000000ff) << 24) | \
+				 (((x) & 0x0000ff00) <<  8) | \
+				 (((x) & 0x00ff0000) >>  8) | \
+				 (((x) & 0xff000000) >> 24)   \
+				)
+#define SHORTSWAP32(x)		((((x) & 0x000000ff) <<  8) | \
+				 (((x) & 0x0000ff00) >>  8) | \
+				 (((x) & 0x00ff0000) <<  8) | \
+				 (((x) & 0xff000000) >>  8)   \
+				)
 #else
-#define SWAP16(x)	 (x)
-#define SWAP32(x)	 (x)
+#define SWAP16(x)		(x)
+#define SWAP32(x)		(x)
 #if defined(VIDEO_FB_16BPP_WORD_SWAP)
-#define SHORTSWAP32(x)	 ( ((x) >> 16) | ((x) << 16) )
+#define SHORTSWAP32(x)		(((x) >> 16) | ((x) << 16))
 #else
-#define SHORTSWAP32(x)	 (x)
+#define SHORTSWAP32(x)		(x)
 #endif
 #endif
 
-#if defined(DEBUG) || defined(DEBUG_CFB_CONSOLE)
-#define PRINTD(x)	  printf(x)
-#else
-#define PRINTD(x)
-#endif
-
-
 #ifdef CONFIG_CONSOLE_EXTRA_INFO
-extern void video_get_info_str (    /* setup a board string: type, speed, etc. */
-    int line_number,	    /* location to place info string beside logo */
-    char *info		    /* buffer for info string */
-    );
-
+/*
+ * setup a board string: type, speed, etc.
+ *
+ * line_number:	location to place info string beside logo
+ * info:	buffer for info string
+ */
+extern void video_get_info_str(int line_number,	char *info);
 #endif
 
 /* Locals */
 static GraphicDevice *pGD;	/* Pointer to Graphic array */
 
-static void *video_fb_address;		/* frame buffer address */
+static void *video_fb_address;	/* frame buffer address */
 static void *video_console_address;	/* console buffer start address */
 
 static int video_logo_height = VIDEO_LOGO_HEIGHT;
 
-static int console_col = 0; /* cursor col */
-static int console_row = 0; /* cursor row */
+static int console_col;		/* cursor col */
+static int console_row;		/* cursor row */
 
-static u32 eorx, fgx, bgx;  /* color pats */
+static u32 eorx, fgx, bgx;	/* color pats */
 
 static const int video_font_draw_table8[] = {
-	    0x00000000, 0x000000ff, 0x0000ff00, 0x0000ffff,
-	    0x00ff0000, 0x00ff00ff, 0x00ffff00, 0x00ffffff,
-	    0xff000000, 0xff0000ff, 0xff00ff00, 0xff00ffff,
-	    0xffff0000, 0xffff00ff, 0xffffff00, 0xffffffff };
+	0x00000000, 0x000000ff, 0x0000ff00, 0x0000ffff,
+	0x00ff0000, 0x00ff00ff, 0x00ffff00, 0x00ffffff,
+	0xff000000, 0xff0000ff, 0xff00ff00, 0xff00ffff,
+	0xffff0000, 0xffff00ff, 0xffffff00, 0xffffffff
+};
 
 static const int video_font_draw_table15[] = {
-	    0x00000000, 0x00007fff, 0x7fff0000, 0x7fff7fff };
+	0x00000000, 0x00007fff, 0x7fff0000, 0x7fff7fff
+};
 
 static const int video_font_draw_table16[] = {
-	    0x00000000, 0x0000ffff, 0xffff0000, 0xffffffff };
+	0x00000000, 0x0000ffff, 0xffff0000, 0xffffffff
+};
 
 static const int video_font_draw_table24[16][3] = {
-	    { 0x00000000, 0x00000000, 0x00000000 },
-	    { 0x00000000, 0x00000000, 0x00ffffff },
-	    { 0x00000000, 0x0000ffff, 0xff000000 },
-	    { 0x00000000, 0x0000ffff, 0xffffffff },
-	    { 0x000000ff, 0xffff0000, 0x00000000 },
-	    { 0x000000ff, 0xffff0000, 0x00ffffff },
-	    { 0x000000ff, 0xffffffff, 0xff000000 },
-	    { 0x000000ff, 0xffffffff, 0xffffffff },
-	    { 0xffffff00, 0x00000000, 0x00000000 },
-	    { 0xffffff00, 0x00000000, 0x00ffffff },
-	    { 0xffffff00, 0x0000ffff, 0xff000000 },
-	    { 0xffffff00, 0x0000ffff, 0xffffffff },
-	    { 0xffffffff, 0xffff0000, 0x00000000 },
-	    { 0xffffffff, 0xffff0000, 0x00ffffff },
-	    { 0xffffffff, 0xffffffff, 0xff000000 },
-	    { 0xffffffff, 0xffffffff, 0xffffffff } };
+	{0x00000000, 0x00000000, 0x00000000},
+	{0x00000000, 0x00000000, 0x00ffffff},
+	{0x00000000, 0x0000ffff, 0xff000000},
+	{0x00000000, 0x0000ffff, 0xffffffff},
+	{0x000000ff, 0xffff0000, 0x00000000},
+	{0x000000ff, 0xffff0000, 0x00ffffff},
+	{0x000000ff, 0xffffffff, 0xff000000},
+	{0x000000ff, 0xffffffff, 0xffffffff},
+	{0xffffff00, 0x00000000, 0x00000000},
+	{0xffffff00, 0x00000000, 0x00ffffff},
+	{0xffffff00, 0x0000ffff, 0xff000000},
+	{0xffffff00, 0x0000ffff, 0xffffffff},
+	{0xffffffff, 0xffff0000, 0x00000000},
+	{0xffffffff, 0xffff0000, 0x00ffffff},
+	{0xffffffff, 0xffffffff, 0xff000000},
+	{0xffffffff, 0xffffffff, 0xffffffff}
+};
 
 static const int video_font_draw_table32[16][4] = {
-	    { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
-	    { 0x00000000, 0x00000000, 0x00000000, 0x00ffffff },
-	    { 0x00000000, 0x00000000, 0x00ffffff, 0x00000000 },
-	    { 0x00000000, 0x00000000, 0x00ffffff, 0x00ffffff },
-	    { 0x00000000, 0x00ffffff, 0x00000000, 0x00000000 },
-	    { 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff },
-	    { 0x00000000, 0x00ffffff, 0x00ffffff, 0x00000000 },
-	    { 0x00000000, 0x00ffffff, 0x00ffffff, 0x00ffffff },
-	    { 0x00ffffff, 0x00000000, 0x00000000, 0x00000000 },
-	    { 0x00ffffff, 0x00000000, 0x00000000, 0x00ffffff },
-	    { 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000 },
-	    { 0x00ffffff, 0x00000000, 0x00ffffff, 0x00ffffff },
-	    { 0x00ffffff, 0x00ffffff, 0x00000000, 0x00000000 },
-	    { 0x00ffffff, 0x00ffffff, 0x00000000, 0x00ffffff },
-	    { 0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00000000 },
-	    { 0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00ffffff } };
-
+	{0x00000000, 0x00000000, 0x00000000, 0x00000000},
+	{0x00000000, 0x00000000, 0x00000000, 0x00ffffff},
+	{0x00000000, 0x00000000, 0x00ffffff, 0x00000000},
+	{0x00000000, 0x00000000, 0x00ffffff, 0x00ffffff},
+	{0x00000000, 0x00ffffff, 0x00000000, 0x00000000},
+	{0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff},
+	{0x00000000, 0x00ffffff, 0x00ffffff, 0x00000000},
+	{0x00000000, 0x00ffffff, 0x00ffffff, 0x00ffffff},
+	{0x00ffffff, 0x00000000, 0x00000000, 0x00000000},
+	{0x00ffffff, 0x00000000, 0x00000000, 0x00ffffff},
+	{0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000},
+	{0x00ffffff, 0x00000000, 0x00ffffff, 0x00ffffff},
+	{0x00ffffff, 0x00ffffff, 0x00000000, 0x00000000},
+	{0x00ffffff, 0x00ffffff, 0x00000000, 0x00ffffff},
+	{0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00000000},
+	{0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00ffffff}
+};
 
-/******************************************************************************/
 
-static void video_drawchars (int xx, int yy, unsigned char *s, int count)
+static void video_drawchars(int xx, int yy, unsigned char *s, int count)
 {
 	u8 *cdat, *dest, *dest0;
 	int rows, offset, c;
@@ -422,12 +440,15 @@
 			c = *s;
 			cdat = video_fontdata + c * VIDEO_FONT_HEIGHT;
 			for (rows = VIDEO_FONT_HEIGHT, dest = dest0;
-			     rows--;
-			     dest += VIDEO_LINE_LEN) {
+			     rows--; dest += VIDEO_LINE_LEN) {
 				u8 bits = *cdat++;
 
-				((u32 *) dest)[0] = (video_font_draw_table8[bits >> 4] & eorx) ^ bgx;
-				((u32 *) dest)[1] = (video_font_draw_table8[bits & 15] & eorx) ^ bgx;
+				((u32 *) dest)[0] =
+					(video_font_draw_table8[bits >> 4] &
+					 eorx) ^ bgx;
+				((u32 *) dest)[1] =
+					(video_font_draw_table8[bits & 15] &
+					 eorx) ^ bgx;
 			}
 			dest0 += VIDEO_FONT_WIDTH * VIDEO_PIXEL_SIZE;
 			s++;
@@ -439,14 +460,25 @@
 			c = *s;
 			cdat = video_fontdata + c * VIDEO_FONT_HEIGHT;
 			for (rows = VIDEO_FONT_HEIGHT, dest = dest0;
-			     rows--;
-			     dest += VIDEO_LINE_LEN) {
+			     rows--; dest += VIDEO_LINE_LEN) {
 				u8 bits = *cdat++;
 
-				((u32 *) dest)[0] = SHORTSWAP32 ((video_font_draw_table15 [bits >> 6] & eorx) ^ bgx);
-				((u32 *) dest)[1] = SHORTSWAP32 ((video_font_draw_table15 [bits >> 4 & 3] & eorx) ^ bgx);
-				((u32 *) dest)[2] = SHORTSWAP32 ((video_font_draw_table15 [bits >> 2 & 3] & eorx) ^ bgx);
-				((u32 *) dest)[3] = SHORTSWAP32 ((video_font_draw_table15 [bits & 3] & eorx) ^ bgx);
+				((u32 *) dest)[0] =
+					SHORTSWAP32((video_font_draw_table15
+						     [bits >> 6] & eorx) ^
+						    bgx);
+				((u32 *) dest)[1] =
+					SHORTSWAP32((video_font_draw_table15
+						     [bits >> 4 & 3] & eorx) ^
+						    bgx);
+				((u32 *) dest)[2] =
+					SHORTSWAP32((video_font_draw_table15
+						     [bits >> 2 & 3] & eorx) ^
+						    bgx);
+				((u32 *) dest)[3] =
+					SHORTSWAP32((video_font_draw_table15
+						     [bits & 3] & eorx) ^
+						    bgx);
 			}
 			dest0 += VIDEO_FONT_WIDTH * VIDEO_PIXEL_SIZE;
 			s++;
@@ -458,14 +490,25 @@
 			c = *s;
 			cdat = video_fontdata + c * VIDEO_FONT_HEIGHT;
 			for (rows = VIDEO_FONT_HEIGHT, dest = dest0;
-			     rows--;
-			     dest += VIDEO_LINE_LEN) {
+			     rows--; dest += VIDEO_LINE_LEN) {
 				u8 bits = *cdat++;
 
-				((u32 *) dest)[0] = SHORTSWAP32 ((video_font_draw_table16 [bits >> 6] & eorx) ^ bgx);
-				((u32 *) dest)[1] = SHORTSWAP32 ((video_font_draw_table16 [bits >> 4 & 3] & eorx) ^ bgx);
-				((u32 *) dest)[2] = SHORTSWAP32 ((video_font_draw_table16 [bits >> 2 & 3] & eorx) ^ bgx);
-				((u32 *) dest)[3] = SHORTSWAP32 ((video_font_draw_table16 [bits & 3] & eorx) ^ bgx);
+				((u32 *) dest)[0] =
+					SHORTSWAP32((video_font_draw_table16
+						     [bits >> 6] & eorx) ^
+						    bgx);
+				((u32 *) dest)[1] =
+					SHORTSWAP32((video_font_draw_table16
+						     [bits >> 4 & 3] & eorx) ^
+						    bgx);
+				((u32 *) dest)[2] =
+					SHORTSWAP32((video_font_draw_table16
+						     [bits >> 2 & 3] & eorx) ^
+						    bgx);
+				((u32 *) dest)[3] =
+					SHORTSWAP32((video_font_draw_table16
+						     [bits & 3] & eorx) ^
+						    bgx);
 			}
 			dest0 += VIDEO_FONT_WIDTH * VIDEO_PIXEL_SIZE;
 			s++;
@@ -477,18 +520,33 @@
 			c = *s;
 			cdat = video_fontdata + c * VIDEO_FONT_HEIGHT;
 			for (rows = VIDEO_FONT_HEIGHT, dest = dest0;
-			     rows--;
-			     dest += VIDEO_LINE_LEN) {
+			     rows--; dest += VIDEO_LINE_LEN) {
 				u8 bits = *cdat++;
 
-				((u32 *) dest)[0] = SWAP32 ((video_font_draw_table32 [bits >> 4][0] & eorx) ^ bgx);
-				((u32 *) dest)[1] = SWAP32 ((video_font_draw_table32 [bits >> 4][1] & eorx) ^ bgx);
-				((u32 *) dest)[2] = SWAP32 ((video_font_draw_table32 [bits >> 4][2] & eorx) ^ bgx);
-				((u32 *) dest)[3] = SWAP32 ((video_font_draw_table32 [bits >> 4][3] & eorx) ^ bgx);
-				((u32 *) dest)[4] = SWAP32 ((video_font_draw_table32 [bits & 15][0] & eorx) ^ bgx);
-				((u32 *) dest)[5] = SWAP32 ((video_font_draw_table32 [bits & 15][1] & eorx) ^ bgx);
-				((u32 *) dest)[6] = SWAP32 ((video_font_draw_table32 [bits & 15][2] & eorx) ^ bgx);
-				((u32 *) dest)[7] = SWAP32 ((video_font_draw_table32 [bits & 15][3] & eorx) ^ bgx);
+				((u32 *) dest)[0] =
+					SWAP32((video_font_draw_table32
+						[bits >> 4][0] & eorx) ^ bgx);
+				((u32 *) dest)[1] =
+					SWAP32((video_font_draw_table32
+						[bits >> 4][1] & eorx) ^ bgx);
+				((u32 *) dest)[2] =
+					SWAP32((video_font_draw_table32
+						[bits >> 4][2] & eorx) ^ bgx);
+				((u32 *) dest)[3] =
+					SWAP32((video_font_draw_table32
+						[bits >> 4][3] & eorx) ^ bgx);
+				((u32 *) dest)[4] =
+					SWAP32((video_font_draw_table32
+						[bits & 15][0] & eorx) ^ bgx);
+				((u32 *) dest)[5] =
+					SWAP32((video_font_draw_table32
+						[bits & 15][1] & eorx) ^ bgx);
+				((u32 *) dest)[6] =
+					SWAP32((video_font_draw_table32
+						[bits & 15][2] & eorx) ^ bgx);
+				((u32 *) dest)[7] =
+					SWAP32((video_font_draw_table32
+						[bits & 15][3] & eorx) ^ bgx);
 			}
 			dest0 += VIDEO_FONT_WIDTH * VIDEO_PIXEL_SIZE;
 			s++;
@@ -500,16 +558,27 @@
 			c = *s;
 			cdat = video_fontdata + c * VIDEO_FONT_HEIGHT;
 			for (rows = VIDEO_FONT_HEIGHT, dest = dest0;
-			     rows--;
-			     dest += VIDEO_LINE_LEN) {
+			     rows--; dest += VIDEO_LINE_LEN) {
 				u8 bits = *cdat++;
 
-				((u32 *) dest)[0] = (video_font_draw_table24[bits >> 4][0] & eorx) ^ bgx;
-				((u32 *) dest)[1] = (video_font_draw_table24[bits >> 4][1] & eorx) ^ bgx;
-				((u32 *) dest)[2] = (video_font_draw_table24[bits >> 4][2] & eorx) ^ bgx;
-				((u32 *) dest)[3] = (video_font_draw_table24[bits & 15][0] & eorx) ^ bgx;
-				((u32 *) dest)[4] = (video_font_draw_table24[bits & 15][1] & eorx) ^ bgx;
-				((u32 *) dest)[5] = (video_font_draw_table24[bits & 15][2] & eorx) ^ bgx;
+				((u32 *) dest)[0] =
+					(video_font_draw_table24[bits >> 4][0]
+					 & eorx) ^ bgx;
+				((u32 *) dest)[1] =
+					(video_font_draw_table24[bits >> 4][1]
+					 & eorx) ^ bgx;
+				((u32 *) dest)[2] =
+					(video_font_draw_table24[bits >> 4][2]
+					 & eorx) ^ bgx;
+				((u32 *) dest)[3] =
+					(video_font_draw_table24[bits & 15][0]
+					 & eorx) ^ bgx;
+				((u32 *) dest)[4] =
+					(video_font_draw_table24[bits & 15][1]
+					 & eorx) ^ bgx;
+				((u32 *) dest)[5] =
+					(video_font_draw_table24[bits & 15][2]
+					 & eorx) ^ bgx;
 			}
 			dest0 += VIDEO_FONT_WIDTH * VIDEO_PIXEL_SIZE;
 			s++;
@@ -518,23 +587,18 @@
 	}
 }
 
-/*****************************************************************************/
-
-static inline void video_drawstring (int xx, int yy, unsigned char *s)
+static inline void video_drawstring(int xx, int yy, unsigned char *s)
 {
-	video_drawchars (xx, yy, s, strlen ((char *)s));
+	video_drawchars(xx, yy, s, strlen((char *) s));
 }
 
-/*****************************************************************************/
-
-static void video_putchar (int xx, int yy, unsigned char c)
+static void video_putchar(int xx, int yy, unsigned char c)
 {
-	video_drawchars (xx, yy + video_logo_height, &c, 1);
+	video_drawchars(xx, yy + video_logo_height, &c, 1);
 }
 
-/*****************************************************************************/
 #if defined(CONFIG_CONSOLE_CURSOR) || defined(CONFIG_VIDEO_SW_CURSOR)
-static void video_set_cursor (void)
+static void video_set_cursor(void)
 {
 	/* swap drawing colors */
 	eorx = fgx;
@@ -542,9 +606,8 @@
 	bgx = eorx;
 	eorx = fgx ^ bgx;
 	/* draw cursor */
-	video_putchar (console_col * VIDEO_FONT_WIDTH,
-		       console_row * VIDEO_FONT_HEIGHT,
-		       ' ');
+	video_putchar(console_col * VIDEO_FONT_WIDTH,
+		      console_row * VIDEO_FONT_HEIGHT, ' ');
 	/* restore drawing colors */
 	eorx = fgx;
 	fgx = bgx;
@@ -552,9 +615,9 @@
 	eorx = fgx ^ bgx;
 }
 #endif
-/*****************************************************************************/
+
 #ifdef CONFIG_CONSOLE_CURSOR
-void console_cursor (int state)
+void console_cursor(int state)
 {
 	static int last_state = 0;
 
@@ -564,92 +627,88 @@
 
 	/* time update only if cursor is on (faster scroll) */
 	if (state) {
-		rtc_get (&tm);
+		rtc_get(&tm);
 
-		sprintf (info, " %02d:%02d:%02d ", tm.tm_hour, tm.tm_min,
-			 tm.tm_sec);
-		video_drawstring (VIDEO_VISIBLE_COLS - 10 * VIDEO_FONT_WIDTH,
-				  VIDEO_INFO_Y, (uchar *)info);
-
-		sprintf (info, "%02d.%02d.%04d", tm.tm_mday, tm.tm_mon,
-			 tm.tm_year);
-		video_drawstring (VIDEO_VISIBLE_COLS - 10 * VIDEO_FONT_WIDTH,
-				  VIDEO_INFO_Y + 1 * VIDEO_FONT_HEIGHT, (uchar *)info);
+		sprintf(info, " %02d:%02d:%02d ", tm.tm_hour, tm.tm_min,
+			tm.tm_sec);
+		video_drawstring(VIDEO_VISIBLE_COLS - 10 * VIDEO_FONT_WIDTH,
+				 VIDEO_INFO_Y, (uchar *) info);
+
+		sprintf(info, "%02d.%02d.%04d", tm.tm_mday, tm.tm_mon,
+			tm.tm_year);
+		video_drawstring(VIDEO_VISIBLE_COLS - 10 * VIDEO_FONT_WIDTH,
+				 VIDEO_INFO_Y + 1 * VIDEO_FONT_HEIGHT,
+				 (uchar *) info);
 	}
 #endif
 
 	if (state && (last_state != state)) {
-		video_set_cursor ();
+		video_set_cursor();
 	}
 
 	if (!state && (last_state != state)) {
 		/* clear cursor */
-		video_putchar (console_col * VIDEO_FONT_WIDTH,
-			       console_row * VIDEO_FONT_HEIGHT,
-			       ' ');
+		video_putchar(console_col * VIDEO_FONT_WIDTH,
+			      console_row * VIDEO_FONT_HEIGHT, ' ');
 	}
 
 	last_state = state;
 }
 #endif
 
-/*****************************************************************************/
-
 #ifndef VIDEO_HW_RECTFILL
-static void memsetl (int *p, int c, int v)
+static void memsetl(int *p, int c, int v)
 {
 	while (c--)
 		*(p++) = v;
 }
 #endif
 
-/*****************************************************************************/
-
 #ifndef VIDEO_HW_BITBLT
-static void memcpyl (int *d, int *s, int c)
+static void memcpyl(int *d, int *s, int c)
 {
 	while (c--)
 		*(d++) = *(s++);
 }
 #endif
 
-/*****************************************************************************/
-
-static void console_scrollup (void)
+static void console_scrollup(void)
 {
 	/* copy up rows ignoring the first one */
 
 #ifdef VIDEO_HW_BITBLT
-	video_hw_bitblt (VIDEO_PIXEL_SIZE,	/* bytes per pixel */
-			 0,	/* source pos x */
-			 video_logo_height + VIDEO_FONT_HEIGHT, /* source pos y */
-			 0,	/* dest pos x */
-			 video_logo_height,	/* dest pos y */
-			 VIDEO_VISIBLE_COLS,	/* frame width */
-			 VIDEO_VISIBLE_ROWS - video_logo_height - VIDEO_FONT_HEIGHT	/* frame height */
+	video_hw_bitblt(VIDEO_PIXEL_SIZE,	/* bytes per pixel */
+			0,			/* source pos x */
+			video_logo_height +
+				VIDEO_FONT_HEIGHT, /* source pos y */
+			0,			/* dest pos x */
+			video_logo_height,	/* dest pos y */
+			VIDEO_VISIBLE_COLS,	/* frame width */
+			VIDEO_VISIBLE_ROWS
+			- video_logo_height
+			- VIDEO_FONT_HEIGHT	/* frame height */
 		);
 #else
-	memcpyl (CONSOLE_ROW_FIRST, CONSOLE_ROW_SECOND,
-		 CONSOLE_SCROLL_SIZE >> 2);
+	memcpyl(CONSOLE_ROW_FIRST, CONSOLE_ROW_SECOND,
+		CONSOLE_SCROLL_SIZE >> 2);
 #endif
 
 	/* clear the last one */
 #ifdef VIDEO_HW_RECTFILL
-	video_hw_rectfill (VIDEO_PIXEL_SIZE,	/* bytes per pixel */
-			   0,	/* dest pos x */
-			   VIDEO_VISIBLE_ROWS - VIDEO_FONT_HEIGHT,	/* dest pos y */
-			   VIDEO_VISIBLE_COLS,	/* frame width */
-			   VIDEO_FONT_HEIGHT,	/* frame height */
-			   CONSOLE_BG_COL	/* fill color */
+	video_hw_rectfill(VIDEO_PIXEL_SIZE,	/* bytes per pixel */
+			  0,			/* dest pos x */
+			  VIDEO_VISIBLE_ROWS
+			  - VIDEO_FONT_HEIGHT,	/* dest pos y */
+			  VIDEO_VISIBLE_COLS,	/* frame width */
+			  VIDEO_FONT_HEIGHT,	/* frame height */
+			  CONSOLE_BG_COL	/* fill color */
 		);
 #else
-	memsetl (CONSOLE_ROW_LAST, CONSOLE_ROW_SIZE >> 2, CONSOLE_BG_COL);
+	memsetl(CONSOLE_ROW_LAST, CONSOLE_ROW_SIZE >> 2, CONSOLE_BG_COL);
 #endif
 }
 
-/*****************************************************************************/
-
-static void console_back (void)
+static void console_back(void)
 {
 	CURSOR_OFF;
 	console_col--;
@@ -660,14 +719,11 @@
 		if (console_row < 0)
 			console_row = 0;
 	}
-	video_putchar (console_col * VIDEO_FONT_WIDTH,
-		       console_row * VIDEO_FONT_HEIGHT,
-		       ' ');
+	video_putchar(console_col * VIDEO_FONT_WIDTH,
+		      console_row * VIDEO_FONT_HEIGHT, ' ');
 }
 
-/*****************************************************************************/
-
-static void console_newline (void)
+static void console_newline(void)
 {
 	/* Check if last character in the line was just drawn. If so, cursor was
 	   overwriten and need not to be cleared. Cursor clearing without this
@@ -682,33 +738,31 @@
 	/* Check if we need to scroll the terminal */
 	if (console_row >= CONSOLE_ROWS) {
 		/* Scroll everything up */
-		console_scrollup ();
+		console_scrollup();
 
 		/* Decrement row number */
 		console_row--;
 	}
 }
 
-static void console_cr (void)
+static void console_cr(void)
 {
 	CURSOR_OFF;
 	console_col = 0;
 }
 
-/*****************************************************************************/
-
-void video_putc (const char c)
+void video_putc(const char c)
 {
 	static int nl = 1;
 
 	switch (c) {
 	case 13:		/* back to first column */
-		console_cr ();
+		console_cr();
 		break;
 
 	case '\n':		/* next line */
 		if (console_col || (!console_col && nl))
-			console_newline ();
+			console_newline();
 		nl = 1;
 		break;
 
@@ -718,52 +772,47 @@
 		console_col &= ~0x0007;
 
 		if (console_col >= CONSOLE_COLS)
-			console_newline ();
+			console_newline();
 		break;
 
 	case 8:		/* backspace */
-		console_back ();
+		console_back();
 		break;
 
 	default:		/* draw the char */
-		video_putchar (console_col * VIDEO_FONT_WIDTH,
-			       console_row * VIDEO_FONT_HEIGHT,
-			       c);
+		video_putchar(console_col * VIDEO_FONT_WIDTH,
+			      console_row * VIDEO_FONT_HEIGHT, c);
 		console_col++;
 
 		/* check for newline */
 		if (console_col >= CONSOLE_COLS) {
-			console_newline ();
+			console_newline();
 			nl = 0;
 		}
 	}
 	CURSOR_SET;
 }
 
-
-/*****************************************************************************/
-
-void video_puts (const char *s)
+void video_puts(const char *s)
 {
-	int count = strlen (s);
+	int count = strlen(s);
 
 	while (count--)
-		video_putc (*s++);
+		video_putc(*s++);
 }
 
-/*****************************************************************************/
-
 /*
  * Do not enforce drivers (or board code) to provide empty
  * video_set_lut() if they do not support 8 bpp format.
  * Implement weak default function instead.
  */
-void __video_set_lut (unsigned int index, unsigned char r,
-		      unsigned char g, unsigned char b)
+void __video_set_lut(unsigned int index, unsigned char r,
+		     unsigned char g, unsigned char b)
 {
 }
-void video_set_lut (unsigned int, unsigned char, unsigned char, unsigned char)
-			__attribute__((weak, alias("__video_set_lut")));
+
+void video_set_lut(unsigned int, unsigned char, unsigned char, unsigned char)
+	__attribute__ ((weak, alias("__video_set_lut")));
 
 #if defined(CONFIG_CMD_BMP) || defined(CONFIG_SPLASH_SCREEN)
 
@@ -773,17 +822,26 @@
 }
 
 #define FILL_15BIT_555RGB(r,g,b) {			\
-	*(unsigned short *)fb = SWAP16((unsigned short)(((r>>3)<<10) | ((g>>3)<<5) | (b>>3))); \
+	*(unsigned short *)fb =				\
+		SWAP16((unsigned short)(((r>>3)<<10) |	\
+					((g>>3)<<5)  |	\
+					 (b>>3)));	\
 	fb += 2;					\
 }
 
 #define FILL_16BIT_565RGB(r,g,b) {			\
-	*(unsigned short *)fb = SWAP16((unsigned short)((((r)>>3)<<11) | (((g)>>2)<<5) | ((b)>>3))); \
+	*(unsigned short *)fb =				\
+		SWAP16((unsigned short)((((r)>>3)<<11)| \
+					(((g)>>2)<<5) | \
+					 ((b)>>3)));	\
 	fb += 2;					\
 }
 
 #define FILL_32BIT_X888RGB(r,g,b) {			\
-	*(unsigned long *)fb = SWAP32((unsigned long)(((r<<16) | (g<<8) | b))); \
+	*(unsigned long *)fb =				\
+		SWAP32((unsigned long)(((r<<16) |	\
+					(g<<8)  |	\
+					 b)));		\
 	fb += 4;					\
 }
 
@@ -804,13 +862,12 @@
 #endif
 
 #if defined(VIDEO_FB_16BPP_PIXEL_SWAP)
-static void inline fill_555rgb_pswap(uchar *fb, int x,
-				     u8 r, u8 g, u8 b)
+static inline void fill_555rgb_pswap(uchar *fb, int x, u8 r, u8 g, u8 b)
 {
-	ushort *dst = (ushort *)fb;
-	ushort color = (ushort)(((r >> 3) << 10) |
-				((g >> 3) << 5) |
-				(b >> 3));
+	ushort *dst = (ushort *) fb;
+	ushort color = (ushort) (((r >> 3) << 10) |
+				 ((g >> 3) <<  5) |
+				  (b >> 3));
 	if (x & 1)
 		*(--dst) = color;
 	else
@@ -826,18 +883,18 @@
 /* Pre-calculated color table entry */
 struct palette {
 	union {
-		unsigned short	w;	/* word */
-		unsigned int	dw;	/* double word */
-	} ce; /* color entry */
+		unsigned short w;	/* word */
+		unsigned int dw;	/* double word */
+	} ce;				/* color entry */
 };
 
 /*
  * Helper to draw encoded/unencoded run.
  */
-static void draw_bitmap (uchar **fb, uchar *bm, struct palette *p,
-			 int cnt, int enc)
+static void draw_bitmap(uchar **fb, uchar *bm, struct palette *p,
+			int cnt, int enc)
 {
-	ulong addr = (ulong)*fb;
+	ulong addr = (ulong) *fb;
 	int *off;
 	int enc_off = 1;
 	int i;
@@ -851,28 +908,28 @@
 	switch (VIDEO_DATA_FORMAT) {
 	case GDF__8BIT_INDEX:
 		for (i = 0; i < cnt; i++)
-			*(unsigned char *)addr++ = bm[*off];
+			*(unsigned char *) addr++ = bm[*off];
 		break;
 	case GDF_15BIT_555RGB:
 	case GDF_16BIT_565RGB:
 		/* differences handled while pre-calculating palette */
 		for (i = 0; i < cnt; i++) {
-			*(unsigned short *)addr = p[bm[*off]].ce.w;
+			*(unsigned short *) addr = p[bm[*off]].ce.w;
 			addr += 2;
 		}
 		break;
 	case GDF_32BIT_X888RGB:
 		for (i = 0; i < cnt; i++) {
-			*(unsigned long *)addr = p[bm[*off]].ce.dw;
+			*(unsigned long *) addr = p[bm[*off]].ce.dw;
 			addr += 4;
 		}
 		break;
 	}
-	*fb = (uchar *)addr; /* return modified address */
+	*fb = (uchar *) addr;	/* return modified address */
 }
 
-static int display_rle8_bitmap (bmp_image_t *img, int xoff, int yoff,
-				int width, int height)
+static int display_rle8_bitmap(bmp_image_t *img, int xoff, int yoff,
+			       int width, int height)
 {
 	unsigned char *bm;
 	unsigned char *fbp;
@@ -889,17 +946,17 @@
 	y = __le32_to_cpu(img->header.height) - 1;
 	ncolors = __le32_to_cpu(img->header.colors_used);
 	bpp = VIDEO_PIXEL_SIZE;
-	fbp = (unsigned char *)((unsigned int)video_fb_address +
-				(((y + yoff) * VIDEO_COLS) + xoff) * bpp);
+	fbp = (unsigned char *) ((unsigned int) video_fb_address +
+				 (((y + yoff) * VIDEO_COLS) + xoff) * bpp);
 
-	bm = (uchar *)img + __le32_to_cpu(img->header.data_offset);
+	bm = (uchar *) img + __le32_to_cpu(img->header.data_offset);
 
 	/* pre-calculate and setup palette */
 	switch (VIDEO_DATA_FORMAT) {
 	case GDF__8BIT_INDEX:
 		for (i = 0; i < ncolors; i++) {
 			cte = img->color_table[i];
-			video_set_lut (i, cte.red, cte.green, cte.blue);
+			video_set_lut(i, cte.red, cte.green, cte.blue);
 		}
 		break;
 	case GDF_15BIT_555RGB:
@@ -922,13 +979,14 @@
 	case GDF_32BIT_X888RGB:
 		for (i = 0; i < ncolors; i++) {
 			cte = img->color_table[i];
-			p[i].ce.dw = SWAP32((cte.red << 16) | (cte.green << 8) |
+			p[i].ce.dw = SWAP32((cte.red << 16) |
+					    (cte.green << 8) |
 					     cte.blue);
 		}
 		break;
 	default:
 		printf("RLE Bitmap unsupported in video mode 0x%x\n",
-			VIDEO_DATA_FORMAT);
+		       VIDEO_DATA_FORMAT);
 		return -1;
 	}
 
@@ -942,7 +1000,7 @@
 				x = 0;
 				y--;
 				fbp = (unsigned char *)
-					((unsigned int)video_fb_address +
+					((unsigned int) video_fb_address +
 					 (((y + yoff) * VIDEO_COLS) +
 					  xoff) * bpp);
 				continue;
@@ -955,7 +1013,7 @@
 				x += bm[2];
 				y -= bm[3];
 				fbp = (unsigned char *)
-					((unsigned int)video_fb_address +
+					((unsigned int) video_fb_address +
 					 (((y + yoff) * VIDEO_COLS) +
 					  x + xoff) * bpp);
 				bm += 4;
@@ -976,13 +1034,13 @@
 					}
 					if (x + runlen > width)
 						cnt = width - x;
-					draw_bitmap (&fbp, bm, p, cnt, 0);
+					draw_bitmap(&fbp, bm, p, cnt, 0);
 					x += runlen;
 				}
 next_run:
 				bm += runlen;
 				if (runlen & 1)
-					bm++; /* 0 padding if length is odd */
+					bm++;	/* 0 padding if length is odd */
 			}
 			break;
 		default:
@@ -993,7 +1051,7 @@
 			if (pixels > limit)
 				goto error;
 
-			if (y < height) { /* only draw into visible area */
+			if (y < height) {     /* only draw into visible area */
 				if (x >= width) {
 					x += runlen;
 					bm += 2;
@@ -1001,7 +1059,7 @@
 				}
 				if (x + runlen > width)
 					cnt = width - x;
-				draw_bitmap (&fbp, bm, p, cnt, 1);
+				draw_bitmap(&fbp, bm, p, cnt, 1);
 				x += runlen;
 			}
 			bm += 2;
@@ -1018,7 +1076,7 @@
 /*
  * Display the BMP file located at address bmp_image.
  */
-int video_display_bitmap (ulong bmp_image, int x, int y)
+int video_display_bitmap(ulong bmp_image, int x, int y)
 {
 	ushort xcount, ycount;
 	uchar *fb;
@@ -1029,12 +1087,13 @@
 	unsigned colors;
 	unsigned long compression;
 	bmp_color_table_entry_t cte;
+
 #ifdef CONFIG_VIDEO_BMP_GZIP
 	unsigned char *dst = NULL;
 	ulong len;
 #endif
 
-	WATCHDOG_RESET ();
+	WATCHDOG_RESET();
 
 	if (!((bmp->header.signature[0] == 'B') &&
 	      (bmp->header.signature[1] == 'M'))) {
@@ -1047,50 +1106,55 @@
 		dst = malloc(CONFIG_SYS_VIDEO_LOGO_MAX_SIZE);
 		if (dst == NULL) {
 			printf("Error: malloc in gunzip failed!\n");
-			return(1);
+			return 1;
 		}
-		if (gunzip(dst, CONFIG_SYS_VIDEO_LOGO_MAX_SIZE, (uchar *)bmp_image, &len) != 0) {
-			printf ("Error: no valid bmp or bmp.gz image at %lx\n", bmp_image);
+		if (gunzip(dst, CONFIG_SYS_VIDEO_LOGO_MAX_SIZE,
+			   (uchar *) bmp_image,
+			   &len) != 0) {
+			printf("Error: no valid bmp or bmp.gz image at %lx\n",
+			       bmp_image);
 			free(dst);
 			return 1;
 		}
 		if (len == CONFIG_SYS_VIDEO_LOGO_MAX_SIZE) {
-			printf("Image could be truncated (increase CONFIG_SYS_VIDEO_LOGO_MAX_SIZE)!\n");
+			printf("Image could be truncated "
+				"(increase CONFIG_SYS_VIDEO_LOGO_MAX_SIZE)!\n");
 		}
 
 		/*
 		 * Set addr to decompressed image
 		 */
-		bmp = (bmp_image_t *)dst;
+		bmp = (bmp_image_t *) dst;
 
 		if (!((bmp->header.signature[0] == 'B') &&
 		      (bmp->header.signature[1] == 'M'))) {
-			printf ("Error: no valid bmp.gz image at %lx\n", bmp_image);
+			printf("Error: no valid bmp.gz image at %lx\n",
+			       bmp_image);
 			free(dst);
 			return 1;
 		}
 #else
-		printf ("Error: no valid bmp image at %lx\n", bmp_image);
+		printf("Error: no valid bmp image at %lx\n", bmp_image);
 		return 1;
 #endif /* CONFIG_VIDEO_BMP_GZIP */
 	}
 
-	width = le32_to_cpu (bmp->header.width);
-	height = le32_to_cpu (bmp->header.height);
-	bpp = le16_to_cpu (bmp->header.bit_count);
-	colors = le32_to_cpu (bmp->header.colors_used);
-	compression = le32_to_cpu (bmp->header.compression);
+	width = le32_to_cpu(bmp->header.width);
+	height = le32_to_cpu(bmp->header.height);
+	bpp = le16_to_cpu(bmp->header.bit_count);
+	colors = le32_to_cpu(bmp->header.colors_used);
+	compression = le32_to_cpu(bmp->header.compression);
 
-	debug ("Display-bmp: %d x %d  with %d colors\n",
-	       width, height, colors);
+	debug("Display-bmp: %d x %d  with %d colors\n",
+	      width, height, colors);
 
 	if (compression != BMP_BI_RGB
 #ifdef CONFIG_VIDEO_BMP_RLE8
 	    && compression != BMP_BI_RLE8
 #endif
-	   ) {
-		printf ("Error: compression type %ld not supported\n",
-			compression);
+		) {
+		printf("Error: compression type %ld not supported\n",
+		       compression);
 #ifdef CONFIG_VIDEO_BMP_GZIP
 		if (dst)
 			free(dst);
@@ -1117,20 +1181,19 @@
 	if ((y + height) > VIDEO_VISIBLE_ROWS)
 		height = VIDEO_VISIBLE_ROWS - y;
 
-	bmap = (uchar *) bmp + le32_to_cpu (bmp->header.data_offset);
+	bmap = (uchar *) bmp + le32_to_cpu(bmp->header.data_offset);
 	fb = (uchar *) (video_fb_address +
 			((y + height - 1) * VIDEO_COLS * VIDEO_PIXEL_SIZE) +
 			x * VIDEO_PIXEL_SIZE);
 
 #ifdef CONFIG_VIDEO_BMP_RLE8
 	if (compression == BMP_BI_RLE8) {
-		return display_rle8_bitmap(bmp,
-					   x, y, width, height);
+		return display_rle8_bitmap(bmp, x, y, width, height);
 	}
 #endif
 
 	/* We handle only 4, 8, or 24 bpp bitmaps */
-	switch (le16_to_cpu (bmp->header.bit_count)) {
+	switch (le16_to_cpu(bmp->header.bit_count)) {
 	case 4:
 		padded_line -= width / 2;
 		ycount = height;
@@ -1138,7 +1201,7 @@
 		switch (VIDEO_DATA_FORMAT) {
 		case GDF_32BIT_X888RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				/*
 				 * Don't assume that 'width' is an
 				 * even number
@@ -1157,7 +1220,7 @@
 				}
 				bmap += padded_line;
 				fb -= (VIDEO_VISIBLE_COLS + width) *
-				      VIDEO_PIXEL_SIZE;
+					VIDEO_PIXEL_SIZE;
 			}
 			break;
 		default:
@@ -1173,32 +1236,36 @@
 			/* Copy colormap */
 			for (xcount = 0; xcount < colors; ++xcount) {
 				cte = bmp->color_table[xcount];
-				video_set_lut (xcount, cte.red, cte.green, cte.blue);
+				video_set_lut(xcount, cte.red, cte.green,
+					      cte.blue);
 			}
 		}
 		ycount = height;
 		switch (VIDEO_DATA_FORMAT) {
 		case GDF__8BIT_INDEX:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
 					*fb++ = *bmap++;
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF__8BIT_332RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
 					cte = bmp->color_table[*bmap++];
-					FILL_8BIT_332RGB (cte.red, cte.green, cte.blue);
+					FILL_8BIT_332RGB(cte.red, cte.green,
+							 cte.blue);
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF_15BIT_555RGB:
@@ -1206,56 +1273,65 @@
 #if defined(VIDEO_FB_16BPP_PIXEL_SWAP)
 				int xpos = x;
 #endif
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
 					cte = bmp->color_table[*bmap++];
 #if defined(VIDEO_FB_16BPP_PIXEL_SWAP)
-					fill_555rgb_pswap (fb, xpos++, cte.red,
-							   cte.green, cte.blue);
+					fill_555rgb_pswap(fb, xpos++, cte.red,
+							  cte.green,
+							  cte.blue);
 					fb += 2;
 #else
-					FILL_15BIT_555RGB (cte.red, cte.green, cte.blue);
+					FILL_15BIT_555RGB(cte.red, cte.green,
+							  cte.blue);
 #endif
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF_16BIT_565RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
 					cte = bmp->color_table[*bmap++];
-					FILL_16BIT_565RGB (cte.red, cte.green, cte.blue);
+					FILL_16BIT_565RGB(cte.red, cte.green,
+							  cte.blue);
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF_32BIT_X888RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
 					cte = bmp->color_table[*bmap++];
-					FILL_32BIT_X888RGB (cte.red, cte.green, cte.blue);
+					FILL_32BIT_X888RGB(cte.red, cte.green,
+							   cte.blue);
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF_24BIT_888RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
 					cte = bmp->color_table[*bmap++];
-					FILL_24BIT_888RGB (cte.red, cte.green, cte.blue);
+					FILL_24BIT_888RGB(cte.red, cte.green,
+							  cte.blue);
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		}
@@ -1266,14 +1342,16 @@
 		switch (VIDEO_DATA_FORMAT) {
 		case GDF__8BIT_332RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
-					FILL_8BIT_332RGB (bmap[2], bmap[1], bmap[0]);
+					FILL_8BIT_332RGB(bmap[2], bmap[1],
+							 bmap[0]);
 					bmap += 3;
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF_15BIT_555RGB:
@@ -1281,66 +1359,75 @@
 #if defined(VIDEO_FB_16BPP_PIXEL_SWAP)
 				int xpos = x;
 #endif
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
 #if defined(VIDEO_FB_16BPP_PIXEL_SWAP)
-					fill_555rgb_pswap (fb, xpos++, bmap[2],
-							   bmap[1], bmap[0]);
+					fill_555rgb_pswap(fb, xpos++, bmap[2],
+							  bmap[1], bmap[0]);
 					fb += 2;
 #else
-					FILL_15BIT_555RGB (bmap[2], bmap[1], bmap[0]);
+					FILL_15BIT_555RGB(bmap[2], bmap[1],
+							  bmap[0]);
 #endif
 					bmap += 3;
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF_16BIT_565RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
-					FILL_16BIT_565RGB (bmap[2], bmap[1], bmap[0]);
+					FILL_16BIT_565RGB(bmap[2], bmap[1],
+							  bmap[0]);
 					bmap += 3;
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF_32BIT_X888RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
-					FILL_32BIT_X888RGB (bmap[2], bmap[1], bmap[0]);
+					FILL_32BIT_X888RGB(bmap[2], bmap[1],
+							   bmap[0]);
 					bmap += 3;
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		case GDF_24BIT_888RGB:
 			while (ycount--) {
-				WATCHDOG_RESET ();
+				WATCHDOG_RESET();
 				xcount = width;
 				while (xcount--) {
-					FILL_24BIT_888RGB (bmap[2], bmap[1], bmap[0]);
+					FILL_24BIT_888RGB(bmap[2], bmap[1],
+							  bmap[0]);
 					bmap += 3;
 				}
 				bmap += padded_line;
-				fb -= (VIDEO_VISIBLE_COLS + width) * VIDEO_PIXEL_SIZE;
+				fb -= (VIDEO_VISIBLE_COLS + width) *
+							VIDEO_PIXEL_SIZE;
 			}
 			break;
 		default:
-			printf ("Error: 24 bits/pixel bitmap incompatible with current video mode\n");
+			printf("Error: 24 bits/pixel bitmap incompatible "
+				"with current video mode\n");
 			break;
 		}
 		break;
 	default:
-		printf ("Error: %d bit/pixel bitmaps not supported by U-Boot\n",
-			le16_to_cpu (bmp->header.bit_count));
+		printf("Error: %d bit/pixel bitmaps not supported by U-Boot\n",
+			le16_to_cpu(bmp->header.bit_count));
 		break;
 	}
 
@@ -1354,28 +1441,26 @@
 }
 #endif
 
-/*****************************************************************************/
 
 #ifdef CONFIG_VIDEO_LOGO
-void logo_plot (void *screen, int width, int x, int y)
+void logo_plot(void *screen, int width, int x, int y)
 {
 
 	int xcount, i;
-	int skip   = (width - VIDEO_LOGO_WIDTH) * VIDEO_PIXEL_SIZE;
+	int skip = (width - VIDEO_LOGO_WIDTH) * VIDEO_PIXEL_SIZE;
 	int ycount = video_logo_height;
 	unsigned char r, g, b, *logo_red, *logo_blue, *logo_green;
 	unsigned char *source;
-	unsigned char *dest = (unsigned char *)screen +
-			      ((y * width * VIDEO_PIXEL_SIZE) +
-			       x * VIDEO_PIXEL_SIZE);
+	unsigned char *dest = (unsigned char *) screen +
+		((y * width * VIDEO_PIXEL_SIZE) + x * VIDEO_PIXEL_SIZE);
 
 #ifdef CONFIG_VIDEO_BMP_LOGO
 	source = bmp_logo_bitmap;
 
 	/* Allocate temporary space for computing colormap */
-	logo_red = malloc (BMP_LOGO_COLORS);
-	logo_green = malloc (BMP_LOGO_COLORS);
-	logo_blue = malloc (BMP_LOGO_COLORS);
+	logo_red = malloc(BMP_LOGO_COLORS);
+	logo_green = malloc(BMP_LOGO_COLORS);
+	logo_blue = malloc(BMP_LOGO_COLORS);
 	/* Compute color map */
 	for (i = 0; i < VIDEO_LOGO_COLORS; i++) {
 		logo_red[i] = (bmp_logo_palette[i] & 0x0f00) >> 4;
@@ -1391,8 +1476,9 @@
 
 	if (VIDEO_DATA_FORMAT == GDF__8BIT_INDEX) {
 		for (i = 0; i < VIDEO_LOGO_COLORS; i++) {
-			video_set_lut (i + VIDEO_LOGO_LUT_OFFSET,
-				       logo_red[i], logo_green[i], logo_blue[i]);
+			video_set_lut(i + VIDEO_LOGO_LUT_OFFSET,
+				      logo_red[i], logo_green[i],
+				      logo_blue[i]);
 		}
 	}
 
@@ -1411,23 +1497,34 @@
 				*dest = *source;
 				break;
 			case GDF__8BIT_332RGB:
-				*dest = ((r >> 5) << 5) | ((g >> 5) << 2) | (b >> 6);
+				*dest = ((r >> 5) << 5) |
+					((g >> 5) << 2) |
+					 (b >> 6);
 				break;
 			case GDF_15BIT_555RGB:
 #if defined(VIDEO_FB_16BPP_PIXEL_SWAP)
-				fill_555rgb_pswap (dest, xpos++, r, g, b);
+				fill_555rgb_pswap(dest, xpos++, r, g, b);
 #else
 				*(unsigned short *) dest =
-					SWAP16 ((unsigned short) (((r >> 3) << 10) | ((g >> 3) << 5) | (b >> 3)));
+					SWAP16((unsigned short) (
+							((r >> 3) << 10) |
+							((g >> 3) <<  5) |
+							 (b >> 3)));
 #endif
 				break;
 			case GDF_16BIT_565RGB:
 				*(unsigned short *) dest =
-					SWAP16 ((unsigned short) (((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3)));
+					SWAP16((unsigned short) (
+							((r >> 3) << 11) |
+							((g >> 2) <<  5) |
+							 (b >> 3)));
 				break;
 			case GDF_32BIT_X888RGB:
 				*(unsigned long *) dest =
-					SWAP32 ((unsigned long) ((r << 16) | (g << 8) | b));
+					SWAP32((unsigned long) (
+							(r << 16) |
+							(g <<  8) |
+							 b));
 				break;
 			case GDF_24BIT_888RGB:
 #ifdef VIDEO_FB_LITTLE_ENDIAN
@@ -1447,94 +1544,100 @@
 		dest += skip;
 	}
 #ifdef CONFIG_VIDEO_BMP_LOGO
-	free (logo_red);
-	free (logo_green);
-	free (logo_blue);
+	free(logo_red);
+	free(logo_green);
+	free(logo_blue);
 #endif
 }
 
-/*****************************************************************************/
-
-static void *video_logo (void)
+static void *video_logo(void)
 {
 	char info[128];
-	extern char version_string;
 	int space, len, y_off = 0;
 
 #ifdef CONFIG_SPLASH_SCREEN
 	char *s;
 	ulong addr;
 
-	if ((s = getenv ("splashimage")) != NULL) {
+	s = getenv("splashimage");
+	if (s != NULL) {
 		int x = 0, y = 0;
 
-		addr = simple_strtoul (s, NULL, 16);
+		addr = simple_strtoul(s, NULL, 16);
 #ifdef CONFIG_SPLASH_SCREEN_ALIGN
-		if ((s = getenv ("splashpos")) != NULL) {
+		s = getenv("splashpos");
+		if (s != NULL) {
 			if (s[0] == 'm')
 				x = BMP_ALIGN_CENTER;
 			else
-				x = simple_strtol (s, NULL, 0);
+				x = simple_strtol(s, NULL, 0);
 
-			if ((s = strchr (s + 1, ',')) != NULL) {
+			s = strchr(s + 1, ',');
+			if (s != NULL) {
 				if (s[1] == 'm')
 					y = BMP_ALIGN_CENTER;
 				else
-					y = simple_strtol (s + 1, NULL, 0);
+					y = simple_strtol(s + 1, NULL, 0);
 			}
 		}
 #endif /* CONFIG_SPLASH_SCREEN_ALIGN */
 
-		if (video_display_bitmap (addr, x, y) == 0) {
+		if (video_display_bitmap(addr, x, y) == 0) {
 			video_logo_height = 0;
 			return ((void *) (video_fb_address));
 		}
 	}
 #endif /* CONFIG_SPLASH_SCREEN */
 
-	logo_plot (video_fb_address, VIDEO_COLS, 0, 0);
+	logo_plot(video_fb_address, VIDEO_COLS, 0, 0);
 
-	sprintf (info, " %s", &version_string);
+	sprintf(info, " %s", version_string);
 
 	space = (VIDEO_LINE_LEN / 2 - VIDEO_INFO_X) / VIDEO_FONT_WIDTH;
 	len = strlen(info);
 
 	if (len > space) {
-		video_drawchars (VIDEO_INFO_X, VIDEO_INFO_Y,
-				 (uchar *)info, space);
-		video_drawchars (VIDEO_INFO_X + VIDEO_FONT_WIDTH,
-				 VIDEO_INFO_Y + VIDEO_FONT_HEIGHT,
-				 (uchar *)info + space, len - space);
+		video_drawchars(VIDEO_INFO_X, VIDEO_INFO_Y,
+				(uchar *) info, space);
+		video_drawchars(VIDEO_INFO_X + VIDEO_FONT_WIDTH,
+				VIDEO_INFO_Y + VIDEO_FONT_HEIGHT,
+				(uchar *) info + space, len - space);
 		y_off = 1;
 	} else
-		video_drawstring (VIDEO_INFO_X, VIDEO_INFO_Y, (uchar *)info);
+		video_drawstring(VIDEO_INFO_X, VIDEO_INFO_Y, (uchar *) info);
 
 #ifdef CONFIG_CONSOLE_EXTRA_INFO
 	{
-		int i, n = ((video_logo_height - VIDEO_FONT_HEIGHT) / VIDEO_FONT_HEIGHT);
+		int i, n =
+			((video_logo_height -
+			  VIDEO_FONT_HEIGHT) / VIDEO_FONT_HEIGHT);
 
 		for (i = 1; i < n; i++) {
-			video_get_info_str (i, info);
+			video_get_info_str(i, info);
 			if (!*info)
 				continue;
 
 			len = strlen(info);
 			if (len > space) {
-				video_drawchars (VIDEO_INFO_X,
-						 VIDEO_INFO_Y +
-						 (i + y_off) * VIDEO_FONT_HEIGHT,
-						 (uchar *)info, space);
+				video_drawchars(VIDEO_INFO_X,
+						VIDEO_INFO_Y +
+						(i + y_off) *
+							VIDEO_FONT_HEIGHT,
+						(uchar *) info, space);
 				y_off++;
-				video_drawchars (VIDEO_INFO_X + VIDEO_FONT_WIDTH,
-						 VIDEO_INFO_Y +
-						 (i + y_off) * VIDEO_FONT_HEIGHT,
-						 (uchar *)info + space,
-						 len - space);
+				video_drawchars(VIDEO_INFO_X +
+						VIDEO_FONT_WIDTH,
+						VIDEO_INFO_Y +
+							(i + y_off) *
+							VIDEO_FONT_HEIGHT,
+						(uchar *) info + space,
+						len - space);
 			} else {
-				video_drawstring (VIDEO_INFO_X,
-						  VIDEO_INFO_Y +
-						  (i + y_off) * VIDEO_FONT_HEIGHT,
-						  (uchar *)info);
+				video_drawstring(VIDEO_INFO_X,
+						 VIDEO_INFO_Y +
+						 (i + y_off) *
+							VIDEO_FONT_HEIGHT,
+						 (uchar *) info);
 			}
 		}
 	}
@@ -1544,74 +1647,94 @@
 }
 #endif
 
-
-/*****************************************************************************/
-
-static int video_init (void)
+static int video_init(void)
 {
 	unsigned char color8;
 
-	if ((pGD = video_hw_init ()) == NULL)
+	pGD = video_hw_init();
+	if (pGD == NULL)
 		return -1;
 
 	video_fb_address = (void *) VIDEO_FB_ADRS;
 #ifdef CONFIG_VIDEO_HW_CURSOR
-	video_init_hw_cursor (VIDEO_FONT_WIDTH, VIDEO_FONT_HEIGHT);
+	video_init_hw_cursor(VIDEO_FONT_WIDTH, VIDEO_FONT_HEIGHT);
 #endif
 
 	/* Init drawing pats */
 	switch (VIDEO_DATA_FORMAT) {
 	case GDF__8BIT_INDEX:
-		video_set_lut (0x01, CONSOLE_FG_COL, CONSOLE_FG_COL, CONSOLE_FG_COL);
-		video_set_lut (0x00, CONSOLE_BG_COL, CONSOLE_BG_COL, CONSOLE_BG_COL);
+		video_set_lut(0x01, CONSOLE_FG_COL, CONSOLE_FG_COL,
+			      CONSOLE_FG_COL);
+		video_set_lut(0x00, CONSOLE_BG_COL, CONSOLE_BG_COL,
+			      CONSOLE_BG_COL);
 		fgx = 0x01010101;
 		bgx = 0x00000000;
 		break;
 	case GDF__8BIT_332RGB:
 		color8 = ((CONSOLE_FG_COL & 0xe0) |
-			  ((CONSOLE_FG_COL >> 3) & 0x1c) | CONSOLE_FG_COL >> 6);
-		fgx = (color8 << 24) | (color8 << 16) | (color8 << 8) | color8;
+			  ((CONSOLE_FG_COL >> 3) & 0x1c) |
+			  CONSOLE_FG_COL >> 6);
+		fgx = (color8 << 24) | (color8 << 16) | (color8 << 8) |
+			color8;
 		color8 = ((CONSOLE_BG_COL & 0xe0) |
-			  ((CONSOLE_BG_COL >> 3) & 0x1c) | CONSOLE_BG_COL >> 6);
-		bgx = (color8 << 24) | (color8 << 16) | (color8 << 8) | color8;
+			  ((CONSOLE_BG_COL >> 3) & 0x1c) |
+			  CONSOLE_BG_COL >> 6);
+		bgx = (color8 << 24) | (color8 << 16) | (color8 << 8) |
+			color8;
 		break;
 	case GDF_15BIT_555RGB:
 		fgx = (((CONSOLE_FG_COL >> 3) << 26) |
-		       ((CONSOLE_FG_COL >> 3) << 21) | ((CONSOLE_FG_COL >> 3) << 16) |
-		       ((CONSOLE_FG_COL >> 3) << 10) | ((CONSOLE_FG_COL >> 3) << 5) |
-		       (CONSOLE_FG_COL >> 3));
+		       ((CONSOLE_FG_COL >> 3) << 21) |
+		       ((CONSOLE_FG_COL >> 3) << 16) |
+		       ((CONSOLE_FG_COL >> 3) << 10) |
+		       ((CONSOLE_FG_COL >> 3) <<  5) |
+			(CONSOLE_FG_COL >> 3));
 		bgx = (((CONSOLE_BG_COL >> 3) << 26) |
-		       ((CONSOLE_BG_COL >> 3) << 21) | ((CONSOLE_BG_COL >> 3) << 16) |
-		       ((CONSOLE_BG_COL >> 3) << 10) | ((CONSOLE_BG_COL >> 3) << 5) |
-		       (CONSOLE_BG_COL >> 3));
+		       ((CONSOLE_BG_COL >> 3) << 21) |
+		       ((CONSOLE_BG_COL >> 3) << 16) |
+		       ((CONSOLE_BG_COL >> 3) << 10) |
+		       ((CONSOLE_BG_COL >> 3) <<  5) |
+			(CONSOLE_BG_COL >> 3));
 		break;
 	case GDF_16BIT_565RGB:
 		fgx = (((CONSOLE_FG_COL >> 3) << 27) |
-		       ((CONSOLE_FG_COL >> 2) << 21) | ((CONSOLE_FG_COL >> 3) << 16) |
-		       ((CONSOLE_FG_COL >> 3) << 11) | ((CONSOLE_FG_COL >> 2) << 5) |
-		       (CONSOLE_FG_COL >> 3));
+		       ((CONSOLE_FG_COL >> 2) << 21) |
+		       ((CONSOLE_FG_COL >> 3) << 16) |
+		       ((CONSOLE_FG_COL >> 3) << 11) |
+		       ((CONSOLE_FG_COL >> 2) <<  5) |
+			(CONSOLE_FG_COL >> 3));
 		bgx = (((CONSOLE_BG_COL >> 3) << 27) |
-		       ((CONSOLE_BG_COL >> 2) << 21) | ((CONSOLE_BG_COL >> 3) << 16) |
-		       ((CONSOLE_BG_COL >> 3) << 11) | ((CONSOLE_BG_COL >> 2) << 5) |
-		       (CONSOLE_BG_COL >> 3));
+		       ((CONSOLE_BG_COL >> 2) << 21) |
+		       ((CONSOLE_BG_COL >> 3) << 16) |
+		       ((CONSOLE_BG_COL >> 3) << 11) |
+		       ((CONSOLE_BG_COL >> 2) <<  5) |
+			(CONSOLE_BG_COL >> 3));
 		break;
 	case GDF_32BIT_X888RGB:
-		fgx = (CONSOLE_FG_COL << 16) | (CONSOLE_FG_COL << 8) | CONSOLE_FG_COL;
-		bgx = (CONSOLE_BG_COL << 16) | (CONSOLE_BG_COL << 8) | CONSOLE_BG_COL;
+		fgx =	(CONSOLE_FG_COL << 16) |
+			(CONSOLE_FG_COL <<  8) |
+			 CONSOLE_FG_COL;
+		bgx =	(CONSOLE_BG_COL << 16) |
+			(CONSOLE_BG_COL <<  8) |
+			 CONSOLE_BG_COL;
 		break;
 	case GDF_24BIT_888RGB:
-		fgx = (CONSOLE_FG_COL << 24) | (CONSOLE_FG_COL << 16) |
-			(CONSOLE_FG_COL << 8) | CONSOLE_FG_COL;
-		bgx = (CONSOLE_BG_COL << 24) | (CONSOLE_BG_COL << 16) |
-			(CONSOLE_BG_COL << 8) | CONSOLE_BG_COL;
+		fgx =	(CONSOLE_FG_COL << 24) |
+			(CONSOLE_FG_COL << 16) |
+			(CONSOLE_FG_COL <<  8) |
+			 CONSOLE_FG_COL;
+		bgx =	(CONSOLE_BG_COL << 24) |
+			(CONSOLE_BG_COL << 16) |
+			(CONSOLE_BG_COL <<  8) |
+			 CONSOLE_BG_COL;
 		break;
 	}
 	eorx = fgx ^ bgx;
 
 #ifdef CONFIG_VIDEO_LOGO
 	/* Plot the logo and get start point of console */
-	PRINTD ("Video: Drawing the logo ...\n");
-	video_console_address = video_logo ();
+	debug("Video: Drawing the logo ...\n");
+	video_console_address = video_logo();
 #else
 	video_console_address = video_fb_address;
 #endif
@@ -1623,9 +1746,6 @@
 	return 0;
 }
 
-
-/*****************************************************************************/
-
 /*
  * Implement a weak default function for boards that optionally
  * need to skip the video initialization.
@@ -1635,9 +1755,11 @@
 	/* As default, don't skip test */
 	return 0;
 }
-int board_video_skip(void) __attribute__((weak, alias("__board_video_skip")));
 
-int drv_video_init (void)
+int board_video_skip(void)
+	__attribute__ ((weak, alias("__board_video_skip")));
+
+int drv_video_init(void)
 {
 	int skip_dev_init;
 	struct stdio_dev console_dev;
@@ -1647,10 +1769,10 @@
 		return 0;
 
 	/* Init video chip - returns with framebuffer cleared */
-	skip_dev_init = (video_init () == -1);
+	skip_dev_init = (video_init() == -1);
 
 #if !defined(CONFIG_VGA_AS_SINGLE_DEVICE)
-	PRINTD ("KBD: Keyboard init ...\n");
+	debug("KBD: Keyboard init ...\n");
 	skip_dev_init |= (VIDEO_KBD_INIT_FCT == -1);
 #endif
 
@@ -1658,8 +1780,8 @@
 		return 0;
 
 	/* Init vga device */
-	memset (&console_dev, 0, sizeof (console_dev));
-	strcpy (console_dev.name, "vga");
+	memset(&console_dev, 0, sizeof(console_dev));
+	strcpy(console_dev.name, "vga");
 	console_dev.ext = DEV_EXT_VIDEO;	/* Video extensions */
 	console_dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_SYSTEM;
 	console_dev.putc = video_putc;	/* 'putc' function */
@@ -1674,7 +1796,7 @@
 	console_dev.getc = VIDEO_GETC_FCT;	/* 'getc' function */
 #endif /* CONFIG_VGA_AS_SINGLE_DEVICE */
 
-	if (stdio_register (&console_dev) != 0)
+	if (stdio_register(&console_dev) != 0)
 		return 0;
 
 	/* Return success */
diff -urN u-boot-2011.06/drivers/video/ct69000.c u-boot-HEAD/drivers/video/ct69000.c
--- u-boot-2011.06/drivers/video/ct69000.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/video/ct69000.c	2011-09-19 23:25:08.000000000 +0200
@@ -1,5 +1,5 @@
 /* ported from ctfb.c (linux kernel):
- * Created in Jan - July 2000 by Thomas Höhenleitner <th@visuelle-maschinen.de>
+ * Created in Jan - July 2000 by Thomas HÃ¶henleitner <th@visuelle-maschinen.de>
  *
  * Ported to U-Boot:
  * (C) Copyright 2002 Denis Peter, MPL AG Switzerland
@@ -626,25 +626,25 @@
 
 /* that is the hardware < 69000 we have to manage
  +---------+  +-------------------+  +----------------------+  +--+
- | REFCLK  |__|NTSC Divisor Select|__|FVCO Reference Divisor|__|÷N|__
- | 14.3MHz |  |(NTSCDS) (÷1, ÷5)  |  |Select (RDS) (÷1, ÷4) |  |  |  |
+ | REFCLK  |__|NTSC Divisor Select|__|FVCO Reference Divisor|__|Ã·N|__
+ | 14.3MHz |  |(NTSCDS) (Ã·1, Ã·5)  |  |Select (RDS) (Ã·1, Ã·4) |  |  |  |
  +---------+  +-------------------+  +----------------------+  +--+  |
   ___________________________________________________________________|
  |
  |                                    fvco                      fout
  | +--------+  +------------+  +-----+     +-------------------+   +----+
  +-| Phase  |__|Charge Pump |__| VCO |_____|Post Divisor (PD)  |___|CLK |--->
- +-| Detect |  |& Filter VCO|  |     |  |  |÷1, 2, 4, 8, 16, 32|   |    |
+ +-| Detect |  |& Filter VCO|  |     |  |  |Ã·1, 2, 4, 8, 16, 32|   |    |
  | +--------+  +------------+  +-----+  |  +-------------------+   +----+
  |                                      |
  |    +--+   +---------------+          |
- |____|÷M|___|VCO Loop Divide|__________|
-      |  |   |(VLD)(÷4, ÷16) |
+ |____|Ã·M|___|VCO Loop Divide|__________|
+      |  |   |(VLD)(Ã·4, Ã·16) |
       +--+   +---------------+
 ****************************************************************************
   that is the hardware >= 69000 we have to manage
  +---------+  +--+
- | REFCLK  |__|÷N|__
+ | REFCLK  |__|Ã·N|__
  | 14.3MHz |  |  |  |
  +---------+  +--+  |
   __________________|
@@ -652,12 +652,12 @@
  |                                    fvco                      fout
  | +--------+  +------------+  +-----+     +-------------------+   +----+
  +-| Phase  |__|Charge Pump |__| VCO |_____|Post Divisor (PD)  |___|CLK |--->
- +-| Detect |  |& Filter VCO|  |     |  |  |÷1, 2, 4, 8, 16, 32|   |    |
+ +-| Detect |  |& Filter VCO|  |     |  |  |Ã·1, 2, 4, 8, 16, 32|   |    |
  | +--------+  +------------+  +-----+  |  +-------------------+   +----+
  |                                      |
  |    +--+   +---------------+          |
- |____|÷M|___|VCO Loop Divide|__________|
-      |  |   |(VLD)(÷1, ÷4)  |
+ |____|Ã·M|___|VCO Loop Divide|__________|
+      |  |   |(VLD)(Ã·1, Ã·4)  |
       +--+   +---------------+
 
 
diff -urN u-boot-2011.06/drivers/video/fsl_diu_fb.c u-boot-HEAD/drivers/video/fsl_diu_fb.c
--- u-boot-2011.06/drivers/video/fsl_diu_fb.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/video/fsl_diu_fb.c	2011-09-19 23:25:08.000000000 +0200
@@ -78,13 +78,9 @@
 	unsigned int flag;
 };
 
-#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
-#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
-#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
-
 /* This setting is used for the ifm pdm360ng with PRIMEVIEW PM070WL3 */
-static struct fb_videomode fsl_diu_mode_800 = {
-	.name		= "800x600-60",
+static struct fb_videomode fsl_diu_mode_800_480 = {
+	.name		= "800x480-60",
 	.refresh	= 60,
 	.xres		= 800,
 	.yres		= 480,
@@ -99,13 +95,30 @@
 	.vmode		= FB_VMODE_NONINTERLACED
 };
 
+/* For the SHARP LQ084S3LG01, used on the P1022DS board */
+static struct fb_videomode fsl_diu_mode_800_600 = {
+	.name		= "800x600-60",
+	.refresh	= 60,
+	.xres		= 800,
+	.yres		= 600,
+	.pixclock	= 25000,
+	.left_margin	= 88,
+	.right_margin	= 40,
+	.upper_margin	= 23,
+	.lower_margin	= 1,
+	.hsync_len	= 128,
+	.vsync_len	= 4,
+	.sync		= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	.vmode		= FB_VMODE_NONINTERLACED
+};
+
 /*
  * These parameters give default parameters
  * for video output 1024x768,
  * FIXME - change timing to proper amounts
  * hsync 31.5kHz, vsync 60Hz
  */
-static struct fb_videomode fsl_diu_mode_1024 = {
+static struct fb_videomode fsl_diu_mode_1024_768 = {
 	.name		= "1024x768-60",
 	.refresh	= 60,
 	.xres		= 1024,
@@ -121,7 +134,7 @@
 	.vmode		= FB_VMODE_NONINTERLACED
 };
 
-static struct fb_videomode fsl_diu_mode_1280 = {
+static struct fb_videomode fsl_diu_mode_1280_1024 = {
 	.name		= "1280x1024-60",
 	.refresh	= 60,
 	.xres		= 1280,
@@ -263,7 +276,7 @@
 	return ad;
 }
 
-int fsl_diu_init(int xres, u32 pixel_format, int gamma_fix)
+int fsl_diu_init(u16 xres, u16 yres, u32 pixel_format, int gamma_fix)
 {
 	struct fb_videomode *fsl_diu_mode_db;
 	struct diu_ad *ad;
@@ -274,15 +287,23 @@
 	struct diu_addr gamma;
 	struct diu_addr cursor;
 
-	switch (xres) {
-	case 800:
-		fsl_diu_mode_db = &fsl_diu_mode_800;
+/* Convert the X,Y resolution pair into a single number */
+#define RESOLUTION(x, y) (((u32)(x) << 16) | (y))
+
+	switch (RESOLUTION(xres, yres)) {
+	case RESOLUTION(800, 480):
+		fsl_diu_mode_db = &fsl_diu_mode_800_480;
 		break;
-	case 1280:
-		fsl_diu_mode_db = &fsl_diu_mode_1280;
+	case RESOLUTION(800, 600):
+		fsl_diu_mode_db = &fsl_diu_mode_800_600;
+	case RESOLUTION(1024, 768):
+		fsl_diu_mode_db = &fsl_diu_mode_1024_768;
+	case RESOLUTION(1280, 1024):
+		fsl_diu_mode_db = &fsl_diu_mode_1280_1024;
 		break;
 	default:
-		fsl_diu_mode_db = &fsl_diu_mode_1024;
+		printf("DIU:   Unsupported resolution %ux%u\n", xres, yres);
+		return -1;
 	}
 
 	/* The AD struct for the dummy framebuffer and the FB itself */
diff -urN u-boot-2011.06/drivers/video/Makefile u-boot-HEAD/drivers/video/Makefile
--- u-boot-2011.06/drivers/video/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/video/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -30,19 +30,20 @@
 COBJS-$(CONFIG_CFB_CONSOLE) += cfb_console.o
 COBJS-$(CONFIG_FSL_DIU_FB) += fsl_diu_fb.o videomodes.o
 COBJS-$(CONFIG_S6E63D6) += s6e63d6.o
+COBJS-$(CONFIG_SED156X) += sed156x.o
 COBJS-$(CONFIG_VIDEO_AMBA) += amba.o
 COBJS-$(CONFIG_VIDEO_CT69000) += ct69000.o videomodes.o
 COBJS-$(CONFIG_VIDEO_MB862xx) += mb862xx.o videomodes.o
 COBJS-$(CONFIG_VIDEO_MB86R0xGDC) += mb86r0xgdc.o videomodes.o
 COBJS-$(CONFIG_VIDEO_MX3) += mx3fb.o
 COBJS-$(CONFIG_VIDEO_MX5) += mxc_ipuv3_fb.o ipu_common.o ipu_disp.o
+COBJS-$(CONFIG_VIDEO_OMAP3) += omap3_dss.o videomodes.o
 COBJS-$(CONFIG_VIDEO_SED13806) += sed13806.o
-COBJS-$(CONFIG_SED156X) += sed156x.o
 COBJS-$(CONFIG_VIDEO_SM501) += sm501.o
 COBJS-$(CONFIG_VIDEO_SMI_LYNXEM) += smiLynxEM.o videomodes.o
 COBJS-$(CONFIG_VIDEO_VCXK) += bus_vcxk.o
 
-COBJS	:= $(COBJS-y)
+COBJS	:= $(sort $(COBJS-y))
 SRCS	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
 
diff -urN u-boot-2011.06/drivers/video/mb862xx.c u-boot-HEAD/drivers/video/mb862xx.c
--- u-boot-2011.06/drivers/video/mb862xx.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/video/mb862xx.c	2011-09-19 23:25:08.000000000 +0200
@@ -189,13 +189,22 @@
 }
 
 #if defined(CONFIG_VIDEO_CORALP)
+/* use CCF and MMR parameters for Coral-P Eval. Board as default */
+#ifndef CONFIG_SYS_MB862xx_CCF
+#define CONFIG_SYS_MB862xx_CCF	0x00090000
+#endif
+#ifndef CONFIG_SYS_MB862xx_MMR
+#define CONFIG_SYS_MB862xx_MMR	0x11d7fa13
+#endif
+
 unsigned int pci_video_init (void)
 {
 	GraphicDevice *dev = &mb862xx;
 	pci_dev_t devbusfn;
+	u16 device;
 
 	if ((devbusfn = pci_find_devices (supported, 0)) < 0) {
-		puts ("PCI video controller not found!\n");
+		puts("controller not present\n");
 		return 0;
 	}
 
@@ -212,10 +221,25 @@
 
 	dev->pciBase = dev->frameAdrs;
 
-	/* Setup clocks and memory mode for Coral-P Eval. Board */
-	HOST_WR_REG (GC_CCF, 0x00090000);
+	puts("Coral-");
+
+	pci_read_config_word(devbusfn, PCI_DEVICE_ID, &device);
+	switch (device) {
+	case PCI_DEVICE_ID_CORAL_P:
+		puts("P\n");
+		break;
+	case PCI_DEVICE_ID_CORAL_PA:
+		puts("PA\n");
+		break;
+	default:
+		puts("Unknown\n");
+		return 0;
+	}
+
+	/* Setup clocks and memory mode for Coral-P(A) */
+	HOST_WR_REG(GC_CCF, CONFIG_SYS_MB862xx_CCF);
 	udelay (200);
-	HOST_WR_REG (GC_MMR, 0x11d7fa13);
+	HOST_WR_REG(GC_MMR, CONFIG_SYS_MB862xx_MMR);
 	udelay (100);
 	return dev->frameAdrs;
 }
@@ -235,8 +259,6 @@
 	if (!pci_video_init ())
 		return 0;
 
-	puts ("CoralP\n");
-
 	tmp = 0;
 	videomode = 0x310;
 	/* get video mode via environment */
diff -urN u-boot-2011.06/drivers/video/mb86r0xgdc.c u-boot-HEAD/drivers/video/mb86r0xgdc.c
--- u-boot-2011.06/drivers/video/mb86r0xgdc.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/video/mb86r0xgdc.c	2011-09-19 23:25:08.000000000 +0200
@@ -57,7 +57,6 @@
 	u16 l2dx, l2dy, l2wx, l2wy, l2ww, l2wh;
 	unsigned long div;
 	int bpp;
-	u32 i;
 
 	bpp = video_get_params(&var_mode, modestr);
 
@@ -77,8 +76,7 @@
 	}
 
 	/* Fill memory with white */
-	for (i = 0; i < var_mode.xres * var_mode.yres / 2; i++)
-		*videomem++ = 0xFFFFFFFF;
+	memset(videomem, 0xFF, var_mode.xres * var_mode.yres * 2);
 
 	mb86r0x.winSizeX = var_mode.xres;
 	mb86r0x.winSizeY = var_mode.yres;
diff -urN u-boot-2011.06/drivers/video/omap3_dss.c u-boot-HEAD/drivers/video/omap3_dss.c
--- u-boot-2011.06/drivers/video/omap3_dss.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/drivers/video/omap3_dss.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,131 @@
+/*
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * Referred to Linux Kernel DSS driver files for OMAP3 by
+ * Tomi Valkeinen from drivers/video/omap2/dss/
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 and any
+ * later version the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/dss.h>
+
+/*
+ * Configure VENC for a given Mode (NTSC / PAL)
+ */
+void omap3_dss_venc_config(const struct venc_regs *venc_cfg,
+				u32 height, u32 width)
+{
+	struct venc_regs *venc = (struct venc_regs *) OMAP3_VENC_BASE;
+	struct dss_regs *dss = (struct dss_regs *) OMAP3_DSS_BASE;
+	struct dispc_regs *dispc = (struct dispc_regs *) OMAP3_DISPC_BASE;
+
+	writel(venc_cfg->status, &venc->status);
+	writel(venc_cfg->f_control, &venc->f_control);
+	writel(venc_cfg->vidout_ctrl, &venc->vidout_ctrl);
+	writel(venc_cfg->sync_ctrl, &venc->sync_ctrl);
+	writel(venc_cfg->llen, &venc->llen);
+	writel(venc_cfg->flens, &venc->flens);
+	writel(venc_cfg->hfltr_ctrl, &venc->hfltr_ctrl);
+	writel(venc_cfg->cc_carr_wss_carr, &venc->cc_carr_wss_carr);
+	writel(venc_cfg->c_phase, &venc->c_phase);
+	writel(venc_cfg->gain_u, &venc->gain_u);
+	writel(venc_cfg->gain_v, &venc->gain_v);
+	writel(venc_cfg->gain_y, &venc->gain_y);
+	writel(venc_cfg->black_level, &venc->black_level);
+	writel(venc_cfg->blank_level, &venc->blank_level);
+	writel(venc_cfg->x_color, &venc->x_color);
+	writel(venc_cfg->m_control, &venc->m_control);
+	writel(venc_cfg->bstamp_wss_data, &venc->bstamp_wss_data);
+	writel(venc_cfg->s_carr, &venc->s_carr);
+	writel(venc_cfg->line21, &venc->line21);
+	writel(venc_cfg->ln_sel, &venc->ln_sel);
+	writel(venc_cfg->l21__wc_ctl, &venc->l21__wc_ctl);
+	writel(venc_cfg->htrigger_vtrigger, &venc->htrigger_vtrigger);
+	writel(venc_cfg->savid__eavid, &venc->savid__eavid);
+	writel(venc_cfg->flen__fal, &venc->flen__fal);
+	writel(venc_cfg->lal__phase_reset, &venc->lal__phase_reset);
+	writel(venc_cfg->hs_int_start_stop_x,
+				&venc->hs_int_start_stop_x);
+	writel(venc_cfg->hs_ext_start_stop_x,
+				&venc->hs_ext_start_stop_x);
+	writel(venc_cfg->vs_int_start_x, &venc->vs_int_start_x);
+	writel(venc_cfg->vs_int_stop_x__vs_int_start_y,
+			&venc->vs_int_stop_x__vs_int_start_y);
+	writel(venc_cfg->vs_int_stop_y__vs_ext_start_x,
+			&venc->vs_int_stop_y__vs_ext_start_x);
+	writel(venc_cfg->vs_ext_stop_x__vs_ext_start_y,
+			&venc->vs_ext_stop_x__vs_ext_start_y);
+	writel(venc_cfg->vs_ext_stop_y, &venc->vs_ext_stop_y);
+	writel(venc_cfg->avid_start_stop_x, &venc->avid_start_stop_x);
+	writel(venc_cfg->avid_start_stop_y, &venc->avid_start_stop_y);
+	writel(venc_cfg->fid_int_start_x__fid_int_start_y,
+				&venc->fid_int_start_x__fid_int_start_y);
+	writel(venc_cfg->fid_int_offset_y__fid_ext_start_x,
+				&venc->fid_int_offset_y__fid_ext_start_x);
+	writel(venc_cfg->fid_ext_start_y__fid_ext_offset_y,
+				&venc->fid_ext_start_y__fid_ext_offset_y);
+	writel(venc_cfg->tvdetgp_int_start_stop_x,
+				&venc->tvdetgp_int_start_stop_x);
+	writel(venc_cfg->tvdetgp_int_start_stop_y,
+				&venc->tvdetgp_int_start_stop_y);
+	writel(venc_cfg->gen_ctrl, &venc->gen_ctrl);
+	writel(venc_cfg->output_control, &venc->output_control);
+	writel(venc_cfg->dac_b__dac_c, &venc->dac_b__dac_c);
+
+	/* Configure DSS for VENC Settings */
+	writel(VENC_DSS_CONFIG, &dss->control);
+
+	/* Configure height and width for Digital out */
+	writel(((height << DIG_LPP_SHIFT) | width), &dispc->size_dig);
+}
+
+/*
+ * Configure Panel Specific Parameters
+ */
+void omap3_dss_panel_config(const struct panel_config *panel_cfg)
+{
+	struct dispc_regs *dispc = (struct dispc_regs *) OMAP3_DISPC_BASE;
+
+	writel(panel_cfg->timing_h, &dispc->timing_h);
+	writel(panel_cfg->timing_v, &dispc->timing_v);
+	writel(panel_cfg->pol_freq, &dispc->pol_freq);
+	writel(panel_cfg->divisor, &dispc->divisor);
+	writel(panel_cfg->lcd_size, &dispc->size_lcd);
+	writel((panel_cfg->load_mode << FRAME_MODE_SHIFT), &dispc->config);
+	writel(((panel_cfg->panel_type << TFTSTN_SHIFT) |
+		(panel_cfg->data_lines << DATALINES_SHIFT)), &dispc->control);
+	writel(panel_cfg->panel_color, &dispc->default_color0);
+}
+
+/*
+ * Enable LCD and DIGITAL OUT in DSS
+ */
+void omap3_dss_enable(void)
+{
+	struct dispc_regs *dispc = (struct dispc_regs *) OMAP3_DISPC_BASE;
+	u32 l = 0;
+
+	l = readl(&dispc->control);
+	l |= DISPC_ENABLE;
+	writel(l, &dispc->control);
+}
diff -urN u-boot-2011.06/drivers/video/sed13806.c u-boot-HEAD/drivers/video/sed13806.c
--- u-boot-2011.06/drivers/video/sed13806.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/video/sed13806.c	2011-09-19 23:25:08.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * Stäubli Faverges - <www.staubli.com>
+ * StÃ¤ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
diff -urN u-boot-2011.06/drivers/video/sm501.c u-boot-HEAD/drivers/video/sm501.c
--- u-boot-2011.06/drivers/video/sm501.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/drivers/video/sm501.c	2011-09-19 23:25:08.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * Stäubli Faverges - <www.staubli.com>
+ * StÃ¤ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * (C) Copyright 2005

diff -urN u-boot-2011.06/include/ACEX1K.h u-boot-HEAD/include/ACEX1K.h
--- u-boot-2011.06/include/ACEX1K.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/ACEX1K.h	2011-09-19 23:25:08.000000000 +0200
@@ -30,13 +30,13 @@
 
 #include <altera.h>
 
-extern int ACEX1K_load( Altera_desc *desc, void *image, size_t size );
-extern int ACEX1K_dump( Altera_desc *desc, void *buf, size_t bsize );
-extern int ACEX1K_info( Altera_desc *desc );
-
-extern int CYC2_load( Altera_desc *desc, void *image, size_t size );
-extern int CYC2_dump( Altera_desc *desc, void *buf, size_t bsize );
-extern int CYC2_info( Altera_desc *desc );
+extern int ACEX1K_load(Altera_desc *desc, const void *image, size_t size);
+extern int ACEX1K_dump(Altera_desc *desc, const void *buf, size_t bsize);
+extern int ACEX1K_info(Altera_desc *desc);
+
+extern int CYC2_load(Altera_desc *desc, const void *image, size_t size);
+extern int CYC2_dump(Altera_desc *desc, const void *buf, size_t bsize);
+extern int CYC2_info(Altera_desc *desc);
 
 /* Slave Serial Implementation function table */
 typedef struct {
@@ -76,6 +76,7 @@
 #define Altera_EP2C8_SIZE	247942
 #define Altera_EP2C20_SIZE	586562
 #define Altera_EP2C35_SIZE	883905
+#define Altera_EP3C5_SIZE	368011		/* .rbf size in bytes */
 
 /* Descriptor Macros
  *********************************************************************/
diff -urN u-boot-2011.06/include/ahci.h u-boot-HEAD/include/ahci.h
--- u-boot-2011.06/include/ahci.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/ahci.h	2011-09-19 23:25:08.000000000 +0200
@@ -25,6 +25,8 @@
 #ifndef _AHCI_H_
 #define _AHCI_H_
 
+#include <pci.h>
+
 #define AHCI_PCI_BAR		0x24
 #define AHCI_MAX_SG		56 /* hardware max is 64K */
 #define AHCI_CMD_SLOT_SZ	32
@@ -187,4 +189,6 @@
 	u32	link_port_map; /*linkup port map*/
 };
 
+int ahci_init(u32 base);
+
 #endif
diff -urN u-boot-2011.06/include/ali512x.h u-boot-HEAD/include/ali512x.h
--- u-boot-2011.06/include/ali512x.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/ali512x.h	2011-09-19 23:25:08.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * Daniel Engström, Omicron Ceti AB <daniel@omicron.se>.
+ * Daniel EngstrÃ¶m, Omicron Ceti AB <daniel@omicron.se>.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
diff -urN u-boot-2011.06/include/altera.h u-boot-HEAD/include/altera.h
--- u-boot-2011.06/include/altera.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/altera.h	2011-09-19 23:25:08.000000000 +0200
@@ -51,18 +51,18 @@
 	passive_parallel_asynchronous,	/* parallel data */
 	passive_serial_asynchronous,	/* serial data w/ internal clock (not used)	*/
 	altera_jtag_mode,		/* jtag/tap serial (not used ) */
-	fast_passive_parallel,	/* fast passive parallel (FPP) */
+	fast_passive_parallel,		/* fast passive parallel (FPP) */
 	fast_passive_parallel_security,	/* fast passive parallel with security (FPPS) */
 	max_altera_iface_type		/* insert all new types before this */
 } Altera_iface;				/* end, typedef Altera_iface */
 
 typedef enum {			/* typedef Altera_Family */
-    min_altera_type,		/* insert all new types after this */
-    Altera_ACEX1K,		/* ACEX1K Family */
-    Altera_CYC2,		/* CYCLONII Family */
+	min_altera_type,	/* insert all new types after this */
+	Altera_ACEX1K,		/* ACEX1K Family */
+	Altera_CYC2,		/* CYCLONII Family */
 	Altera_StratixII,	/* StratixII Familiy */
 /* Add new models here */
-    max_altera_type		/* insert all new types before this */
+	max_altera_type		/* insert all new types before this */
 } Altera_Family;		/* end, typedef Altera_Family */
 
 typedef struct {		/* typedef Altera_desc */
@@ -76,9 +76,9 @@
 
 /* Generic Altera Functions
  *********************************************************************/
-extern int altera_load( Altera_desc *desc, void *image, size_t size );
-extern int altera_dump( Altera_desc *desc, void *buf, size_t bsize );
-extern int altera_info( Altera_desc *desc );
+extern int altera_load(Altera_desc *desc, const void *image, size_t size);
+extern int altera_dump(Altera_desc *desc, const void *buf, size_t bsize);
+extern int altera_info(Altera_desc *desc);
 
 /* Board specific implementation specific function types
  *********************************************************************/
@@ -88,7 +88,7 @@
 typedef int (*Altera_done_fn)( int cookie );
 typedef int (*Altera_clk_fn)( int assert_clk, int flush, int cookie );
 typedef int (*Altera_data_fn)( int assert_data, int flush, int cookie );
-typedef int (*Altera_write_fn)(void *buf, size_t len, int flush, int cookie);
+typedef int(*Altera_write_fn)(const void *buf, size_t len, int flush, int cookie);
 typedef int (*Altera_abort_fn)( int cookie );
 typedef int (*Altera_post_fn)( int cookie );

diff -urN u-boot-2011.06/include/faraday/ftsdc010.h u-boot-HEAD/include/faraday/ftsdc010.h
--- u-boot-2011.06/include/faraday/ftsdc010.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/include/faraday/ftsdc010.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,245 @@
+/*
+ * Faraday FTSDC010 Secure Digital Memory Card Host Controller
+ *
+ * Copyright (C) 2011 Andes Technology Corporation
+ * Macpaul Lin, Andes Technology Corporation <macpaul@andestech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __FTSDC010_H
+#define __FTSDC010_H
+
+#ifndef __ASSEMBLY__
+/* sd controller register */
+struct ftsdc010_mmc {
+	unsigned int	cmd;		/* 0x00 - command reg		*/
+	unsigned int	argu;		/* 0x04 - argument reg		*/
+	unsigned int	rsp0;		/* 0x08 - response reg0		*/
+	unsigned int	rsp1;		/* 0x0c - response reg1		*/
+	unsigned int	rsp2;		/* 0x10 - response reg2		*/
+	unsigned int	rsp3;		/* 0x14 - response reg3		*/
+	unsigned int	rsp_cmd;	/* 0x18 - responded cmd reg	*/
+	unsigned int	dcr;		/* 0x1c - data control reg	*/
+	unsigned int	dtr;		/* 0x20 - data timer reg	*/
+	unsigned int	dlr;		/* 0x24 - data length reg	*/
+	unsigned int	status;		/* 0x28 - status reg		*/
+	unsigned int	clr;		/* 0x2c - clear reg		*/
+	unsigned int	int_mask;	/* 0x30 - intrrupt mask reg	*/
+	unsigned int	pcr;		/* 0x34 - power control reg	*/
+	unsigned int	ccr;		/* 0x38 - clock contorl reg	*/
+	unsigned int	bwr;		/* 0x3c - bus width reg		*/
+	unsigned int	dwr;		/* 0x40 - data window reg	*/
+#ifndef CONFIG_FTSDC010_SDIO
+	unsigned int	feature;	/* 0x44 - feature reg		*/
+	unsigned int	rev;		/* 0x48 - revision reg		*/
+#else
+	unsigned int	mmc_intr_time;	/* 0x44 - MMC int resp time reg	*/
+	unsigned int	gpo;		/* 0x48 - gerenal purpose output */
+	unsigned int	reserved[8];	/* 0x50 - 0x68 reserved		*/
+	unsigned int	sdio_ctrl1;	/* 0x6c - SDIO control reg 1	*/
+	unsigned int	sdio_ctrl2;	/* 0x70 - SDIO control reg 2	*/
+	unsigned int	sdio_status;	/* 0x74 - SDIO status regi	*/
+	unsigned int	reserved1[9];	/* 0x78 - 0x98	reserved	*/
+	unsigned int	feature;	/* 0x9c - feature reg		*/
+	unsigned int	rev;		/* 0xa0 - revision reg		*/
+#endif /* CONFIG_FTSDC010_SDIO */
+};
+
+struct mmc_host {
+	struct ftsdc010_mmc *reg;
+	unsigned int version;		/* SDHCI spec. version */
+	unsigned int clock;		/* Current clock (MHz) */
+	unsigned int fifo_len;		/* bytes */
+	unsigned int last_opcode;	/* Last OP Code */
+	unsigned int card_type;		/* Card type */
+};
+
+/* functions */
+int ftsdc010_mmc_init(int dev_index);
+
+#endif	/* __ASSEMBLY__ */
+
+/* global defines */
+#define FTSDC010_CMD_RETRY			0x100000
+#define FTSDC010_PIO_RETRY			100	/* pio retry times */
+#define FTSDC010_DELAY_UNIT			100	/* 100 us */
+
+/* define from Linux kernel - include/linux/mmc/card.h */
+#define MMC_TYPE_SDIO				2	/* SDIO card */
+
+/* define for mmc layer */
+#define MMC_DATA_BOTH_DIR			(MMC_DATA_WRITE | MMC_DATA_READ)
+
+/* this part is strange */
+#define FTSDC010_SDIO_CTRL1_REG			0x0000006C
+#define FTSDC010_SDIO_CTRL2_REG			0x0000006C
+#define FTSDC010_SDIO_STATUS_REG		0x00000070
+
+/* 0x00 - command register */
+#define FTSDC010_CMD_IDX(x)			(((x) & 0x3f) << 0)
+#define FTSDC010_CMD_NEED_RSP			(1 << 6)
+#define FTSDC010_CMD_LONG_RSP			(1 << 7)
+#define FTSDC010_CMD_APP_CMD			(1 << 8)
+#define FTSDC010_CMD_CMD_EN			(1 << 9)
+#define FTSDC010_CMD_SDC_RST			(1 << 10)
+#define FTSDC010_CMD_MMC_INT_STOP		(1 << 11)
+
+/* 0x18 - responded command register */
+#define FTSDC010_RSP_CMD_IDX(x)			(((x) >> 0) & 0x3f)
+#define FTSDC010_RSP_CMD_APP			(1 << 6)
+
+/* 0x1c - data control register */
+#define FTSDC010_DCR_BLK_SIZE(x)		(((x) & 0xf) << 0)
+#define FTSDC010_DCR_DATA_WRITE			(1 << 4)
+#define FTSDC010_DCR_DMA_EN			(1 << 5)
+#define FTSDC010_DCR_DATA_EN			(1 << 6)
+#ifdef CONFIG_FTSDC010_SDIO
+#define FTSDC010_DCR_FIFOTH			(1 << 7)
+#define FTSDC010_DCR_DMA_TYPE(x)		(((x) & 0x3) << 8)
+#define FTSDC010_DCR_FIFO_RST			(1 << 10)
+#endif /* CONFIG_FTSDC010_SDIO */
+
+#define FTSDC010_DCR_DMA_TYPE_1			0x0	/* Single r/w	*/
+#define FTSDC010_DCR_DMA_TYPE_4			0x1	/* Burst 4 r/w	*/
+#define FTSDC010_DCR_DMA_TYPE_8			0x2	/* Burst 8 r/w	*/
+
+#define FTSDC010_DCR_BLK_BYTES(x)		(ffs(x) - 1)	/* 1B - 2048B */
+
+/* CPRM related define */
+#define FTSDC010_CPRM_DATA_CHANGE_ENDIAN_EN	0x000008
+#define FTSDC010_CPRM_DATA_SWAP_HL_EN		0x000010
+
+/* 0x28 - status register */
+#define FTSDC010_STATUS_RSP_CRC_FAIL		(1 << 0)
+#define FTSDC010_STATUS_DATA_CRC_FAIL		(1 << 1)
+#define FTSDC010_STATUS_RSP_TIMEOUT		(1 << 2)
+#define FTSDC010_STATUS_DATA_TIMEOUT		(1 << 3)
+#define FTSDC010_STATUS_RSP_CRC_OK		(1 << 4)
+#define FTSDC010_STATUS_DATA_CRC_OK		(1 << 5)
+#define FTSDC010_STATUS_CMD_SEND		(1 << 6)
+#define FTSDC010_STATUS_DATA_END		(1 << 7)
+#define FTSDC010_STATUS_FIFO_URUN		(1 << 8)
+#define FTSDC010_STATUS_FIFO_ORUN		(1 << 9)
+#define FTSDC010_STATUS_CARD_CHANGE		(1 << 10)
+#define FTSDC010_STATUS_CARD_DETECT		(1 << 11)
+#define FTSDC010_STATUS_WRITE_PROT		(1 << 12)
+#ifdef CONFIG_FTSDC010_SDIO
+#define FTSDC010_STATUS_CP_READY		(1 << 13) /* reserved ? */
+#define FTSDC010_STATUS_CP_BUF_READY		(1 << 14) /* reserved ? */
+#define FTSDC010_STATUS_PLAIN_TEXT_READY	(1 << 15) /* reserved ? */
+#define FTSDC010_STATUS_SDIO_IRPT		(1 << 16) /* SDIO card intr */
+#define FTSDC010_STATUS_DATA0_STATUS		(1 << 17)
+#endif /* CONFIG_FTSDC010_SDIO */
+
+/* 0x2c - clear register */
+#define FTSDC010_CLR_RSP_CRC_FAIL		(1 << 0)
+#define FTSDC010_CLR_DATA_CRC_FAIL		(1 << 1)
+#define FTSDC010_CLR_RSP_TIMEOUT		(1 << 2)
+#define FTSDC010_CLR_DATA_TIMEOUT		(1 << 3)
+#define FTSDC010_CLR_RSP_CRC_OK			(1 << 4)
+#define FTSDC010_CLR_DATA_CRC_OK		(1 << 5)
+#define FTSDC010_CLR_CMD_SEND			(1 << 6)
+#define FTSDC010_CLR_DATA_END			(1 << 7)
+#define FTSDC010_STATUS_FIFO_URUN		(1 << 8) /* reserved ? */
+#define FTSDC010_STATUS_FIFO_ORUN		(1 << 9) /* reserved ? */
+#define FTSDC010_CLR_CARD_CHANGE		(1 << 10)
+#ifdef CONFIG_FTSDC010_SDIO
+#define FTSDC010_CLR_SDIO_IRPT			(1 << 16)
+#endif /* CONFIG_FTSDC010_SDIO */
+
+/* 0x30 - interrupt mask register */
+#define FTSDC010_INT_MASK_RSP_CRC_FAIL		(1 << 0)
+#define FTSDC010_INT_MASK_DATA_CRC_FAIL		(1 << 1)
+#define FTSDC010_INT_MASK_RSP_TIMEOUT		(1 << 2)
+#define FTSDC010_INT_MASK_DATA_TIMEOUT		(1 << 3)
+#define FTSDC010_INT_MASK_RSP_CRC_OK		(1 << 4)
+#define FTSDC010_INT_MASK_DATA_CRC_OK		(1 << 5)
+#define FTSDC010_INT_MASK_CMD_SEND		(1 << 6)
+#define FTSDC010_INT_MASK_DATA_END		(1 << 7)
+#define FTSDC010_INT_MASK_FIFO_URUN		(1 << 8)
+#define FTSDC010_INT_MASK_FIFO_ORUN		(1 << 9)
+#define FTSDC010_INT_MASK_CARD_CHANGE		(1 << 10)
+#ifdef CONFIG_FTSDC010_SDIO
+#define FTSDC010_INT_MASK_CP_READY		(1 << 13)
+#define FTSDC010_INT_MASK_CP_BUF_READY		(1 << 14)
+#define FTSDC010_INT_MASK_PLAIN_TEXT_READY	(1 << 15)
+#define FTSDC010_INT_MASK_SDIO_IRPT		(1 << 16)
+#define FTSDC010_STATUS_DATA0_STATUS		(1 << 17)
+#endif /* CONFIG_FTSDC010_SDIO */
+
+/* ? */
+#define FTSDC010_CARD_INSERT			0x0
+#define FTSDC010_CARD_REMOVE			FTSDC010_STATUS_REG_CARD_DETECT
+
+/* 0x34 - power control register */
+#define FTSDC010_PCR_POWER(x)			(((x) & 0xf) << 0)
+#define FTSDC010_PCR_POWER_ON			(1 << 4)
+
+/* 0x38 - clock control register */
+#define FTSDC010_CCR_CLK_DIV(x)			(((x) & 0x7f) << 0)
+#define FTSDC010_CCR_CLK_SD			(1 << 7) /* 0: MMC, 1: SD */
+#define FTSDC010_CCR_CLK_DIS			(1 << 8)
+
+/* card type */
+#define FTSDC010_CARD_TYPE_SD			FTSDC010_CLOCK_REG_CARD_TYPE
+#define FTSDC010_CARD_TYPE_MMC			0x0
+
+/* 0x3c - bus width register */
+#define FTSDC010_BWR_SINGLE_BUS			(1 << 0)
+#define FTSDC010_BWR_WIDE_8_BUS			(1 << 1)
+#define FTSDC010_BWR_WIDE_4_BUS			(1 << 2)
+#define FTSDC010_BWR_WIDE_BUS_SUPPORT(x)	(((x) >> 3) & 0x3)
+#define FTSDC010_BWR_CARD_DETECT		(1 << 5)
+
+#define FTSDC010_BWR_1_BUS_SUPPORT		0x0
+#define FTSDC010_BWR_4_BUS_SUPPORT		0x1
+#define FTSDC010_BWR_8_BUS_SUPPORT		0x2
+
+/* 0x44 or 0x9c - feature register */
+#define FTSDC010_FEATURE_FIFO_DEPTH(x)		(((x) >> 0) & 0xff)
+#define FTSDC010_FEATURE_CPRM_FUNCTION		(1 << 8)
+
+#define FTSDC010_FIFO_DEPTH_4			0x04
+#define FTSDC010_FIFO_DEPTH_8			0x08
+#define FTSDC010_FIFO_DEPTH_16			0x10
+
+/* 0x48 or 0xa0 - revision register */
+#define FTSDC010_REV_REVISION(x)		(((x) & 0xff) >> 0)
+#define FTSDC010_REV_MINOR(x)			(((x) & 0xff00) >> 8)
+#define FTSDC010_REV_MAJOR(x)			(((x) & 0xffff0000) >> 16)
+
+#ifdef CONFIG_FTSDC010_SDIO
+/* 0x44 - general purpose output */
+#define FTSDC010_GPO_PORT(x)			(((x) & 0xf) << 0)
+
+/* 0x6c - sdio control register 1 */
+#define FTSDC010_SDIO_CTRL1_SDIO_BLK_SIZE(x)	(((x) & 0xfff) << 0)
+#define FTSDC010_SDIO_CTRL1_SDIO_BLK_MODE	(1 << 12)
+#define FTSDC010_SDIO_CTRL1_READ_WAIT_EN	(1 << 13)
+#define FTSDC010_SDIO_CTRL1_SDIO_ENABLE		(1 << 14)
+#define FTSDC010_SDIO_CTRL1_SDIO_BLK_NO(x)	(((x) & 0x1ff) << 15)
+
+/* 0x70 - sdio control register 2 */
+#define FTSDC010_SDIO_CTRL2_SUSP_READ_WAIT	(1 << 0)
+#define FTSDC010_SDIO_CTRL2_SUSP_CMD_ABORT	(1 << 1)
+
+/* 0x74 - sdio status register */
+#define FTSDC010_SDIO_STATUS_SDIO_BLK_CNT(x)	(((x) >> 0) & 0x1ffff)
+#define FTSDC010_SDIO_STATUS_FIFO_REMAIN_NO(x)	(((x) >> 17) & 0xef)
+
+#endif /* CONFIG_FTSDC010_SDIO */
+
+#endif /* __FTSDC010_H */

diff -urN u-boot-2011.06/include/fpga.h u-boot-HEAD/include/fpga.h
--- u-boot-2011.06/include/fpga.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/fpga.h	2011-09-19 23:25:08.000000000 +0200
@@ -72,11 +72,11 @@
 
 
 /* root function definitions */
-extern void fpga_init( void );
-extern int fpga_add( fpga_type devtype, void *desc );
-extern int fpga_count( void );
-extern int fpga_load( int devnum, void *buf, size_t bsize );
-extern int fpga_dump( int devnum, void *buf, size_t bsize );
-extern int fpga_info( int devnum );
+extern void fpga_init(void);
+extern int fpga_add(fpga_type devtype, void *desc);
+extern int fpga_count(void);
+extern int fpga_load(int devnum, const void *buf, size_t bsize);
+extern int fpga_dump(int devnum, const void *buf, size_t bsize);
+extern int fpga_info(int devnum);
 
 #endif	/* _FPGA_H_ */
diff -urN u-boot-2011.06/include/fsl_diu_fb.h u-boot-HEAD/include/fsl_diu_fb.h
--- u-boot-2011.06/include/fsl_diu_fb.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/fsl_diu_fb.h	2011-09-19 23:25:08.000000000 +0200
@@ -24,7 +24,7 @@
  * MA 02111-1307 USA
  */
 
-int fsl_diu_init(int xres, u32 pixel_format, int gamma_fix);
+int fsl_diu_init(u16 xres, u16 yres, u32 pixel_format, int gamma_fix);
 
 /* Prototypes for external board-specific functions */
 int platform_diu_init(unsigned int xres, unsigned int yres, const char *port);
diff -urN u-boot-2011.06/include/galileo/gt64260R.h u-boot-HEAD/include/galileo/gt64260R.h
--- u-boot-2011.06/include/galileo/gt64260R.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/galileo/gt64260R.h	2011-09-19 23:25:08.000000000 +0200
@@ -1182,7 +1182,7 @@
 #define CHANNEL2_REGISTER10				0x9070
 #define CHANNEL2_REGISTER11				0x9074
 
-/* MPSCs Interupts  */
+/* MPSCs Interrupts  */
 
 #define MPSC0_CAUSE					0xb824
 #define MPSC0_MASK					0xb8a4

diff -urN u-boot-2011.06/include/lattice.h u-boot-HEAD/include/lattice.h
--- u-boot-2011.06/include/lattice.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/lattice.h	2011-09-19 23:25:08.000000000 +0200
@@ -302,8 +302,8 @@
 void ispVMDelay(unsigned short int a_usMicroSecondDelay);
 void calibration(void);
 
-int lattice_load(Lattice_desc *desc, void *buf, size_t bsize);
-int lattice_dump(Lattice_desc *desc, void *buf, size_t bsize);
+int lattice_load(Lattice_desc *desc, const void *buf, size_t bsize);
+int lattice_dump(Lattice_desc *desc, const void *buf, size_t bsize);
 int lattice_info(Lattice_desc *desc);
 
 void ispVMStart(void);

diff -urN u-boot-2011.06/include/mpc5xxx_sdma.h u-boot-HEAD/include/mpc5xxx_sdma.h
--- u-boot-2011.06/include/mpc5xxx_sdma.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/mpc5xxx_sdma.h	2011-09-19 23:25:08.000000000 +0200
@@ -82,11 +82,11 @@
     sdma->IntPend = (1 << tasknum);                    \
 }
 
-/* get interupt pending bit of a task */
+/* get interrupt pending bit of a task */
 #define SDMA_GET_PENDINGBIT(tasknum)                   \
 	((*(vu_long *)(MPC5XXX_SDMA + 0x14)) & (1<<(tasknum)))
 
-/* get interupt mask bit of a task */
+/* get interrupt mask bit of a task */
 #define SDMA_GET_MASKBIT(tasknum)                      \
 	((*(vu_long *)(MPC5XXX_SDMA + 0x18)) & (1<<(tasknum)))
 
diff -urN u-boot-2011.06/include/mpc824x.h u-boot-HEAD/include/mpc824x.h
--- u-boot-2011.06/include/mpc824x.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/mpc824x.h	2011-09-19 23:25:08.000000000 +0200
@@ -258,7 +258,7 @@
 #define PLTR		0x8000000d  /* PCI Latancy Timer Register */
 #define PHTR		0x8000000e  /* PCI Header Type Register */
 #define BISTCTRL	0x8000000f  /* BIST Control */
-#define LMBAR		0x80000010  /* Local Base Addres Register */
+#define LMBAR		0x80000010  /* Local Base Address Register */
 #define PCSRBAR		0x80000014  /* PCSR Base Address Register */
 #define ILR		0x8000003c  /* PCI Interrupt Line Register */
 #define IPR		0x8000003d  /* Interrupt Pin Register */
diff -urN u-boot-2011.06/include/mpc83xx.h u-boot-HEAD/include/mpc83xx.h
--- u-boot-2011.06/include/mpc83xx.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/mpc83xx.h	2011-09-19 23:25:08.000000000 +0200
@@ -1000,6 +1000,7 @@
 #define SDRAM_CFG_8_BE			0x00040000
 #define SDRAM_CFG_NCAP			0x00020000
 #define SDRAM_CFG_2T_EN			0x00008000
+#define SDRAM_CFG_HSE			0x00000008
 #define SDRAM_CFG_BI			0x00000001
 
 /* DDR_SDRAM_MODE - DDR SDRAM Mode Register
diff -urN u-boot-2011.06/include/mxc_gpio.h u-boot-HEAD/include/mxc_gpio.h
--- u-boot-2011.06/include/mxc_gpio.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/mxc_gpio.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-/*
- *
- * (c) 2007 Pengutronix, Sascha Hauer <s.hauer@pengutronix.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __MXC_GPIO_H
-#define __MXC_GPIO_H
-
-enum mxc_gpio_direction {
-	MXC_GPIO_DIRECTION_IN,
-	MXC_GPIO_DIRECTION_OUT,
-};
-
-#ifdef CONFIG_MXC_GPIO
-extern int mxc_gpio_direction(unsigned int gpio,
-			       enum mxc_gpio_direction direction);
-extern void mxc_gpio_set(unsigned int gpio, unsigned int value);
-extern int mxc_gpio_get(unsigned int gpio);
-#else
-static inline int mxc_gpio_direction(unsigned int gpio,
-				      enum mxc_gpio_direction direction)
-{
-	return 1;
-}
-static inline int mxc_gpio_get(unsigned int gpio)
-{
-	return 1;
-}
-static inline void mxc_gpio_set(unsigned int gpio, unsigned int value)
-{
-}
-#endif
-
-#endif

diff -urN u-boot-2011.06/include/sdhci.h u-boot-HEAD/include/sdhci.h
--- u-boot-2011.06/include/sdhci.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/include/sdhci.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,325 @@
+/*
+ * Copyright 2011, Marvell Semiconductor Inc.
+ * Lei Wen <leiwen@marvell.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Back ported to the 8xx platform (from the 8260 platform) by
+ * Murray.Jensen@cmst.csiro.au, 27-Jan-01.
+ */
+#ifndef __SDHCI_HW_H
+#define __SDHCI_HW_H
+
+#include <asm/io.h>
+/*
+ * Controller registers
+ */
+
+#define SDHCI_DMA_ADDRESS	0x00
+
+#define SDHCI_BLOCK_SIZE	0x04
+#define  SDHCI_MAKE_BLKSZ(dma, blksz) (((dma & 0x7) << 12) | (blksz & 0xFFF))
+
+#define SDHCI_BLOCK_COUNT	0x06
+
+#define SDHCI_ARGUMENT		0x08
+
+#define SDHCI_TRANSFER_MODE	0x0C
+#define  SDHCI_TRNS_DMA		0x01
+#define  SDHCI_TRNS_BLK_CNT_EN	0x02
+#define  SDHCI_TRNS_ACMD12	0x04
+#define  SDHCI_TRNS_READ	0x10
+#define  SDHCI_TRNS_MULTI	0x20
+
+#define SDHCI_COMMAND		0x0E
+#define  SDHCI_CMD_RESP_MASK	0x03
+#define  SDHCI_CMD_CRC		0x08
+#define  SDHCI_CMD_INDEX	0x10
+#define  SDHCI_CMD_DATA		0x20
+#define  SDHCI_CMD_ABORTCMD	0xC0
+
+#define  SDHCI_CMD_RESP_NONE	0x00
+#define  SDHCI_CMD_RESP_LONG	0x01
+#define  SDHCI_CMD_RESP_SHORT	0x02
+#define  SDHCI_CMD_RESP_SHORT_BUSY 0x03
+
+#define SDHCI_MAKE_CMD(c, f) (((c & 0xff) << 8) | (f & 0xff))
+#define SDHCI_GET_CMD(c) ((c>>8) & 0x3f)
+
+#define SDHCI_RESPONSE		0x10
+
+#define SDHCI_BUFFER		0x20
+
+#define SDHCI_PRESENT_STATE	0x24
+#define  SDHCI_CMD_INHIBIT	0x00000001
+#define  SDHCI_DATA_INHIBIT	0x00000002
+#define  SDHCI_DOING_WRITE	0x00000100
+#define  SDHCI_DOING_READ	0x00000200
+#define  SDHCI_SPACE_AVAILABLE	0x00000400
+#define  SDHCI_DATA_AVAILABLE	0x00000800
+#define  SDHCI_CARD_PRESENT	0x00010000
+#define  SDHCI_WRITE_PROTECT	0x00080000
+
+#define SDHCI_HOST_CONTROL	0x28
+#define  SDHCI_CTRL_LED		0x01
+#define  SDHCI_CTRL_4BITBUS	0x02
+#define  SDHCI_CTRL_HISPD	0x04
+#define  SDHCI_CTRL_DMA_MASK	0x18
+#define   SDHCI_CTRL_SDMA	0x00
+#define   SDHCI_CTRL_ADMA1	0x08
+#define   SDHCI_CTRL_ADMA32	0x10
+#define   SDHCI_CTRL_ADMA64	0x18
+#define   SDHCI_CTRL_8BITBUS	0x20
+
+#define SDHCI_POWER_CONTROL	0x29
+#define  SDHCI_POWER_ON		0x01
+#define  SDHCI_POWER_180	0x0A
+#define  SDHCI_POWER_300	0x0C
+#define  SDHCI_POWER_330	0x0E
+
+#define SDHCI_BLOCK_GAP_CONTROL	0x2A
+
+#define SDHCI_WAKE_UP_CONTROL	0x2B
+#define  SDHCI_WAKE_ON_INT	0x01
+#define  SDHCI_WAKE_ON_INSERT	0x02
+#define  SDHCI_WAKE_ON_REMOVE	0x04
+
+#define SDHCI_CLOCK_CONTROL	0x2C
+#define  SDHCI_DIVIDER_SHIFT	8
+#define  SDHCI_DIVIDER_HI_SHIFT	6
+#define  SDHCI_DIV_MASK	0xFF
+#define  SDHCI_DIV_MASK_LEN	8
+#define  SDHCI_DIV_HI_MASK	0x300
+#define  SDHCI_CLOCK_CARD_EN	0x0004
+#define  SDHCI_CLOCK_INT_STABLE	0x0002
+#define  SDHCI_CLOCK_INT_EN	0x0001
+
+#define SDHCI_TIMEOUT_CONTROL	0x2E
+
+#define SDHCI_SOFTWARE_RESET	0x2F
+#define  SDHCI_RESET_ALL	0x01
+#define  SDHCI_RESET_CMD	0x02
+#define  SDHCI_RESET_DATA	0x04
+
+#define SDHCI_INT_STATUS	0x30
+#define SDHCI_INT_ENABLE	0x34
+#define SDHCI_SIGNAL_ENABLE	0x38
+#define  SDHCI_INT_RESPONSE	0x00000001
+#define  SDHCI_INT_DATA_END	0x00000002
+#define  SDHCI_INT_DMA_END	0x00000008
+#define  SDHCI_INT_SPACE_AVAIL	0x00000010
+#define  SDHCI_INT_DATA_AVAIL	0x00000020
+#define  SDHCI_INT_CARD_INSERT	0x00000040
+#define  SDHCI_INT_CARD_REMOVE	0x00000080
+#define  SDHCI_INT_CARD_INT	0x00000100
+#define  SDHCI_INT_ERROR	0x00008000
+#define  SDHCI_INT_TIMEOUT	0x00010000
+#define  SDHCI_INT_CRC		0x00020000
+#define  SDHCI_INT_END_BIT	0x00040000
+#define  SDHCI_INT_INDEX	0x00080000
+#define  SDHCI_INT_DATA_TIMEOUT	0x00100000
+#define  SDHCI_INT_DATA_CRC	0x00200000
+#define  SDHCI_INT_DATA_END_BIT	0x00400000
+#define  SDHCI_INT_BUS_POWER	0x00800000
+#define  SDHCI_INT_ACMD12ERR	0x01000000
+#define  SDHCI_INT_ADMA_ERROR	0x02000000
+
+#define  SDHCI_INT_NORMAL_MASK	0x00007FFF
+#define  SDHCI_INT_ERROR_MASK	0xFFFF8000
+
+#define  SDHCI_INT_CMD_MASK	(SDHCI_INT_RESPONSE | SDHCI_INT_TIMEOUT | \
+		SDHCI_INT_CRC | SDHCI_INT_END_BIT | SDHCI_INT_INDEX)
+#define  SDHCI_INT_DATA_MASK	(SDHCI_INT_DATA_END | SDHCI_INT_DMA_END | \
+		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL | \
+		SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_DATA_CRC | \
+		SDHCI_INT_DATA_END_BIT | SDHCI_INT_ADMA_ERROR)
+#define SDHCI_INT_ALL_MASK	((unsigned int)-1)
+
+#define SDHCI_ACMD12_ERR	0x3C
+
+/* 3E-3F reserved */
+
+#define SDHCI_CAPABILITIES	0x40
+#define  SDHCI_TIMEOUT_CLK_MASK	0x0000003F
+#define  SDHCI_TIMEOUT_CLK_SHIFT 0
+#define  SDHCI_TIMEOUT_CLK_UNIT	0x00000080
+#define  SDHCI_CLOCK_BASE_MASK	0x00003F00
+#define  SDHCI_CLOCK_V3_BASE_MASK	0x0000FF00
+#define  SDHCI_CLOCK_BASE_SHIFT	8
+#define  SDHCI_MAX_BLOCK_MASK	0x00030000
+#define  SDHCI_MAX_BLOCK_SHIFT  16
+#define  SDHCI_CAN_DO_8BIT	0x00040000
+#define  SDHCI_CAN_DO_ADMA2	0x00080000
+#define  SDHCI_CAN_DO_ADMA1	0x00100000
+#define  SDHCI_CAN_DO_HISPD	0x00200000
+#define  SDHCI_CAN_DO_SDMA	0x00400000
+#define  SDHCI_CAN_VDD_330	0x01000000
+#define  SDHCI_CAN_VDD_300	0x02000000
+#define  SDHCI_CAN_VDD_180	0x04000000
+#define  SDHCI_CAN_64BIT	0x10000000
+
+#define SDHCI_CAPABILITIES_1	0x44
+
+#define SDHCI_MAX_CURRENT	0x48
+
+/* 4C-4F reserved for more max current */
+
+#define SDHCI_SET_ACMD12_ERROR	0x50
+#define SDHCI_SET_INT_ERROR	0x52
+
+#define SDHCI_ADMA_ERROR	0x54
+
+/* 55-57 reserved */
+
+#define SDHCI_ADMA_ADDRESS	0x58
+
+/* 60-FB reserved */
+
+#define SDHCI_SLOT_INT_STATUS	0xFC
+
+#define SDHCI_HOST_VERSION	0xFE
+#define  SDHCI_VENDOR_VER_MASK	0xFF00
+#define  SDHCI_VENDOR_VER_SHIFT	8
+#define  SDHCI_SPEC_VER_MASK	0x00FF
+#define  SDHCI_SPEC_VER_SHIFT	0
+#define   SDHCI_SPEC_100	0
+#define   SDHCI_SPEC_200	1
+#define   SDHCI_SPEC_300	2
+
+/*
+ * End of controller registers.
+ */
+
+#define SDHCI_MAX_DIV_SPEC_200	256
+#define SDHCI_MAX_DIV_SPEC_300	2046
+
+/*
+ * quirks
+ */
+#define SDHCI_QUIRK_32BIT_DMA_ADDR	(1 << 0)
+
+/*
+ * Host SDMA buffer boundary. Valid values from 4K to 512K in powers of 2.
+ */
+#define SDHCI_DEFAULT_BOUNDARY_SIZE	(512 * 1024)
+#define SDHCI_DEFAULT_BOUNDARY_ARG	(7)
+struct sdhci_ops {
+#ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
+	u32             (*read_l)(struct sdhci_host *host, int reg);
+	u16             (*read_w)(struct sdhci_host *host, int reg);
+	u8              (*read_b)(struct sdhci_host *host, int reg);
+	void            (*write_l)(struct sdhci_host *host, u32 val, int reg);
+	void            (*write_w)(struct sdhci_host *host, u16 val, int reg);
+	void            (*write_b)(struct sdhci_host *host, u8 val, int reg);
+#endif
+};
+
+struct sdhci_host {
+	char *name;
+	void *ioaddr;
+	unsigned int quirks;
+	unsigned int version;
+	unsigned int clock;
+	const struct sdhci_ops *ops;
+};
+
+#ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
+
+static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
+{
+	if (unlikely(host->ops->write_l))
+		host->ops->write_l(host, val, reg);
+	else
+		writel(val, host->ioaddr + reg);
+}
+
+static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
+{
+	if (unlikely(host->ops->write_w))
+		host->ops->write_w(host, val, reg);
+	else
+		writew(val, host->ioaddr + reg);
+}
+
+static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
+{
+	if (unlikely(host->ops->write_b))
+		host->ops->write_b(host, val, reg);
+	else
+		writeb(val, host->ioaddr + reg);
+}
+
+static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
+{
+	if (unlikely(host->ops->read_l))
+		return host->ops->read_l(host, reg);
+	else
+		return readl(host->ioaddr + reg);
+}
+
+static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
+{
+	if (unlikely(host->ops->read_w))
+		return host->ops->read_w(host, reg);
+	else
+		return readw(host->ioaddr + reg);
+}
+
+static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
+{
+	if (unlikely(host->ops->read_b))
+		return host->ops->read_b(host, reg);
+	else
+		return readb(host->ioaddr + reg);
+}
+
+#else
+
+static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
+{
+	writel(val, host->ioaddr + reg);
+}
+
+static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
+{
+	writew(val, host->ioaddr + reg);
+}
+
+static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
+{
+	writeb(val, host->ioaddr + reg);
+}
+static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
+{
+	return readl(host->ioaddr + reg);
+}
+
+static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
+{
+	return readw(host->ioaddr + reg);
+}
+
+static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
+{
+	return readb(host->ioaddr + reg);
+}
+#endif
+
+int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk);
+#endif /* __SDHCI_HW_H */

diff -urN u-boot-2011.06/include/sed13806.h u-boot-HEAD/include/sed13806.h
--- u-boot-2011.06/include/sed13806.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/sed13806.h	2011-09-19 23:25:08.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * Stäubli Faverges - <www.staubli.com>
+ * StÃ¤ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * See file CREDITS for list of people who contributed to this
diff -urN u-boot-2011.06/include/serial.h u-boot-HEAD/include/serial.h
--- u-boot-2011.06/include/serial.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/serial.h	2011-09-19 23:25:08.000000000 +0200
@@ -1,12 +1,12 @@
 #ifndef __SERIAL_H__
 #define __SERIAL_H__
 
+#include <post.h>
+
 #define NAMESIZE 16
-#define CTLRSIZE 8
 
 struct serial_device {
 	char name[NAMESIZE];
-	char ctlr[CTLRSIZE];
 
 	int  (*init) (void);
 	int  (*uninit) (void);
@@ -15,6 +15,9 @@
 	int (*tstc) (void);
 	void (*putc) (const char c);
 	void (*puts) (const char *s);
+#if CONFIG_POST & CONFIG_SYS_POST_UART
+	void (*loop) (int);
+#endif
 
 	struct serial_device *next;
 };
@@ -71,6 +74,15 @@
 extern struct serial_device serial_btuart_device;
 extern struct serial_device serial_stuart_device;
 
+#if defined(CONFIG_SYS_BFIN_UART)
+extern void serial_register_bfin_uart(void);
+extern struct serial_device bfin_serial0_device;
+extern struct serial_device bfin_serial1_device;
+extern struct serial_device bfin_serial2_device;
+extern struct serial_device bfin_serial3_device;
+#endif
+
+extern void serial_register(struct serial_device *);
 extern void serial_initialize(void);
 extern void serial_stdio_init(void);
 extern int serial_assign(char * name);
diff -urN u-boot-2011.06/include/sm501.h u-boot-HEAD/include/sm501.h
--- u-boot-2011.06/include/sm501.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/sm501.h	2011-09-19 23:25:08.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2002
- * Stäubli Faverges - <www.staubli.com>
+ * StÃ¤ubli Faverges - <www.staubli.com>
  * Pierre AUBERT  p.aubert@staubli.com
  *
  * (C) Copyright 2005
diff -urN u-boot-2011.06/include/spartan2.h u-boot-HEAD/include/spartan2.h
--- u-boot-2011.06/include/spartan2.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/spartan2.h	2011-09-19 23:25:08.000000000 +0200
@@ -27,9 +27,9 @@
 
 #include <xilinx.h>
 
-extern int Spartan2_load( Xilinx_desc *desc, void *image, size_t size );
-extern int Spartan2_dump( Xilinx_desc *desc, void *buf, size_t bsize );
-extern int Spartan2_info( Xilinx_desc *desc );
+extern int Spartan2_load(Xilinx_desc *desc, const void *image, size_t size);
+extern int Spartan2_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+extern int Spartan2_info(Xilinx_desc *desc);
 
 /* Slave Parallel Implementation function table */
 typedef struct {
diff -urN u-boot-2011.06/include/spartan3.h u-boot-HEAD/include/spartan3.h
--- u-boot-2011.06/include/spartan3.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/spartan3.h	2011-09-19 23:25:08.000000000 +0200
@@ -27,9 +27,9 @@
 
 #include <xilinx.h>
 
-extern int Spartan3_load( Xilinx_desc *desc, void *image, size_t size );
-extern int Spartan3_dump( Xilinx_desc *desc, void *buf, size_t bsize );
-extern int Spartan3_info( Xilinx_desc *desc );
+extern int Spartan3_load(Xilinx_desc *desc, const void *image, size_t size);
+extern int Spartan3_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+extern int Spartan3_info(Xilinx_desc *desc);
 
 /* Slave Parallel Implementation function table */
 typedef struct {
diff -urN u-boot-2011.06/include/spi_flash.h u-boot-HEAD/include/spi_flash.h
--- u-boot-2011.06/include/spi_flash.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/spi_flash.h	2011-09-19 23:25:08.000000000 +0200
@@ -31,8 +31,11 @@
 
 	const char	*name;
 
+	/* Total flash size */
 	u32		size;
-
+	/* Write (page) size */
+	u32		page_size;
+	/* Erase (sector) size */
 	u32		sector_size;
 
 	int		(*read)(struct spi_flash *flash, u32 offset,
diff -urN u-boot-2011.06/include/status_led.h u-boot-HEAD/include/status_led.h
--- u-boot-2011.06/include/status_led.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/status_led.h	2011-09-19 23:25:08.000000000 +0200
@@ -357,24 +357,24 @@
  */
 #ifndef	__ASSEMBLY__
 extern void	coloured_LED_init (void);
-extern void	red_LED_on(void);
-extern void	red_LED_off(void);
-extern void	green_LED_on(void);
-extern void	green_LED_off(void);
-extern void	yellow_LED_on(void);
-extern void	yellow_LED_off(void);
-extern void	blue_LED_on(void);
-extern void	blue_LED_off(void);
+extern void	red_led_on(void);
+extern void	red_led_off(void);
+extern void	green_led_on(void);
+extern void	green_led_off(void);
+extern void	yellow_led_on(void);
+extern void	yellow_led_off(void);
+extern void	blue_led_on(void);
+extern void	blue_led_off(void);
 #else
 	.extern LED_init
-	.extern red_LED_on
-	.extern red_LED_off
-	.extern yellow_LED_on
-	.extern yellow_LED_off
-	.extern green_LED_on
-	.extern green_LED_off
-	.extern blue_LED_on
-	.extern blue_LED_off
+	.extern red_led_on
+	.extern red_led_off
+	.extern yellow_led_on
+	.extern yellow_led_off
+	.extern green_led_on
+	.extern green_led_off
+	.extern blue_led_on
+	.extern blue_led_off
 #endif
 
 #endif	/* CONFIG_STATUS_LED	*/

 diff -urN u-boot-2011.06/include/netdev.h u-boot-HEAD/include/netdev.h
--- u-boot-2011.06/include/netdev.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/netdev.h	2011-09-19 23:25:08.000000000 +0200
@@ -43,29 +43,32 @@
 /* Driver initialization prototypes */
 int altera_tse_initialize(u8 dev_num, int mac_base,
 			  int sgdma_rx_base, int sgdma_tx_base);
-int ax88180_initialize(bd_t *bis);
-int au1x00_enet_initialize(bd_t*);
 int at91emac_register(bd_t *bis, unsigned long iobase);
+int au1x00_enet_initialize(bd_t*);
+int ax88180_initialize(bd_t *bis);
 int bfin_EMAC_initialize(bd_t *bis);
 int cs8900_initialize(u8 dev_num, int base_addr);
-int dc21x4x_initialize(bd_t *bis);
 int davinci_emac_initialize(void);
+int dc21x4x_initialize(bd_t *bis);
 int designware_initialize(u32 id, ulong base_addr, u32 phy_addr);
+int dm9000_initialize(bd_t *bis);
 int dnet_eth_initialize(int id, void *regs, unsigned int phy_addr);
 int e1000_initialize(bd_t *bis);
 int eepro100_initialize(bd_t *bis);
 int enc28j60_initialize(unsigned int bus, unsigned int cs,
 	unsigned int max_hz, unsigned int mode);
 int ep93xx_eth_initialize(u8 dev_num, int base_addr);
-int ethoc_initialize(u8 dev_num, int base_addr);
 int eth_3com_initialize (bd_t * bis);
+int ethoc_initialize(u8 dev_num, int base_addr);
 int fec_initialize (bd_t *bis);
 int fecmxc_initialize (bd_t *bis);
+int fecmxc_initialize(bd_t *bis);
 int ftgmac100_initialize(bd_t *bits);
 int ftmac100_initialize(bd_t *bits);
 int greth_initialize(bd_t *bis);
 void gt6426x_eth_initialize(bd_t *bis);
 int inca_switch_initialize(bd_t *bis);
+int ks8695_eth_initialize(void);
 int lan91c96_initialize(u8 dev_num, int base_addr);
 int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
 int mcdmafec_initialize(bd_t *bis);
@@ -84,16 +87,14 @@
 int rtl8139_initialize(bd_t *bis);
 int rtl8169_initialize(bd_t *bis);
 int scc_initialize(bd_t *bis);
+int sh_eth_initialize(bd_t *bis);
 int skge_initialize(bd_t *bis);
-int smc911x_initialize(u8 dev_num, int base_addr);
 int smc91111_initialize(u8 dev_num, int base_addr);
+int smc911x_initialize(u8 dev_num, int base_addr);
 int tsi108_eth_initialize(bd_t *bis);
 int uec_standard_init(bd_t *bis);
 int uli526x_initialize(bd_t *bis);
 int xilinx_emaclite_initialize (bd_t *bis, int base_addr);
-int sh_eth_initialize(bd_t *bis);
-int dm9000_initialize(bd_t *bis);
-int fecmxc_initialize(bd_t *bis);
 
 /* Boards with PCI network controllers can call this from their board_eth_init()
  * function to initialize whatever's on board.

diff -urN u-boot-2011.06/include/usb_ether.h u-boot-HEAD/include/usb_ether.h
--- u-boot-2011.06/include/usb_ether.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/usb_ether.h	2011-09-19 23:25:08.000000000 +0200
@@ -51,6 +51,11 @@
 	unsigned char	irqinterval;	/* Intervall for IRQ Pipe */
 
 	/* private fields for each driver can go here if needed */
+#ifdef CONFIG_USB_ETHER_SMSC95XX
+	size_t rx_urb_size;  /* maximum USB URB size */
+	u32 mac_cr;  /* MAC control register value */
+	int have_hwaddr;  /* 1 if we have a hardware MAC address */
+#endif
 };
 
 /*
@@ -65,4 +70,12 @@
 		      struct eth_device *eth);
 #endif
 
+#ifdef CONFIG_USB_ETHER_SMSC95XX
+void smsc95xx_eth_before_probe(void);
+int smsc95xx_eth_probe(struct usb_device *dev, unsigned int ifnum,
+			struct ueth_data *ss);
+int smsc95xx_eth_get_info(struct usb_device *dev, struct ueth_data *ss,
+			struct eth_device *eth);
+#endif
+
 #endif /* __USB_ETHER_H__ */

diff -urN u-boot-2011.06/include/virtex2.h u-boot-HEAD/include/virtex2.h
--- u-boot-2011.06/include/virtex2.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/virtex2.h	2011-09-19 23:25:08.000000000 +0200
@@ -28,9 +28,9 @@
 
 #include <xilinx.h>
 
-extern int Virtex2_load( Xilinx_desc *desc, void *image, size_t size );
-extern int Virtex2_dump( Xilinx_desc *desc, void *buf, size_t bsize );
-extern int Virtex2_info( Xilinx_desc *desc );
+extern int Virtex2_load(Xilinx_desc *desc, const void *image, size_t size);
+extern int Virtex2_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+extern int Virtex2_info(Xilinx_desc *desc);
 
 /*
  * Slave SelectMap Implementation function table.
diff -urN u-boot-2011.06/include/xilinx.h u-boot-HEAD/include/xilinx.h
--- u-boot-2011.06/include/xilinx.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/include/xilinx.h	2011-09-19 23:25:08.000000000 +0200
@@ -81,9 +81,9 @@
 
 /* Generic Xilinx Functions
  *********************************************************************/
-extern int xilinx_load( Xilinx_desc *desc, void *image, size_t size );
-extern int xilinx_dump( Xilinx_desc *desc, void *buf, size_t bsize );
-extern int xilinx_info( Xilinx_desc *desc );
+extern int xilinx_load(Xilinx_desc *desc, const void *image, size_t size);
+extern int xilinx_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+extern int xilinx_info(Xilinx_desc *desc);
 
 /* Board specific implementation specific function types
  *********************************************************************/

diff -urN u-boot-2011.06/post/drivers/flash.c u-boot-HEAD/post/drivers/flash.c
--- u-boot-2011.06/post/drivers/flash.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/post/drivers/flash.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,107 @@
+/*
+ * Parallel NOR Flash tests
+ *
+ * Copyright (c) 2005-2011 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <post.h>
+#include <flash.h>
+
+#if CONFIG_POST & CONFIG_SYS_POST_FLASH
+
+/*
+ * This code will walk over the declared sectors erasing them,
+ * then programming them, then verifying the written contents.
+ * Possible future work:
+ *  - verify sectors before/after are not erased/written
+ *  - verify partial writes (e.g. programming only middle of sector)
+ *  - verify the contents of the erased sector
+ *  - better seed pattern than 0x00..0xff
+ */
+
+#ifndef CONFIG_SYS_POST_FLASH_NUM
+# define CONFIG_SYS_POST_FLASH_NUM 0
+#endif
+#if CONFIG_SYS_POST_FLASH_START >= CONFIG_SYS_POST_FLASH_END
+# error "invalid flash block start/end"
+#endif
+
+extern flash_info_t flash_info[];
+
+static void *seed_src_data(void *ptr, ulong *old_len, ulong new_len)
+{
+	unsigned char *p;
+	ulong i;
+
+	p = ptr = realloc(ptr, new_len);
+	if (!ptr)
+		return ptr;
+
+	for (i = *old_len; i < new_len; ++i)
+		p[i] = i;
+
+	*old_len = new_len;
+
+	return ptr;
+}
+
+int flash_post_test(int flags)
+{
+	ulong len;
+	void *src;
+	int ret, n, n_start, n_end;
+	flash_info_t *info;
+
+	/* the output from the common flash layers needs help */
+	puts("\n");
+
+	len = 0;
+	src = NULL;
+	info = &flash_info[CONFIG_SYS_POST_FLASH_NUM];
+	n_start = CONFIG_SYS_POST_FLASH_START;
+	n_end = CONFIG_SYS_POST_FLASH_END;
+
+	for (n = n_start; n < n_end; ++n) {
+		ulong s_start, s_len, s_off;
+
+		s_start = info->start[n];
+		s_len = flash_sector_size(info, n);
+		s_off = s_start - info->start[0];
+
+		src = seed_src_data(src, &len, s_len);
+		if (!src) {
+			printf("malloc(%#lx) failed\n", s_len);
+			return 1;
+		}
+
+		printf("\tsector %i: %#lx +%#lx", n, s_start, s_len);
+
+		ret = flash_erase(info, n, n + 1);
+		if (ret) {
+			flash_perror(ret);
+			break;
+		}
+
+		ret = write_buff(info, src, s_start, s_len);
+		if (ret) {
+			flash_perror(ret);
+			break;
+		}
+
+		ret = memcmp(src, (void *)s_start, s_len);
+		if (ret) {
+			printf(" verify failed with %i\n", ret);
+			break;
+		}
+	}
+
+	free(src);
+
+	return ret;
+}
+
+#endif
diff -urN u-boot-2011.06/post/drivers/Makefile u-boot-HEAD/post/drivers/Makefile
--- u-boot-2011.06/post/drivers/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/post/drivers/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -24,6 +24,6 @@
 
 LIB	= libpostdrivers.o
 
-COBJS-$(CONFIG_HAS_POST)	+= i2c.o memory.o rtc.o
+COBJS-$(CONFIG_HAS_POST)	+= flash.o i2c.o memory.o rtc.o
 
 include $(TOPDIR)/post/rules.mk
diff -urN u-boot-2011.06/post/drivers/memory.c u-boot-HEAD/post/drivers/memory.c
--- u-boot-2011.06/post/drivers/memory.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/post/drivers/memory.c	2011-09-19 23:25:08.000000000 +0200
@@ -225,7 +225,7 @@
 static int memory_post_dataline(unsigned long long * pmem)
 {
 	unsigned long long temp64 = 0;
-	int num_patterns = sizeof(pattern)/ sizeof(pattern[0]);
+	int num_patterns = ARRAY_SIZE(pattern);
 	int i;
 	unsigned int hi, lo, pathi, patlo;
 	int ret = 0;
@@ -452,13 +452,17 @@
 	return ret;
 }
 
+/*
+ * !! this is only valid, if you have contiguous memory banks !!
+ */
 __attribute__((weak))
 int arch_memory_test_prepare(u32 *vstart, u32 *size, phys_addr_t *phys_offset)
 {
 	bd_t *bd = gd->bd;
+
 	*vstart = CONFIG_SYS_SDRAM_BASE;
-	*size = (bd->bi_memsize >= 256 << 20 ?
-			256 << 20 : bd->bi_memsize) - (1 << 20);
+	*size = (gd->ram_size >= 256 << 20 ?
+			256 << 20 : gd->ram_size) - (1 << 20);
 
 	/* Limit area to be tested with the board info struct */
 	if ((*vstart) + (*size) > (ulong)bd)
@@ -500,9 +504,10 @@
 			unsigned long i;
 			for (i = 0; i < (memsize >> 20) && ret == 0; i++) {
 				if (ret == 0)
-					ret = memory_post_tests(i << 20, 0x800);
+					ret = memory_post_tests(vstart +
+						(i << 20), 0x800);
 				if (ret == 0)
-					ret = memory_post_tests(
+					ret = memory_post_tests(vstart +
 						(i << 20) + 0xff800, 0x800);
 			}
 		}
