diff -urN u-boot-2011.06/arch/arm/config.mk u-boot-HEAD/arch/arm/config.mk
--- u-boot-2011.06/arch/arm/config.mk	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/config.mk	2011-09-19 23:25:08.000000000 +0200
@@ -56,9 +56,16 @@
 
 # For EABI, make sure to provide raise()
 ifneq (,$(findstring -mabi=aapcs-linux,$(PLATFORM_CPPFLAGS)))
-# This file is parsed several times; make sure to add only once.
-ifeq (,$(findstring arch/arm/lib/eabi_compat.o,$(PLATFORM_LIBS)))
-PLATFORM_LIBS += $(OBJTREE)/arch/arm/lib/eabi_compat.o
+# This file is parsed many times, so the string may get added multiple
+# times. Also, the prefix needs to be different based on whether
+# CONFIG_SPL_BUILD is defined or not. 'filter-out' the existing entry
+# before adding the correct one.
+ifdef CONFIG_SPL_BUILD
+PLATFORM_LIBS := $(SPLTREE)/arch/arm/lib/eabi_compat.o \
+	$(filter-out %/arch/arm/lib/eabi_compat.o, $(PLATFORM_LIBS))
+else
+PLATFORM_LIBS := $(OBJTREE)/arch/arm/lib/eabi_compat.o \
+	$(filter-out %/arch/arm/lib/eabi_compat.o, $(PLATFORM_LIBS))
 endif
 endif
 
diff -urN u-boot-2011.06/arch/arm/cpu/arm1136/start.S u-boot-HEAD/arch/arm/cpu/arm1136/start.S
--- u-boot-2011.06/arch/arm/cpu/arm1136/start.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm1136/start.S	2011-09-19 23:25:08.000000000 +0200
@@ -3,8 +3,8 @@
  *
  *  Copyright (c) 2004	Texas Instruments <r-woodruff2@ti.com>
  *
- *  Copyright (c) 2001	Marius Gröger <mag@sysgo.de>
- *  Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
+ *  Copyright (c) 2001	Marius GrÃ¶ger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex ZÃ¼pke <azu@sysgo.de>
  *  Copyright (c) 2002	Gary Jennejohn <garyj@denx.de>
  *  Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
  *  Copyright (c) 2003	Kshitij <kshitij@ti.com>
@@ -33,7 +33,7 @@
 #include <version.h>
 .globl _start
 _start: b	reset
-#ifdef CONFIG_PRELOADER
+#ifdef CONFIG_SPL_BUILD
 	ldr	pc, _hang
 	ldr	pc, _hang
 	ldr	pc, _hang
@@ -68,7 +68,7 @@
 _irq:			.word irq
 _fiq:			.word fiq
 _pad:			.word 0x12345678 /* now 16*4=64 */
-#endif	/* CONFIG_PRELOADER */
+#endif	/* CONFIG_SPL_BUILD */
 .global _end_vect
 _end_vect:
 
@@ -201,7 +201,7 @@
 	cmp	r0, r2			/* until source end address [r2]    */
 	blo	copy_loop
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * fix .rel.dyn relocations
 	 */
@@ -243,7 +243,7 @@
 #endif
 
 clear_bss:
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
 	mov	r4, r6			/* reloc addr */
@@ -255,7 +255,7 @@
 	add	r0, r0, #4
 	cmp	r0, r1
 	bne	clbss_l
-#endif	/* #ifndef CONFIG_PRELOADER */
+#endif	/* #ifndef CONFIG_SPL_BUILD */
 
 /*
  * We are done. Do not return, instead branch to second part of board
@@ -329,7 +329,7 @@
 	mov	pc, lr		/* back to my caller */
 #endif /* CONFIG_SKIP_LOWLEVEL_INIT */
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 /*
  *************************************************************************
  *
@@ -436,17 +436,17 @@
 	.macro get_fiq_stack			@ setup FIQ stack
 	ldr	sp, FIQ_STACK_START
 	.endm
-#endif	/* CONFIG_PRELOADER */
+#endif	/* CONFIG_SPL_BUILD */
 
 /*
  * exception handlers
  */
-#ifdef CONFIG_PRELOADER
+#ifdef CONFIG_SPL_BUILD
 	.align	5
 do_hang:
 	ldr	sp, _TEXT_BASE			/* use 32 words about stack */
 	bl	hang				/* hang and never return */
-#else	/* !CONFIG_PRELOADER */
+#else	/* !CONFIG_SPL_BUILD */
 	.align	5
 undefined_instruction:
 	get_bad_stack
@@ -512,11 +512,11 @@
 	.align 5
 .global arm1136_cache_flush
 arm1136_cache_flush:
-#if !defined(CONFIG_SYS_NO_ICACHE)
+#if !defined(CONFIG_SYS_ICACHE_OFF)
 		mcr	p15, 0, r1, c7, c5, 0	@ invalidate I cache
 #endif
-#if !defined(CONFIG_SYS_NO_DCACHE)
+#if !defined(CONFIG_SYS_DCACHE_OFF)
 		mcr	p15, 0, r1, c7, c14, 0	@ invalidate D cache
 #endif
 		mov	pc, lr			@ back to caller
-#endif	/* CONFIG_PRELOADER */
+#endif	/* CONFIG_SPL_BUILD */

diff -urN u-boot-2011.06/arch/arm/cpu/arm1176/start.S u-boot-HEAD/arch/arm/cpu/arm1176/start.S
--- u-boot-2011.06/arch/arm/cpu/arm1176/start.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm1176/start.S	2011-09-19 23:25:08.000000000 +0200
@@ -263,7 +263,7 @@
 	cmp	r0, r2			/* until source end address [r2]    */
 	blo	copy_loop
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * fix .rel.dyn relocations
 	 */
@@ -343,7 +343,7 @@
 #endif
 
 clear_bss:
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
 	mov	r4, r6			/* reloc addr */
@@ -358,7 +358,7 @@
 
 #ifndef CONFIG_NAND_SPL
 	bl coloured_LED_init
-	bl red_LED_on
+	bl red_led_on
 #endif
 #endif
 
diff -urN u-boot-2011.06/arch/arm/cpu/arm720t/cpu.c u-boot-HEAD/arch/arm/cpu/arm720t/cpu.c
--- u-boot-2011.06/arch/arm/cpu/arm720t/cpu.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm720t/cpu.c	2011-09-19 23:25:08.000000000 +0200
@@ -36,10 +36,6 @@
 #include <asm/hardware.h>
 #include <asm/system.h>
 
-#if defined(CONFIG_IMPA7) || defined(CONFIG_EP7312) || defined(CONFIG_ARMADILLO)
-static void cache_flush(void);
-#endif
-
 int cleanup_before_linux (void)
 {
 	/*
@@ -50,20 +46,7 @@
 	 * and we set the CPU-speed to 73 MHz - see start.S for details
 	 */
 
-#if defined(CONFIG_IMPA7) || defined(CONFIG_EP7312) || defined(CONFIG_ARMADILLO)
-	disable_interrupts ();
-
-	/* turn off I-cache */
-	icache_disable();
-	dcache_disable();
-
-	/* flush I-cache */
-	cache_flush();
-#ifdef CONFIG_ARM7_REVD
-	/* go to high speed */
-	IO_SYSCON3 = (IO_SYSCON3 & ~CLKCTL) | CLKCTL_73;
-#endif
-#elif defined(CONFIG_NETARM) || defined(CONFIG_S3C4510B) || defined(CONFIG_LPC2292)
+#if defined(CONFIG_NETARM) || defined(CONFIG_S3C4510B) || defined(CONFIG_LPC2292)
 	disable_interrupts ();
 	/* Nothing more needed */
 #elif defined(CONFIG_INTEGRATOR) && defined(CONFIG_ARCH_INTEGRATOR)
@@ -73,18 +56,3 @@
 #endif
 	return 0;
 }
-
-#if defined(CONFIG_IMPA7) || defined(CONFIG_EP7312) || defined(CONFIG_ARMADILLO)
-/* flush I/D-cache */
-static void cache_flush (void)
-{
-	unsigned long i = 0;
-
-	asm ("mcr p15, 0, %0, c7, c5, 0": :"r" (i));
-}
-#elif defined(CONFIG_INTEGRATOR) && defined(CONFIG_ARCH_INTEGRATOR)
-	/* No specific cache setup for IntegratorAP/CM720T as yet */
-	void icache_enable (void)
-	{
-	}
-#endif

diff -urN u-boot-2011.06/arch/arm/cpu/arm720t/interrupts.c u-boot-HEAD/arch/arm/cpu/arm720t/interrupts.c
--- u-boot-2011.06/arch/arm/cpu/arm720t/interrupts.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm720t/interrupts.c	2011-09-19 23:25:08.000000000 +0200
@@ -149,18 +149,6 @@
 
 	/* set timer 2 counter */
 	lastdec = TIMER_LOAD_VAL;
-#elif defined(CONFIG_IMPA7) || defined(CONFIG_EP7312) || defined(CONFIG_ARMADILLO)
-	/* disable all interrupts */
-	IO_INTMR1 = 0;
-
-	/* operate timer 1 in prescale mode */
-	IO_SYSCON1 |= SYSCON1_TC1M;
-
-	/* select 2kHz clock source for timer 1 */
-	IO_SYSCON1 &= ~SYSCON1_TC1S;
-
-	/* set timer 1 counter */
-	lastdec = IO_TC1D = TIMER_LOAD_VAL;
 #elif defined(CONFIG_S3C4510B)
 	/* configure free running timer 0 */
 	PUT_REG( REG_TMOD, 0x0);
@@ -207,23 +195,13 @@
  */
 
 
-#if defined(CONFIG_IMPA7) || defined(CONFIG_EP7312) || defined(CONFIG_NETARM) || defined(CONFIG_ARMADILLO) || defined(CONFIG_LPC2292)
-
-void reset_timer (void)
-{
-	reset_timer_masked ();
-}
+#if defined(CONFIG_NETARM) || defined(CONFIG_LPC2292)
 
 ulong get_timer (ulong base)
 {
 	return get_timer_masked () - base;
 }
 
-void set_timer (ulong t)
-{
-	timestamp = t;
-}
-
 void __udelay (unsigned long usec)
 {
 	ulong tmo;
@@ -243,13 +221,6 @@
 #endif
 }
 
-void reset_timer_masked (void)
-{
-	/* reset time */
-	lastdec = READ_TIMER;
-	timestamp = 0;
-}
-
 ulong get_timer_masked (void)
 {
 	ulong now = READ_TIMER;
 
diff -urN u-boot-2011.06/arch/arm/cpu/arm720t/start.S u-boot-HEAD/arch/arm/cpu/arm720t/start.S
--- u-boot-2011.06/arch/arm/cpu/arm720t/start.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm720t/start.S	2011-09-19 23:25:08.000000000 +0200
@@ -1,8 +1,8 @@
 /*
  *  armboot - Startup Code for ARM720 CPU-core
  *
- *  Copyright (c) 2001	Marius Gröger <mag@sysgo.de>
- *  Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
+ *  Copyright (c) 2001	Marius GrÃ¶ger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex ZÃ¼pke <azu@sysgo.de>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -178,7 +178,7 @@
 	cmp	r0, r2			/* until source end address [r2]    */
 	blo	copy_loop
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * fix .rel.dyn relocations
 	 */
@@ -220,7 +220,7 @@
 #endif
 
 clear_bss:
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
 	mov	r4, r6			/* reloc addr */
@@ -234,7 +234,7 @@
 	bne	clbss_l
 
 	bl coloured_LED_init
-	bl red_LED_on
+	bl red_led_on
 #endif
 
 /*
@@ -272,25 +272,7 @@
  *************************************************************************
  */
 
-#if defined(CONFIG_IMPA7) || defined(CONFIG_EP7312) || defined(CONFIG_ARMADILLO)
-
-/* Interupt-Controller base addresses */
-INTMR1:		.word	0x80000280 @ 32 bit size
-INTMR2:		.word	0x80001280 @ 16 bit size
-INTMR3:		.word	0x80002280 @  8 bit size
-
-/* SYSCONs */
-SYSCON1:	.word	0x80000100
-SYSCON2:	.word	0x80001100
-SYSCON3:	.word	0x80002200
-
-#define CLKCTL	       0x6  /* mask */
-#define CLKCTL_18      0x0  /* 18.432 MHz */
-#define CLKCTL_36      0x2  /* 36.864 MHz */
-#define CLKCTL_49      0x4  /* 49.152 MHz */
-#define CLKCTL_73      0x6  /* 73.728 MHz */
-
-#elif defined(CONFIG_LPC2292)
+#if defined(CONFIG_LPC2292)
 PLLCFG_ADR:	.word	PLLCFG
 PLLFEED_ADR:	.word	PLLFEED
 PLLCON_ADR:	.word	PLLCON
@@ -301,35 +283,7 @@
 #endif
 
 cpu_init_crit:
-#if defined(CONFIG_IMPA7) || defined(CONFIG_EP7312) || defined(CONFIG_ARMADILLO)
-
-	/*
-	 * mask all IRQs by clearing all bits in the INTMRs
-	 */
-	mov	r1, #0x00
-	ldr	r0, INTMR1
-	str	r1, [r0]
-	ldr	r0, INTMR2
-	str	r1, [r0]
-	ldr	r0, INTMR3
-	str	r1, [r0]
-
-	/*
-	 * flush v4 I/D caches
-	 */
-	mov	r0, #0
-	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
-	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
-
-	/*
-	 * disable MMU stuff and caches
-	 */
-	mrc	p15,0,r0,c1,c0
-	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
-	bic	r0, r0, #0x0000008f	@ clear bits 7, 3:0 (B--- WCAM)
-	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
-	mcr	p15,0,r0,c1,c0
-#elif defined(CONFIG_NETARM)
+#if defined(CONFIG_NETARM)
 	/*
 	 * prior to software reset : need to set pin PORTC4 to be *HRESET
 	 */
@@ -634,19 +588,7 @@
 
 #endif
 
-#if defined(CONFIG_IMPA7) || defined(CONFIG_EP7312) || defined(CONFIG_ARMADILLO)
-	.align	5
-.globl reset_cpu
-reset_cpu:
-	mov	ip, #0
-	mcr	p15, 0, ip, c7, c7, 0		@ invalidate cache
-	mcr	p15, 0, ip, c8, c7, 0		@ flush TLB (v4)
-	mrc	p15, 0, ip, c1, c0, 0		@ get ctrl register
-	bic	ip, ip, #0x000f			@ ............wcam
-	bic	ip, ip, #0x2100			@ ..v....s........
-	mcr	p15, 0, ip, c1, c0, 0		@ ctrl register
-	mov	pc, r0
-#elif defined(CONFIG_NETARM)
+#if defined(CONFIG_NETARM)
 	.align	5
 .globl reset_cpu
 reset_cpu:

diff -urN u-boot-2011.06/arch/arm/cpu/arm920t/cpu.c u-boot-HEAD/arch/arm/cpu/arm920t/cpu.c
--- u-boot-2011.06/arch/arm/cpu/arm920t/cpu.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm920t/cpu.c	2011-09-19 23:25:08.000000000 +0200
@@ -33,10 +33,6 @@
 #include <command.h>
 #include <asm/system.h>
 
-#ifdef CONFIG_AT91_LEGACY
-#warning Your board is using legacy AT91RM9200 SoC access. Please update!
-#endif
-
 static void cache_flush(void);
 
 int cleanup_before_linux (void)
 
diff -urN u-boot-2011.06/arch/arm/cpu/arm920t/start.S u-boot-HEAD/arch/arm/cpu/arm920t/start.S
--- u-boot-2011.06/arch/arm/cpu/arm920t/start.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm920t/start.S	2011-09-19 23:25:08.000000000 +0200
@@ -1,8 +1,8 @@
 /*
  *  armboot - Startup Code for ARM920 CPU-core
  *
- *  Copyright (c) 2001	Marius Gröger <mag@sysgo.de>
- *  Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
+ *  Copyright (c) 2001	Marius GrÃ¶ger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex ZÃ¼pke <azu@sysgo.de>
  *  Copyright (c) 2002	Gary Jennejohn <garyj@denx.de>
  *
  * See file CREDITS for list of people who contributed to this
@@ -142,11 +142,11 @@
 
 # if defined(CONFIG_S3C2400)
 #  define pWTCON	0x15300000
-#  define INTMSK	0x14400008	/* Interupt-Controller base addresses */
+#  define INTMSK	0x14400008	/* Interrupt-Controller base addresses */
 #  define CLKDIVN	0x14800014	/* clock divisor register */
 #else
 #  define pWTCON	0x53000000
-#  define INTMSK	0x4A000008	/* Interupt-Controller base addresses */
+#  define INTMSK	0x4A000008	/* Interrupt-Controller base addresses */
 #  define INTSUBMSK	0x4A00001C
 #  define CLKDIVN	0x4C000014	/* clock divisor register */
 # endif
@@ -221,7 +221,7 @@
 	cmp	r0, r2			/* until source end address [r2]    */
 	blo	copy_loop
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * fix .rel.dyn relocations
 	 */
@@ -263,7 +263,7 @@
 #endif
 
 clear_bss:
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
 	mov	r4, r6			/* reloc addr */
@@ -277,7 +277,7 @@
 	bne	clbss_l
 
 	bl coloured_LED_init
-	bl red_LED_on
+	bl red_led_on
 #endif
 
 /*

diff -urN u-boot-2011.06/arch/arm/cpu/arm925t/start.S u-boot-HEAD/arch/arm/cpu/arm925t/start.S
--- u-boot-2011.06/arch/arm/cpu/arm925t/start.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm925t/start.S	2011-09-19 23:25:08.000000000 +0200
@@ -5,8 +5,8 @@
  *
  *  ----- Adapted for OMAP1510 from ARM920 code ------
  *
- *  Copyright (c) 2001	Marius Gröger <mag@sysgo.de>
- *  Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
+ *  Copyright (c) 2001	Marius GrÃ¶ger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex ZÃ¼pke <azu@sysgo.de>
  *  Copyright (c) 2002	Gary Jennejohn <garyj@denx.de>
  *  Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
  *  Copyright (c) 2003	Kshitij	 <kshitij@ti.com>
@@ -215,7 +215,7 @@
 	cmp	r0, r2			/* until source end address [r2]    */
 	blo	copy_loop
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * fix .rel.dyn relocations
 	 */
@@ -257,7 +257,7 @@
 #endif
 
 clear_bss:
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
 	mov	r4, r6			/* reloc addr */
@@ -271,7 +271,7 @@
 	bne	clbss_l
 
 	bl coloured_LED_init
-	bl red_LED_on
+	bl red_led_on
 #endif
 
 /*

diff -urN u-boot-2011.06/arch/arm/cpu/arm925t/timer.c u-boot-HEAD/arch/arm/cpu/arm925t/timer.c
--- u-boot-2011.06/arch/arm/cpu/arm925t/timer.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm925t/timer.c	2011-09-19 23:25:08.000000000 +0200
@@ -56,7 +56,9 @@
 		CONFIG_SYS_TIMERBASE + CNTL_TIMER);
 
 	/* init the timestamp and lastdec value */
-	reset_timer_masked();
+	lastdec = __raw_readl(CONFIG_SYS_TIMERBASE + READ_TIM) /
+			(TIMER_CLOCK / CONFIG_SYS_HZ);
+	timestamp = 0;	       /* start "advancing" time stamp from 0 */
 
 	return 0;
 }
@@ -64,22 +66,11 @@
 /*
  * timer without interrupts
  */
-
-void reset_timer (void)
-{
-	reset_timer_masked ();
-}
-
 ulong get_timer (ulong base)
 {
 	return get_timer_masked () - base;
 }
 
-void set_timer (ulong t)
-{
-	timestamp = t;
-}
-
 /* delay x useconds AND preserve advance timestamp value */
 void __udelay (unsigned long usec)
 {
@@ -96,14 +87,6 @@
 	}
 }
 
-void reset_timer_masked (void)
-{
-	/* reset time */
-	lastdec = __raw_readl(CONFIG_SYS_TIMERBASE + READ_TIM) /
-			(TIMER_CLOCK / CONFIG_SYS_HZ);
-	timestamp = 0;	       /* start "advancing" time stamp from 0 */
-}
-
 ulong get_timer_masked (void)
 {
 	uint32_t now = __raw_readl(CONFIG_SYS_TIMERBASE + READ_TIM) /

diff -urN u-boot-2011.06/arch/arm/cpu/arm926ejs/start.S u-boot-HEAD/arch/arm/cpu/arm926ejs/start.S
--- u-boot-2011.06/arch/arm/cpu/arm926ejs/start.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm926ejs/start.S	2011-09-19 23:25:08.000000000 +0200
@@ -5,8 +5,8 @@
  *
  *  ----- Adapted for OMAP1610 OMAP730 from ARM925t code ------
  *
- *  Copyright (c) 2001	Marius Gröger <mag@sysgo.de>
- *  Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
+ *  Copyright (c) 2001	Marius GrÃ¶ger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex ZÃ¼pke <azu@sysgo.de>
  *  Copyright (c) 2002	Gary Jennejohn <garyj@denx.de>
  *  Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
  *  Copyright (c) 2003	Kshitij <kshitij@ti.com>
@@ -54,7 +54,7 @@
 .globl _start
 _start:
 	b	reset
-#ifdef CONFIG_PRELOADER
+#ifdef CONFIG_SPL_BUILD
 /* No exception handlers in preloader */
 	ldr	pc, _hang
 	ldr	pc, _hang
@@ -98,7 +98,7 @@
 _fiq:
 	.word fiq
 
-#endif	/* CONFIG_PRELOADER */
+#endif	/* CONFIG_SPL_BUILD */
 	.balignl 16,0xdeadbeef
 
 
@@ -214,7 +214,7 @@
 	cmp	r0, r2			/* until source end address [r2]    */
 	blo	copy_loop
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * fix .rel.dyn relocations
 	 */
@@ -256,7 +256,7 @@
 #endif
 
 clear_bss:
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
 	mov	r4, r6			/* reloc addr */
@@ -270,7 +270,7 @@
 	bne	clbss_l
 
 	bl coloured_LED_init
-	bl red_LED_on
+	bl red_led_on
 #endif
 
 /*
@@ -343,7 +343,7 @@
 	mov	pc, lr		/* back to my caller */
 #endif /* CONFIG_SKIP_LOWLEVEL_INIT */
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 /*
  *************************************************************************
  *
@@ -440,18 +440,18 @@
 	.macro get_fiq_stack			@ setup FIQ stack
 	ldr	sp, FIQ_STACK_START
 	.endm
-#endif	/* CONFIG_PRELOADER */
+#endif	/* CONFIG_SPL_BUILD */
 
 /*
  * exception handlers
  */
-#ifdef CONFIG_PRELOADER
+#ifdef CONFIG_SPL_BUILD
 	.align	5
 do_hang:
 	ldr	sp, _TEXT_BASE			/* switch to abort stack */
 1:
 	bl	1b				/* hang and never return */
-#else	/* !CONFIG_PRELOADER */
+#else	/* !CONFIG_SPL_BUILD */
 	.align  5
 undefined_instruction:
 	get_bad_stack
@@ -514,4 +514,4 @@
 	bl	do_fiq
 
 #endif
-#endif	/* CONFIG_PRELOADER */
+#endif	/* CONFIG_SPL_BUILD */

diff -urN u-boot-2011.06/arch/arm/cpu/arm946es/start.S u-boot-HEAD/arch/arm/cpu/arm946es/start.S
--- u-boot-2011.06/arch/arm/cpu/arm946es/start.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/arm946es/start.S	2011-09-19 23:25:08.000000000 +0200
@@ -5,8 +5,8 @@
  *
  *  ----- Adapted for OMAP1610 OMAP730 from ARM925t code ------
  *
- *  Copyright (c) 2001	Marius Gröger <mag@sysgo.de>
- *  Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
+ *  Copyright (c) 2001	Marius GrÃ¶ger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex ZÃ¼pke <azu@sysgo.de>
  *  Copyright (c) 2002	Gary Jennejohn <garyj@denx.de>
  *  Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
  *  Copyright (c) 2003	Kshitij <kshitij@ti.com>
@@ -186,7 +186,7 @@
 	cmp	r0, r2			/* until source end address [r2]    */
 	blo	copy_loop
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * fix .rel.dyn relocations
 	 */
@@ -228,7 +228,7 @@
 #endif
 
 clear_bss:
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
 	mov	r4, r6			/* reloc addr */

diff -urN u-boot-2011.06/arch/arm/cpu/armv7/cache_v7.c u-boot-HEAD/arch/arm/cpu/armv7/cache_v7.c
--- u-boot-2011.06/arch/arm/cpu/armv7/cache_v7.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/arch/arm/cpu/armv7/cache_v7.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,396 @@
+/*
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ * Aneesh V <aneesh@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <linux/types.h>
+#include <common.h>
+#include <asm/armv7.h>
+#include <asm/utils.h>
+
+#define ARMV7_DCACHE_INVAL_ALL		1
+#define ARMV7_DCACHE_CLEAN_INVAL_ALL	2
+#define ARMV7_DCACHE_INVAL_RANGE	3
+#define ARMV7_DCACHE_CLEAN_INVAL_RANGE	4
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+/*
+ * Write the level and type you want to Cache Size Selection Register(CSSELR)
+ * to get size details from Current Cache Size ID Register(CCSIDR)
+ */
+static void set_csselr(u32 level, u32 type)
+{	u32 csselr = level << 1 | type;
+
+	/* Write to Cache Size Selection Register(CSSELR) */
+	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r" (csselr));
+}
+
+static u32 get_ccsidr(void)
+{
+	u32 ccsidr;
+
+	/* Read current CP15 Cache Size ID Register */
+	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
+	return ccsidr;
+}
+
+static u32 get_clidr(void)
+{
+	u32 clidr;
+
+	/* Read current CP15 Cache Level ID Register */
+	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
+	return clidr;
+}
+
+static void v7_inval_dcache_level_setway(u32 level, u32 num_sets,
+					 u32 num_ways, u32 way_shift,
+					 u32 log2_line_len)
+{
+	int way, set, setway;
+
+	/*
+	 * For optimal assembly code:
+	 *	a. count down
+	 *	b. have bigger loop inside
+	 */
+	for (way = num_ways - 1; way >= 0 ; way--) {
+		for (set = num_sets - 1; set >= 0; set--) {
+			setway = (level << 1) | (set << log2_line_len) |
+				 (way << way_shift);
+			/* Invalidate data/unified cache line by set/way */
+			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
+					: : "r" (setway));
+		}
+	}
+	/* DSB to make sure the operation is complete */
+	CP15DSB;
+}
+
+static void v7_clean_inval_dcache_level_setway(u32 level, u32 num_sets,
+					       u32 num_ways, u32 way_shift,
+					       u32 log2_line_len)
+{
+	int way, set, setway;
+
+	/*
+	 * For optimal assembly code:
+	 *	a. count down
+	 *	b. have bigger loop inside
+	 */
+	for (way = num_ways - 1; way >= 0 ; way--) {
+		for (set = num_sets - 1; set >= 0; set--) {
+			setway = (level << 1) | (set << log2_line_len) |
+				 (way << way_shift);
+			/*
+			 * Clean & Invalidate data/unified
+			 * cache line by set/way
+			 */
+			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
+					: : "r" (setway));
+		}
+	}
+	/* DSB to make sure the operation is complete */
+	CP15DSB;
+}
+
+static void v7_maint_dcache_level_setway(u32 level, u32 operation)
+{
+	u32 ccsidr;
+	u32 num_sets, num_ways, log2_line_len, log2_num_ways;
+	u32 way_shift;
+
+	set_csselr(level, ARMV7_CSSELR_IND_DATA_UNIFIED);
+
+	ccsidr = get_ccsidr();
+
+	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
+				CCSIDR_LINE_SIZE_OFFSET) + 2;
+	/* Converting from words to bytes */
+	log2_line_len += 2;
+
+	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
+			CCSIDR_ASSOCIATIVITY_OFFSET) + 1;
+	num_sets  = ((ccsidr & CCSIDR_NUM_SETS_MASK) >>
+			CCSIDR_NUM_SETS_OFFSET) + 1;
+	/*
+	 * According to ARMv7 ARM number of sets and number of ways need
+	 * not be a power of 2
+	 */
+	log2_num_ways = log_2_n_round_up(num_ways);
+
+	way_shift = (32 - log2_num_ways);
+	if (operation == ARMV7_DCACHE_INVAL_ALL) {
+		v7_inval_dcache_level_setway(level, num_sets, num_ways,
+				      way_shift, log2_line_len);
+	} else if (operation == ARMV7_DCACHE_CLEAN_INVAL_ALL) {
+		v7_clean_inval_dcache_level_setway(level, num_sets, num_ways,
+						   way_shift, log2_line_len);
+	}
+}
+
+static void v7_maint_dcache_all(u32 operation)
+{
+	u32 level, cache_type, level_start_bit = 0;
+
+	u32 clidr = get_clidr();
+
+	for (level = 0; level < 7; level++) {
+		cache_type = (clidr >> level_start_bit) & 0x7;
+		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
+		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
+		    (cache_type == ARMV7_CLIDR_CTYPE_UNIFIED))
+			v7_maint_dcache_level_setway(level, operation);
+		level_start_bit += 3;
+	}
+}
+
+static void v7_dcache_clean_inval_range(u32 start,
+					u32 stop, u32 line_len)
+{
+	u32 mva;
+
+	/* Align start to cache line boundary */
+	start &= ~(line_len - 1);
+	for (mva = start; mva < stop; mva = mva + line_len) {
+		/* DCCIMVAC - Clean & Invalidate data cache by MVA to PoC */
+		asm volatile ("mcr p15, 0, %0, c7, c14, 1" : : "r" (mva));
+	}
+}
+
+static void v7_dcache_inval_range(u32 start, u32 stop, u32 line_len)
+{
+	u32 mva;
+
+	/*
+	 * If start address is not aligned to cache-line do not
+	 * invalidate the first cache-line
+	 */
+	if (start & (line_len - 1)) {
+		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
+			__func__, start);
+		/* move to next cache line */
+		start = (start + line_len - 1) & ~(line_len - 1);
+	}
+
+	/*
+	 * If stop address is not aligned to cache-line do not
+	 * invalidate the last cache-line
+	 */
+	if (stop & (line_len - 1)) {
+		printf("ERROR: %s - stop address is not aligned - 0x%08x\n",
+			__func__, stop);
+		/* align to the beginning of this cache line */
+		stop &= ~(line_len - 1);
+	}
+
+	for (mva = start; mva < stop; mva = mva + line_len) {
+		/* DCIMVAC - Invalidate data cache by MVA to PoC */
+		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
+	}
+}
+
+static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
+{
+	u32 line_len, ccsidr;
+
+	ccsidr = get_ccsidr();
+	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
+			CCSIDR_LINE_SIZE_OFFSET) + 2;
+	/* Converting from words to bytes */
+	line_len += 2;
+	/* converting from log2(linelen) to linelen */
+	line_len = 1 << line_len;
+
+	switch (range_op) {
+	case ARMV7_DCACHE_CLEAN_INVAL_RANGE:
+		v7_dcache_clean_inval_range(start, stop, line_len);
+		break;
+	case ARMV7_DCACHE_INVAL_RANGE:
+		v7_dcache_inval_range(start, stop, line_len);
+		break;
+	}
+
+	/* DSB to make sure the operation is complete */
+	CP15DSB;
+}
+
+/* Invalidate TLB */
+static void v7_inval_tlb(void)
+{
+	/* Invalidate entire unified TLB */
+	asm volatile ("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
+	/* Invalidate entire data TLB */
+	asm volatile ("mcr p15, 0, %0, c8, c6, 0" : : "r" (0));
+	/* Invalidate entire instruction TLB */
+	asm volatile ("mcr p15, 0, %0, c8, c5, 0" : : "r" (0));
+	/* Full system DSB - make sure that the invalidation is complete */
+	CP15DSB;
+	/* Full system ISB - make sure the instruction stream sees it */
+	CP15ISB;
+}
+
+void invalidate_dcache_all(void)
+{
+	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);
+
+	v7_outer_cache_inval_all();
+}
+
+/*
+ * Performs a clean & invalidation of the entire data cache
+ * at all levels
+ */
+void flush_dcache_all(void)
+{
+	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);
+
+	v7_outer_cache_flush_all();
+}
+
+/*
+ * Invalidates range in all levels of D-cache/unified cache used:
+ * Affects the range [start, stop - 1]
+ */
+void invalidate_dcache_range(unsigned long start, unsigned long stop)
+{
+
+	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
+
+	v7_outer_cache_inval_range(start, stop);
+}
+
+/*
+ * Flush range(clean & invalidate) from all levels of D-cache/unified
+ * cache used:
+ * Affects the range [start, stop - 1]
+ */
+void flush_dcache_range(unsigned long start, unsigned long stop)
+{
+	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
+
+	v7_outer_cache_flush_range(start, stop);
+}
+
+void arm_init_before_mmu(void)
+{
+	v7_outer_cache_enable();
+	invalidate_dcache_all();
+	v7_inval_tlb();
+}
+
+/*
+ * Flush range from all levels of d-cache/unified-cache used:
+ * Affects the range [start, start + size - 1]
+ */
+void  flush_cache(unsigned long start, unsigned long size)
+{
+	flush_dcache_range(start, start + size);
+}
+#else /* #ifndef CONFIG_SYS_DCACHE_OFF */
+void invalidate_dcache_all(void)
+{
+}
+
+void flush_dcache_all(void)
+{
+}
+
+void invalidate_dcache_range(unsigned long start, unsigned long stop)
+{
+}
+
+void flush_dcache_range(unsigned long start, unsigned long stop)
+{
+}
+
+void arm_init_before_mmu(void)
+{
+}
+
+void  flush_cache(unsigned long start, unsigned long size)
+{
+}
+#endif /* #ifndef CONFIG_SYS_DCACHE_OFF */
+
+#ifndef CONFIG_SYS_ICACHE_OFF
+/* Invalidate entire I-cache and branch predictor array */
+void invalidate_icache_all(void)
+{
+	/*
+	 * Invalidate all instruction caches to PoU.
+	 * Also flushes branch target cache.
+	 */
+	asm volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
+
+	/* Invalidate entire branch predictor array */
+	asm volatile ("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));
+
+	/* Full system DSB - make sure that the invalidation is complete */
+	CP15DSB;
+
+	/* ISB - make sure the instruction stream sees it */
+	CP15ISB;
+}
+#else
+void invalidate_icache_all(void)
+{
+}
+#endif
+
+/*
+ * Stub implementations for outer cache operations
+ */
+void __v7_outer_cache_enable(void)
+{
+}
+void v7_outer_cache_enable(void)
+	__attribute__((weak, alias("__v7_outer_cache_enable")));
+
+void __v7_outer_cache_disable(void)
+{
+}
+void v7_outer_cache_disable(void)
+	__attribute__((weak, alias("__v7_outer_cache_disable")));
+
+void __v7_outer_cache_flush_all(void)
+{
+}
+void v7_outer_cache_flush_all(void)
+	__attribute__((weak, alias("__v7_outer_cache_flush_all")));
+
+void __v7_outer_cache_inval_all(void)
+{
+}
+void v7_outer_cache_inval_all(void)
+	__attribute__((weak, alias("__v7_outer_cache_inval_all")));
+
+void __v7_outer_cache_flush_range(u32 start, u32 end)
+{
+}
+void v7_outer_cache_flush_range(u32 start, u32 end)
+	__attribute__((weak, alias("__v7_outer_cache_flush_range")));
+
+void __v7_outer_cache_inval_range(u32 start, u32 end)
+{
+}
+void v7_outer_cache_inval_range(u32 start, u32 end)
+	__attribute__((weak, alias("__v7_outer_cache_inval_range")));

diff -urN u-boot-2011.06/arch/arm/cpu/armv7/cpu.c u-boot-HEAD/arch/arm/cpu/armv7/cpu.c
--- u-boot-2011.06/arch/arm/cpu/armv7/cpu.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/armv7/cpu.c	2011-09-19 23:25:08.000000000 +0200
@@ -35,16 +35,17 @@
 #include <command.h>
 #include <asm/system.h>
 #include <asm/cache.h>
-#ifndef CONFIG_L2_OFF
-#include <asm/arch/sys_proto.h>
-#endif
+#include <asm/armv7.h>
 
-static void cache_flush(void);
+void save_boot_params_default(u32 r0, u32 r1, u32 r2, u32 r3)
+{
+}
+
+void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
+	__attribute__((weak, alias("save_boot_params_default")));
 
 int cleanup_before_linux(void)
 {
-	unsigned int i;
-
 	/*
 	 * this function is called just before we call linux
 	 * it prepares the processor for linux
@@ -53,31 +54,29 @@
 	 */
 	disable_interrupts();
 
-	/* turn off I/D-cache */
+	/*
+	 * Turn off I-cache and invalidate it
+	 */
 	icache_disable();
-	dcache_disable();
+	invalidate_icache_all();
 
-	/* invalidate I-cache */
-	cache_flush();
+	/*
+	 * turn off D-cache
+	 * dcache_disable() in turn flushes the d-cache and disables MMU
+	 */
+	dcache_disable();
 
-#ifndef CONFIG_L2_OFF
-	/* turn off L2 cache */
-	l2_cache_disable();
-	/* invalidate L2 cache also */
-	invalidate_dcache(get_device_type());
-#endif
-	i = 0;
-	/* mem barrier to sync up things */
-	asm("mcr p15, 0, %0, c7, c10, 4": :"r"(i));
-
-#ifndef CONFIG_L2_OFF
-	l2_cache_enable();
-#endif
+	/*
+	 * After D-cache is flushed and before it is disabled there may
+	 * be some new valid entries brought into the cache. We are sure
+	 * that these lines are not dirty and will not affect our execution.
+	 * (because unwinding the call-stack and setting a bit in CP15 SCTRL
+	 * is all we did during this. We have not pushed anything on to the
+	 * stack. Neither have we affected any static data)
+	 * So just invalidate the entire d-cache again to avoid coherency
+	 * problems for kernel
+	 */
+	invalidate_dcache_all();
 
 	return 0;
 }
-
-static void cache_flush(void)
-{
-	asm ("mcr p15, 0, %0, c7, c5, 0": :"r" (0));
-}

diff -urN u-boot-2011.06/arch/arm/cpu/armv7/Makefile u-boot-HEAD/arch/arm/cpu/armv7/Makefile
--- u-boot-2011.06/arch/arm/cpu/armv7/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/armv7/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -26,7 +26,12 @@
 LIB	= $(obj)lib$(CPU).o
 
 START	:= start.o
-COBJS	:= cpu.o
+
+ifndef CONFIG_SPL_BUILD
+COBJS	+= cache_v7.o
+COBJS	+= cpu.o
+endif
+
 COBJS  += syslib.o
 
 SRCS	:= $(START:.o=.S) $(COBJS:.o=.c)

diff -urN u-boot-2011.06/arch/arm/cpu/armv7/start.S u-boot-HEAD/arch/arm/cpu/armv7/start.S
--- u-boot-2011.06/arch/arm/cpu/armv7/start.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/armv7/start.S	2011-09-19 23:25:08.000000000 +0200
@@ -42,7 +42,16 @@
 	ldr	pc, _not_used
 	ldr	pc, _irq
 	ldr	pc, _fiq
-
+#ifdef CONFIG_SPL_BUILD
+_undefined_instruction: .word _undefined_instruction
+_software_interrupt:	.word _software_interrupt
+_prefetch_abort:	.word _prefetch_abort
+_data_abort:		.word _data_abort
+_not_used:		.word _not_used
+_irq:			.word _irq
+_fiq:			.word _fiq
+_pad:			.word 0x12345678 /* now 16*4=64 */
+#else
 _undefined_instruction: .word undefined_instruction
 _software_interrupt:	.word software_interrupt
 _prefetch_abort:	.word prefetch_abort
@@ -51,6 +60,8 @@
 _irq:			.word irq
 _fiq:			.word fiq
 _pad:			.word 0x12345678 /* now 16*4=64 */
+#endif	/* CONFIG_SPL_BUILD */
+
 .global _end_vect
 _end_vect:
 
@@ -89,6 +100,10 @@
 _bss_start_ofs:
 	.word __bss_start - _start
 
+.global	_image_copy_end_ofs
+_image_copy_end_ofs:
+	.word 	__image_copy_end - _start
+
 .globl _bss_end_ofs
 _bss_end_ofs:
 	.word __bss_end__ - _start
@@ -119,6 +134,7 @@
  */
 
 reset:
+	bl	save_boot_params
 	/*
 	 * set the cpu to SVC32 mode
 	 */
@@ -182,12 +198,11 @@
 	mov	sp, r4
 
 	adr	r0, _start
-#ifndef CONFIG_PRELOADER
 	cmp	r0, r6
+	moveq	r9, #0		/* no relocation. relocation offset(r9) = 0 */
 	beq	clear_bss		/* skip relocation */
-#endif
 	mov	r1, r6			/* r1 <- scratch for copy_loop */
-	ldr	r3, _bss_start_ofs
+	ldr	r3, _image_copy_end_ofs
 	add	r2, r0, r3		/* r2 <- source end address	    */
 
 copy_loop:
@@ -196,7 +211,7 @@
 	cmp	r0, r2			/* until source end address [r2]    */
 	blo	copy_loop
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * fix .rel.dyn relocations
 	 */
@@ -235,26 +250,48 @@
 	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
 	cmp	r2, r3
 	blo	fixloop
+	b	clear_bss
+_rel_dyn_start_ofs:
+	.word __rel_dyn_start - _start
+_rel_dyn_end_ofs:
+	.word __rel_dyn_end - _start
+_dynsym_start_ofs:
+	.word __dynsym_start - _start
+
+#endif	/* #ifndef CONFIG_SPL_BUILD */
 
 clear_bss:
+#ifdef CONFIG_SPL_BUILD
+	/* No relocation for SPL */
+	ldr	r0, =__bss_start
+	ldr	r1, =__bss_end__
+#else
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
 	mov	r4, r6			/* reloc addr */
 	add	r0, r0, r4
 	add	r1, r1, r4
+#endif
 	mov	r2, #0x00000000		/* clear			    */
 
 clbss_l:str	r2, [r0]		/* clear loop...		    */
 	add	r0, r0, #4
 	cmp	r0, r1
 	bne	clbss_l
-#endif	/* #ifndef CONFIG_PRELOADER */
 
 /*
  * We are done. Do not return, instead branch to second part of board
  * initialization, now running from RAM.
  */
 jump_2_ram:
+/*
+ * If I-cache is enabled invalidate it
+ */
+#ifndef CONFIG_SYS_ICACHE_OFF
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
+#endif
 	ldr	r0, _board_init_r_ofs
 	adr	r1, _start
 	add	lr, r0, r1
@@ -268,13 +305,8 @@
 _board_init_r_ofs:
 	.word board_init_r - _start
 
-_rel_dyn_start_ofs:
-	.word __rel_dyn_start - _start
-_rel_dyn_end_ofs:
-	.word __rel_dyn_end - _start
-_dynsym_start_ofs:
-	.word __dynsym_start - _start
 
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
 /*************************************************************************
  *
  * CPU_init_critical registers
@@ -290,6 +322,9 @@
 	mov	r0, #0			@ set up for MCR
 	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
 	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
+	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
+	mcr     p15, 0, r0, c7, c10, 4	@ DSB
+	mcr     p15, 0, r0, c7, c5, 4	@ ISB
 
 	/*
 	 * disable MMU stuff and caches
@@ -298,7 +333,12 @@
 	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
 	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
 	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
-	orr	r0, r0, #0x00000800	@ set bit 12 (Z---) BTB
+	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
+#ifdef CONFIG_SYS_ICACHE_OFF
+	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
+#else
+	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
+#endif
 	mcr	p15, 0, r0, c1, c0, 0
 
 	/*
@@ -311,6 +351,9 @@
 	bl	lowlevel_init		@ go setup pll,mux,memory
 	mov	lr, ip			@ restore link
 	mov	pc, lr			@ back to my caller
+#endif
+
+#ifndef CONFIG_SPL_BUILD
 /*
  *************************************************************************
  *
@@ -498,4 +541,5 @@
 	bad_save_user_regs
 	bl	do_fiq
 
-#endif
+#endif /* CONFIG_USE_IRQ */
+#endif /* CONFIG_SPL_BUILD */

diff -urN u-boot-2011.06/arch/arm/cpu/armv7/u-boot.lds u-boot-HEAD/arch/arm/cpu/armv7/u-boot.lds
--- u-boot-2011.06/arch/arm/cpu/armv7/u-boot.lds	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/cpu/armv7/u-boot.lds	2011-09-19 23:25:08.000000000 +0200
@@ -55,6 +55,8 @@
 
 	. = ALIGN(4);
 
+	__image_copy_end = .;
+
 	.rel.dyn : {
 		__rel_dyn_start = .;
 		*(.rel*)

diff -urN u-boot-2011.06/arch/arm/include/asm/arch-arm720t/hardware.h u-boot-HEAD/arch/arm/include/asm/arch-arm720t/hardware.h
--- u-boot-2011.06/arch/arm/include/asm/arch-arm720t/hardware.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/include/asm/arch-arm720t/hardware.h	2011-09-19 23:25:08.000000000 +0200
@@ -26,12 +26,6 @@
 
 #if defined(CONFIG_NETARM)
 #include <asm/arch-arm720t/netarm_registers.h>
-#elif defined(CONFIG_IMPA7)
-/* include IMPA7 specific hardware file if there was one */
-#elif defined(CONFIG_EP7312)
-/* include EP7312 specific hardware file if there was one */
-#elif defined(CONFIG_ARMADILLO)
-/* include armadillo specific hardware file if there was one */
 #elif defined(CONFIG_INTEGRATOR) && defined(CONFIG_ARCH_INTEGRATOR)
 /* include IntegratorCP/CM720T specific hardware file if there was one */
 #else

diff -urN u-boot-2011.06/arch/arm/include/asm/armv7.h u-boot-HEAD/arch/arm/include/asm/armv7.h
--- u-boot-2011.06/arch/arm/include/asm/armv7.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/arch/arm/include/asm/armv7.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ * Aneesh V <aneesh@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef ARMV7_H
+#define ARMV7_H
+#include <linux/types.h>
+
+/* Cortex-A9 revisions */
+#define MIDR_CORTEX_A9_R0P1	0x410FC091
+#define MIDR_CORTEX_A9_R1P2	0x411FC092
+#define MIDR_CORTEX_A9_R1P3	0x411FC093
+#define MIDR_CORTEX_A9_R2P10	0x412FC09A
+
+/* CCSIDR */
+#define CCSIDR_LINE_SIZE_OFFSET		0
+#define CCSIDR_LINE_SIZE_MASK		0x7
+#define CCSIDR_ASSOCIATIVITY_OFFSET	3
+#define CCSIDR_ASSOCIATIVITY_MASK	(0x3FF << 3)
+#define CCSIDR_NUM_SETS_OFFSET		13
+#define CCSIDR_NUM_SETS_MASK		(0x7FFF << 13)
+
+/*
+ * Values for InD field in CSSELR
+ * Selects the type of cache
+ */
+#define ARMV7_CSSELR_IND_DATA_UNIFIED	0
+#define ARMV7_CSSELR_IND_INSTRUCTION	1
+
+/* Values for Ctype fields in CLIDR */
+#define ARMV7_CLIDR_CTYPE_NO_CACHE		0
+#define ARMV7_CLIDR_CTYPE_INSTRUCTION_ONLY	1
+#define ARMV7_CLIDR_CTYPE_DATA_ONLY		2
+#define ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA	3
+#define ARMV7_CLIDR_CTYPE_UNIFIED		4
+
+/*
+ * CP15 Barrier instructions
+ * Please note that we have separate barrier instructions in ARMv7
+ * However, we use the CP15 based instructtions because we use
+ * -march=armv5 in U-Boot
+ */
+#define CP15ISB	asm volatile ("mcr     p15, 0, %0, c7, c5, 4" : : "r" (0))
+#define CP15DSB	asm volatile ("mcr     p15, 0, %0, c7, c10, 4" : : "r" (0))
+#define CP15DMB	asm volatile ("mcr     p15, 0, %0, c7, c10, 5" : : "r" (0))
+
+void v7_outer_cache_enable(void);
+void v7_outer_cache_disable(void);
+void v7_outer_cache_flush_all(void);
+void v7_outer_cache_inval_all(void);
+void v7_outer_cache_flush_range(u32 start, u32 end);
+void v7_outer_cache_inval_range(u32 start, u32 end);
+
+#endif
diff -urN u-boot-2011.06/arch/arm/include/asm/bitops.h u-boot-HEAD/arch/arm/include/asm/bitops.h
--- u-boot-2011.06/arch/arm/include/asm/bitops.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/include/asm/bitops.h	2011-09-19 23:25:08.000000000 +0200
@@ -106,6 +106,11 @@
     return ((unsigned char *) addr)[nr >> 3] & (1U << (nr & 7));
 }
 
+static inline int __ilog2(unsigned int x)
+{
+	return generic_fls(x) - 1;
+}
+
 /*
  * ffz = Find First Zero in word. Undefined if no zero exists,
  * so code should check against ~0UL first..
diff -urN u-boot-2011.06/arch/arm/include/asm/global_data.h u-boot-HEAD/arch/arm/include/asm/global_data.h
--- u-boot-2011.06/arch/arm/include/asm/global_data.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/include/asm/global_data.h	2011-09-19 23:25:08.000000000 +0200
@@ -24,7 +24,7 @@
 #ifndef	__ASM_GBL_DATA_H
 #define __ASM_GBL_DATA_H
 /*
- * The following data structure is placed in some memory wich is
+ * The following data structure is placed in some memory which is
  * available very early after boot (like DPRAM on MPC8xx/MPC82xx, or
  * some locked parts of the data cache) to allow for a minimum set of
  * global variables during system initialization (until we have set
@@ -70,7 +70,7 @@
 	unsigned long	irq_sp;		/* irq stack pointer */
 	unsigned long	start_addr_sp;	/* start_addr_stackpointer */
 	unsigned long	reloc_off;
-#if !(defined(CONFIG_SYS_NO_ICACHE) && defined(CONFIG_SYS_NO_DCACHE))
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
 	unsigned long	tlb_addr;
 #endif
 	void		**jt;		/* jump table */
diff -urN u-boot-2011.06/arch/arm/include/asm/gpio.h u-boot-HEAD/arch/arm/include/asm/gpio.h
--- u-boot-2011.06/arch/arm/include/asm/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/arch/arm/include/asm/gpio.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2011, NVIDIA Corp. All rights reserved.
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _GPIO_H_
+#define _GPIO_H_
+
+#include <asm/arch/gpio.h>
+/*
+ * Generic GPIO API
+ */
+
+int gpio_request(int gp, const char *label);
+void gpio_free(int gp);
+void gpio_toggle_value(int gp);
+int gpio_direction_input(int gp);
+int gpio_direction_output(int gp, int value);
+int gpio_get_value(int gp);
+void gpio_set_value(int gp, int value);
+
+#endif	/* _GPIO_H_ */

diff -urN u-boot-2011.06/arch/arm/include/asm/pl310.h u-boot-HEAD/arch/arm/include/asm/pl310.h
--- u-boot-2011.06/arch/arm/include/asm/pl310.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/arch/arm/include/asm/pl310.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ * Aneesh V <aneesh@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _PL310_H_
+#define _PL310_H_
+
+#include <linux/types.h>
+
+/* Register bit fields */
+#define PL310_AUX_CTRL_ASSOCIATIVITY_MASK	(1 << 16)
+
+struct pl310_regs {
+	u32 pl310_cache_id;
+	u32 pl310_cache_type;
+	u32 pad1[62];
+	u32 pl310_ctrl;
+	u32 pl310_aux_ctrl;
+	u32 pl310_tag_latency_ctrl;
+	u32 pl310_data_latency_ctrl;
+	u32 pad2[60];
+	u32 pl310_event_cnt_ctrl;
+	u32 pl310_event_cnt1_cfg;
+	u32 pl310_event_cnt0_cfg;
+	u32 pl310_event_cnt1_val;
+	u32 pl310_event_cnt0_val;
+	u32 pl310_intr_mask;
+	u32 pl310_masked_intr_stat;
+	u32 pl310_raw_intr_stat;
+	u32 pl310_intr_clear;
+	u32 pad3[323];
+	u32 pl310_cache_sync;
+	u32 pad4[15];
+	u32 pl310_inv_line_pa;
+	u32 pad5[2];
+	u32 pl310_inv_way;
+	u32 pad6[12];
+	u32 pl310_clean_line_pa;
+	u32 pad7[1];
+	u32 pl310_clean_line_idx;
+	u32 pl310_clean_way;
+	u32 pad8[12];
+	u32 pl310_clean_inv_line_pa;
+	u32 pad9[1];
+	u32 pl310_clean_inv_line_idx;
+	u32 pl310_clean_inv_way;
+};
+
+void pl310_inval_all(void);
+void pl310_clean_inval_all(void);
+void pl310_inval_range(u32 start, u32 end);
+void pl310_clean_inval_range(u32 start, u32 end);
+
+#endif

diff -urN u-boot-2011.06/arch/arm/include/asm/u-boot-arm.h u-boot-HEAD/arch/arm/include/asm/u-boot-arm.h
--- u-boot-2011.06/arch/arm/include/asm/u-boot-arm.h	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/include/asm/u-boot-arm.h	2011-09-19 23:25:08.000000000 +0200
@@ -57,21 +57,10 @@
 void	setup_serial_tag (struct tag **params);
 void	setup_revision_tag (struct tag **params);
 
-/* ------------------------------------------------------------ */
-/* Here is a list of some prototypes which are incompatible to	*/
-/* the U-Boot implementation					*/
-/* To be fixed!							*/
-/* ------------------------------------------------------------ */
-/* common/cmd_nvedit.c */
-int	setenv		(char *, char *);
-
 /* cpu/.../interrupt.c */
 int	arch_interrupt_init	(void);
 void	reset_timer_masked	(void);
 ulong	get_timer_masked	(void);
 void	udelay_masked		(unsigned long usec);
 
-/* cpu/.../timer.c */
-int	timer_init		(void);
-
 #endif	/* _U_BOOT_ARM_H_ */

diff -urN u-boot-2011.06/arch/arm/include/asm/utils.h u-boot-HEAD/arch/arm/include/asm/utils.h
--- u-boot-2011.06/arch/arm/include/asm/utils.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/arch/arm/include/asm/utils.h	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ * Aneesh V <aneesh@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _UTILS_H_
+#define _UTILS_H_
+
+static inline s32 log_2_n_round_up(u32 n)
+{
+	s32 log2n = -1;
+	u32 temp = n;
+
+	while (temp) {
+		log2n++;
+		temp >>= 1;
+	}
+
+	if (n & (n - 1))
+		return log2n + 1; /* not power of 2 - round up */
+	else
+		return log2n; /* power of 2 */
+}
+
+static inline s32 log_2_n_round_down(u32 n)
+{
+	s32 log2n = -1;
+	u32 temp = n;
+
+	while (temp) {
+		log2n++;
+		temp >>= 1;
+	}
+
+	return log2n;
+}
+
+#endif

diff -urN u-boot-2011.06/arch/arm/lib/board.c u-boot-HEAD/arch/arm/lib/board.c
--- u-boot-2011.06/arch/arm/lib/board.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/lib/board.c	2011-09-19 23:25:08.000000000 +0200
@@ -42,7 +42,6 @@
 #include <command.h>
 #include <malloc.h>
 #include <stdio_dev.h>
-#include <timestamp.h>
 #include <version.h>
 #include <net.h>
 #include <serial.h>
@@ -70,13 +69,6 @@
 extern void dataflash_print_info(void);
 #endif
 
-#ifndef CONFIG_IDENT_STRING
-#define CONFIG_IDENT_STRING ""
-#endif
-
-const char version_string[] =
-	U_BOOT_VERSION" (" U_BOOT_DATE " - " U_BOOT_TIME ")"CONFIG_IDENT_STRING;
-
 #ifdef CONFIG_DRIVER_RTL8019
 extern void rtl8019_get_enetaddr (uchar * addr);
 #endif
@@ -92,26 +84,28 @@
  ************************************************************************
  * May be supplied by boards if desired
  */
-void inline __coloured_LED_init (void) {}
-void coloured_LED_init (void) __attribute__((weak, alias("__coloured_LED_init")));
-void inline __red_LED_on (void) {}
-void red_LED_on (void) __attribute__((weak, alias("__red_LED_on")));
-void inline __red_LED_off(void) {}
-void red_LED_off(void) __attribute__((weak, alias("__red_LED_off")));
-void inline __green_LED_on(void) {}
-void green_LED_on(void) __attribute__((weak, alias("__green_LED_on")));
-void inline __green_LED_off(void) {}
-void green_LED_off(void) __attribute__((weak, alias("__green_LED_off")));
-void inline __yellow_LED_on(void) {}
-void yellow_LED_on(void) __attribute__((weak, alias("__yellow_LED_on")));
-void inline __yellow_LED_off(void) {}
-void yellow_LED_off(void) __attribute__((weak, alias("__yellow_LED_off")));
-void inline __blue_LED_on(void) {}
-void blue_LED_on(void) __attribute__((weak, alias("__blue_LED_on")));
-void inline __blue_LED_off(void) {}
-void blue_LED_off(void) __attribute__((weak, alias("__blue_LED_off")));
+inline void __coloured_LED_init(void) {}
+void coloured_LED_init(void)
+	__attribute__((weak, alias("__coloured_LED_init")));
+inline void __red_led_on(void) {}
+void red_led_on(void) __attribute__((weak, alias("__red_led_on")));
+inline void __red_led_off(void) {}
+void red_led_off(void) __attribute__((weak, alias("__red_led_off")));
+inline void __green_led_on(void) {}
+void green_led_on(void) __attribute__((weak, alias("__green_led_on")));
+inline void __green_led_off(void) {}
+void green_led_off(void) __attribute__((weak, alias("__green_led_off")));
+inline void __yellow_led_on(void) {}
+void yellow_led_on(void) __attribute__((weak, alias("__yellow_led_on")));
+inline void __yellow_led_off(void) {}
+void yellow_led_off(void) __attribute__((weak, alias("__yellow_led_off")));
+inline void __blue_led_on(void) {}
+void blue_led_on(void) __attribute__((weak, alias("__blue_led_on")));
+inline void __blue_led_off(void) {}
+void blue_led_off(void) __attribute__((weak, alias("__blue_led_off")));
 
-/************************************************************************
+/*
+ ************************************************************************
  * Init Utilities							*
  ************************************************************************
  * Some of this code should be moved into the core functions,
@@ -122,30 +116,30 @@
 #if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
 #define CONFIG_BAUDRATE 115200
 #endif
-static int init_baudrate (void)
+static int init_baudrate(void)
 {
 	char tmp[64];	/* long enough for environment variables */
-	int i = getenv_f("baudrate", tmp, sizeof (tmp));
+	int i = getenv_f("baudrate", tmp, sizeof(tmp));
 
 	gd->baudrate = (i > 0)
-			? (int) simple_strtoul (tmp, NULL, 10)
+			? (int) simple_strtoul(tmp, NULL, 10)
 			: CONFIG_BAUDRATE;
 
 	return (0);
 }
 
-static int display_banner (void)
+static int display_banner(void)
 {
-	printf ("\n\n%s\n\n", version_string);
-	debug ("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
+	printf("\n\n%s\n\n", version_string);
+	debug("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
 	       _TEXT_BASE,
-	       _bss_start_ofs+_TEXT_BASE, _bss_end_ofs+_TEXT_BASE);
+	       _bss_start_ofs + _TEXT_BASE, _bss_end_ofs + _TEXT_BASE);
 #ifdef CONFIG_MODEM_SUPPORT
-	debug ("Modem Support enabled\n");
+	debug("Modem Support enabled\n");
 #endif
 #ifdef CONFIG_USE_IRQ
-	debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
-	debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
+	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
+	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
 #endif
 
 	return (0);
@@ -158,23 +152,23 @@
  * gives a simple yet clear indication which part of the
  * initialization if failing.
  */
-static int display_dram_config (void)
+static int display_dram_config(void)
 {
 	int i;
 
 #ifdef DEBUG
-	puts ("RAM Configuration:\n");
+	puts("RAM Configuration:\n");
 
-	for(i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
-		printf ("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);
-		print_size (gd->bd->bi_dram[i].size, "\n");
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		printf("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);
+		print_size(gd->bd->bi_dram[i].size, "\n");
 	}
 #else
 	ulong size = 0;
 
-	for (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
 		size += gd->bd->bi_dram[i].size;
-	}
+
 	puts("DRAM:  ");
 	print_size(size, "\n");
 #endif
@@ -183,11 +177,11 @@
 }
 
 #if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
-static int init_func_i2c (void)
+static int init_func_i2c(void)
 {
-	puts ("I2C:   ");
-	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
-	puts ("ready\n");
+	puts("I2C:   ");
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	puts("ready\n");
 	return (0);
 }
 #endif
@@ -226,7 +220,7 @@
  */
 typedef int (init_fnc_t) (void);
 
-int print_cpuinfo (void);
+int print_cpuinfo(void);
 
 void __dram_init_banksize(void)
 {
@@ -265,7 +259,7 @@
 	NULL,
 };
 
-void board_init_f (ulong bootflag)
+void board_init_f(ulong bootflag)
 {
 	bd_t *bd;
 	init_fnc_t **init_fnc_ptr;
@@ -277,7 +271,7 @@
 	/* compiler optimization barrier needed for GCC >= 3.4 */
 	__asm__ __volatile__("": : :"memory");
 
-	memset ((void*)gd, 0, sizeof (gd_t));
+	memset((void *)gd, 0, sizeof(gd_t));
 
 	gd->mon_len = _bss_end_ofs;
 
@@ -287,11 +281,11 @@
 		}
 	}
 
-	debug ("monitor len: %08lX\n", gd->mon_len);
+	debug("monitor len: %08lX\n", gd->mon_len);
 	/*
 	 * Ram is setup, size stored in gd !!
 	 */
-	debug ("ramsize: %08lX\n", gd->ram_size);
+	debug("ramsize: %08lX\n", gd->ram_size);
 #if defined(CONFIG_SYS_MEM_TOP_HIDE)
 	/*
 	 * Subtract specified amount of memory to hide so that it won't
@@ -312,7 +306,8 @@
 #ifndef CONFIG_ALT_LB_ADDR
 	/* reserve kernel log buffer */
 	addr -= (LOGBUFF_RESERVE);
-	debug ("Reserving %dk for kernel logbuffer at %08lx\n", LOGBUFF_LEN, addr);
+	debug("Reserving %dk for kernel logbuffer at %08lx\n", LOGBUFF_LEN,
+		addr);
 #endif
 #endif
 
@@ -320,13 +315,14 @@
 	/*
 	 * reserve protected RAM
 	 */
-	i = getenv_r ("pram", (char *)tmp, sizeof (tmp));
-	reg = (i > 0) ? simple_strtoul ((const char *)tmp, NULL, 10) : CONFIG_PRAM;
+	i = getenv_r("pram", (char *)tmp, sizeof(tmp));
+	reg = (i > 0) ? simple_strtoul((const char *)tmp, NULL, 10) :
+		CONFIG_PRAM;
 	addr -= (reg << 10);		/* size is in kB */
-	debug ("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
+	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
 #endif /* CONFIG_PRAM */
 
-#if !(defined(CONFIG_SYS_NO_ICACHE) && defined(CONFIG_SYS_NO_DCACHE))
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
 	/* reserve TLB table */
 	addr -= (4096 * 4);
 
@@ -334,19 +330,19 @@
 	addr &= ~(0x10000 - 1);
 
 	gd->tlb_addr = addr;
-	debug ("TLB table at: %08lx\n", addr);
+	debug("TLB table at: %08lx\n", addr);
 #endif
 
 	/* round down to next 4 kB limit */
 	addr &= ~(4096 - 1);
-	debug ("Top of RAM usable for U-Boot at: %08lx\n", addr);
+	debug("Top of RAM usable for U-Boot at: %08lx\n", addr);
 
 #ifdef CONFIG_LCD
 #ifdef CONFIG_FB_ADDR
 	gd->fb_base = CONFIG_FB_ADDR;
 #else
 	/* reserve memory for LCD display (always full pages) */
-	addr = lcd_setmem (addr);
+	addr = lcd_setmem(addr);
 	gd->fb_base = addr;
 #endif /* CONFIG_FB_ADDR */
 #endif /* CONFIG_LCD */
@@ -358,14 +354,14 @@
 	addr -= gd->mon_len;
 	addr &= ~(4096 - 1);
 
-	debug ("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10, addr);
+	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10, addr);
 
-#ifndef CONFIG_PRELOADER
+#ifndef CONFIG_SPL_BUILD
 	/*
 	 * reserve memory for malloc() arena
 	 */
 	addr_sp = addr - TOTAL_MALLOC_LEN;
-	debug ("Reserving %dk for malloc() at: %08lx\n",
+	debug("Reserving %dk for malloc() at: %08lx\n",
 			TOTAL_MALLOC_LEN >> 10, addr_sp);
 	/*
 	 * (permanently) allocate a Board Info struct
@@ -374,18 +370,23 @@
 	addr_sp -= sizeof (bd_t);
 	bd = (bd_t *) addr_sp;
 	gd->bd = bd;
-	debug ("Reserving %zu Bytes for Board Info at: %08lx\n",
+	debug("Reserving %zu Bytes for Board Info at: %08lx\n",
 			sizeof (bd_t), addr_sp);
+
+#ifdef CONFIG_MACH_TYPE
+	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
+#endif
+
 	addr_sp -= sizeof (gd_t);
 	id = (gd_t *) addr_sp;
-	debug ("Reserving %zu Bytes for Global Data at: %08lx\n",
+	debug("Reserving %zu Bytes for Global Data at: %08lx\n",
 			sizeof (gd_t), addr_sp);
 
 	/* setup stackpointer for exeptions */
 	gd->irq_sp = addr_sp;
 #ifdef CONFIG_USE_IRQ
 	addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
-	debug ("Reserving %zu Bytes for IRQ stack at: %08lx\n",
+	debug("Reserving %zu Bytes for IRQ stack at: %08lx\n",
 		CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);
 #endif
 	/* leave 3 words for abort-stack    */
@@ -398,11 +399,11 @@
 	gd->irq_sp = addr_sp;
 #endif
 
-	debug ("New Stack Pointer is: %08lx\n", addr_sp);
+	debug("New Stack Pointer is: %08lx\n", addr_sp);
 
 #ifdef CONFIG_POST
 	post_bootmode_init();
-	post_run (NULL, POST_ROM | post_bootmode_get(0));
+	post_run(NULL, POST_ROM | post_bootmode_get(0));
 #endif
 
 	gd->bd->bi_baudrate = gd->baudrate;
@@ -413,10 +414,10 @@
 	gd->relocaddr = addr;
 	gd->start_addr_sp = addr_sp;
 	gd->reloc_off = addr - _TEXT_BASE;
-	debug ("relocation Offset is: %08lx\n", gd->reloc_off);
-	memcpy (id, (void *)gd, sizeof (gd_t));
+	debug("relocation Offset is: %08lx\n", gd->reloc_off);
+	memcpy(id, (void *)gd, sizeof(gd_t));
 
-	relocate_code (addr_sp, id, addr);
+	relocate_code(addr_sp, id, addr);
 
 	/* NOTREACHED - relocate_code() does not return */
 }
@@ -425,7 +426,8 @@
 static char *failed = "*** failed ***\n";
 #endif
 
-/************************************************************************
+/*
+ ************************************************************************
  *
  * This is the next part if the initialization sequence: we are now
  * running from RAM and have a "normal" C environment, i. e. global
@@ -435,7 +437,7 @@
  ************************************************************************
  */
 
-void board_init_r (gd_t *id, ulong dest_addr)
+void board_init_r(gd_t *id, ulong dest_addr)
 {
 	char *s;
 	bd_t *bd;
@@ -450,20 +452,24 @@
 	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
 
 	monitor_flash_len = _end_ofs;
-	debug ("monitor flash len: %08lX\n", monitor_flash_len);
+
+	/* Enable caches */
+	enable_caches();
+
+	debug("monitor flash len: %08lX\n", monitor_flash_len);
 	board_init();	/* Setup chipselects */
 
 #ifdef CONFIG_SERIAL_MULTI
 	serial_initialize();
 #endif
 
-	debug ("Now running in RAM - U-Boot at: %08lx\n", dest_addr);
+	debug("Now running in RAM - U-Boot at: %08lx\n", dest_addr);
 
 #ifdef CONFIG_LOGBUFFER
-	logbuff_init_ptrs ();
+	logbuff_init_ptrs();
 #endif
 #ifdef CONFIG_POST
-	post_output_backlog ();
+	post_output_backlog();
 #endif
 
 	/* The Malloc area is immediately below the monitor copy in DRAM */
@@ -471,34 +477,35 @@
 	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
 
 #if !defined(CONFIG_SYS_NO_FLASH)
-	puts ("Flash: ");
+	puts("Flash: ");
 
-	if ((flash_size = flash_init ()) > 0) {
+	flash_size = flash_init();
+	if (flash_size > 0) {
 # ifdef CONFIG_SYS_FLASH_CHECKSUM
-		print_size (flash_size, "");
+		print_size(flash_size, "");
 		/*
 		 * Compute and print flash CRC if flashchecksum is set to 'y'
 		 *
 		 * NOTE: Maybe we should add some WATCHDOG_RESET()? XXX
 		 */
-		s = getenv ("flashchecksum");
+		s = getenv("flashchecksum");
 		if (s && (*s == 'y')) {
-			printf ("  CRC: %08X",
-				crc32 (0, (const unsigned char *) CONFIG_SYS_FLASH_BASE, flash_size)
-			);
+			printf("  CRC: %08X", crc32(0,
+				(const unsigned char *) CONFIG_SYS_FLASH_BASE,
+				flash_size));
 		}
-		putc ('\n');
+		putc('\n');
 # else	/* !CONFIG_SYS_FLASH_CHECKSUM */
-		print_size (flash_size, "\n");
+		print_size(flash_size, "\n");
 # endif /* CONFIG_SYS_FLASH_CHECKSUM */
 	} else {
-		puts (failed);
-		hang ();
+		puts(failed);
+		hang();
 	}
 #endif
 
 #if defined(CONFIG_CMD_NAND)
-	puts ("NAND:  ");
+	puts("NAND:  ");
 	nand_init();		/* go init the NAND */
 #endif
 
@@ -517,44 +524,44 @@
 #endif
 
 	/* initialize environment */
-	env_relocate ();
+	env_relocate();
 
 #if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
 	arm_pci_init();
 #endif
 
 	/* IP Address */
-	gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
+	gd->bd->bi_ip_addr = getenv_IPaddr("ipaddr");
 
-	stdio_init ();	/* get the devices list going. */
+	stdio_init();	/* get the devices list going. */
 
-	jumptable_init ();
+	jumptable_init();
 
 #if defined(CONFIG_API)
 	/* Initialize API */
-	api_init ();
+	api_init();
 #endif
 
-	console_init_r ();	/* fully init console as a device */
+	console_init_r();	/* fully init console as a device */
 
 #if defined(CONFIG_ARCH_MISC_INIT)
 	/* miscellaneous arch dependent initialisations */
-	arch_misc_init ();
+	arch_misc_init();
 #endif
 #if defined(CONFIG_MISC_INIT_R)
 	/* miscellaneous platform dependent initialisations */
-	misc_init_r ();
+	misc_init_r();
 #endif
 
 	 /* set up exceptions */
-	interrupt_init ();
+	interrupt_init();
 	/* enable exceptions */
-	enable_interrupts ();
+	enable_interrupts();
 
 	/* Perform network card initialisation if necessary */
 #if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96)
 	/* XXX: this needs to be moved to board init */
-	if (getenv ("ethaddr")) {
+	if (getenv("ethaddr")) {
 		uchar enetaddr[6];
 		eth_getenv_enetaddr("ethaddr", enetaddr);
 		smc_set_mac_addr(enetaddr);
@@ -562,17 +569,17 @@
 #endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */
 
 	/* Initialize from environment */
-	if ((s = getenv ("loadaddr")) != NULL) {
-		load_addr = simple_strtoul (s, NULL, 16);
-	}
+	s = getenv("loadaddr");
+	if (s != NULL)
+		load_addr = simple_strtoul(s, NULL, 16);
 #if defined(CONFIG_CMD_NET)
-	if ((s = getenv ("bootfile")) != NULL) {
-		copy_filename (BootFile, s, sizeof (BootFile));
-	}
+	s = getenv("bootfile");
+	if (s != NULL)
+		copy_filename(BootFile, s, sizeof(BootFile));
 #endif
 
 #ifdef BOARD_LATE_INIT
-	board_late_init ();
+	board_late_init();
 #endif
 
 #ifdef CONFIG_BITBANGMII
@@ -580,17 +587,17 @@
 #endif
 #if defined(CONFIG_CMD_NET)
 #if defined(CONFIG_NET_MULTI)
-	puts ("Net:   ");
+	puts("Net:   ");
 #endif
 	eth_initialize(gd->bd);
 #if defined(CONFIG_RESET_PHY_R)
-	debug ("Reset Ethernet PHY\n");
+	debug("Reset Ethernet PHY\n");
 	reset_phy();
 #endif
 #endif
 
 #ifdef CONFIG_POST
-	post_run (NULL, POST_RAM | post_bootmode_get(0));
+	post_run(NULL, POST_RAM | post_bootmode_get(0));
 #endif
 
 #if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
@@ -604,35 +611,35 @@
 #ifdef CONFIG_PRAM
 		char *s;
 
-		if ((s = getenv ("pram")) != NULL) {
-			pram = simple_strtoul (s, NULL, 10);
-		} else {
+		s = getenv("pram");
+		if (s != NULL)
+			pram = simple_strtoul(s, NULL, 10);
+		else
 			pram = CONFIG_PRAM;
-		}
 #else
-		pram=0;
+		pram = 0;
 #endif
 #ifdef CONFIG_LOGBUFFER
 #ifndef CONFIG_ALT_LB_ADDR
 		/* Also take the logbuffer into account (pram is in kB) */
-		pram += (LOGBUFF_LEN+LOGBUFF_OVERHEAD)/1024;
+		pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / 1024;
 #endif
 #endif
-		sprintf ((char *)memsz, "%ldk", (bd->bi_memsize / 1024) - pram);
-		setenv ("mem", (char *)memsz);
+		sprintf((char *)memsz, "%ldk", (gd->ram_size / 1024) - pram);
+		setenv("mem", (char *)memsz);
 	}
 #endif
 
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
-		main_loop ();
+		main_loop();
 	}
 
 	/* NOTREACHED - no way out of command loop except booting */
 }
 
-void hang (void)
+void hang(void)
 {
-	puts ("### ERROR ### Please RESET the board ###\n");
+	puts("### ERROR ### Please RESET the board ###\n");
 	for (;;);
 }

diff -urN u-boot-2011.06/arch/arm/lib/cache.c u-boot-HEAD/arch/arm/lib/cache.c
--- u-boot-2011.06/arch/arm/lib/cache.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/lib/cache.c	2011-09-19 23:25:08.000000000 +0200
@@ -25,7 +25,7 @@
 
 #include <common.h>
 
-void  flush_cache (unsigned long dummy1, unsigned long dummy2)
+void  __flush_cache(unsigned long start, unsigned long size)
 {
 #if defined(CONFIG_OMAP2420) || defined(CONFIG_ARM1136)
 	void arm1136_cache_flush(void);
@@ -38,10 +38,30 @@
 	/* disable write buffer as well (page 2-22) */
 	asm("mcr p15, 0, %0, c7, c10, 4" : : "r" (0));
 #endif
-#ifdef CONFIG_OMAP34XX
-	void v7_flush_cache_all(void);
-
-	v7_flush_cache_all();
-#endif
 	return;
 }
+void  flush_cache(unsigned long start, unsigned long size)
+	__attribute__((weak, alias("__flush_cache")));
+
+/*
+ * Default implementation:
+ * do a range flush for the entire range
+ */
+void	__flush_dcache_all(void)
+{
+	flush_cache(0, ~0);
+}
+void	flush_dcache_all(void)
+	__attribute__((weak, alias("__flush_dcache_all")));
+
+
+/*
+ * Default implementation of enable_caches()
+ * Real implementation should be in platform code
+ */
+void __enable_caches(void)
+{
+	puts("WARNING: Caches not enabled\n");
+}
+void enable_caches(void)
+	__attribute__((weak, alias("__enable_caches")));

diff -urN u-boot-2011.06/arch/arm/lib/cache-cp15.c u-boot-HEAD/arch/arm/lib/cache-cp15.c
--- u-boot-2011.06/arch/arm/lib/cache-cp15.c	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/lib/cache-cp15.c	2011-09-19 23:25:08.000000000 +0200
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <asm/system.h>
 
-#if !(defined(CONFIG_SYS_NO_ICACHE) && defined(CONFIG_SYS_NO_DCACHE))
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
 
 #if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
 #define CACHE_SETUP	0x1a
@@ -34,6 +34,12 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+void __arm_init_before_mmu(void)
+{
+}
+void arm_init_before_mmu(void)
+	__attribute__((weak, alias("__arm_init_before_mmu")));
+
 static void cp_delay (void)
 {
 	volatile int i;
@@ -65,6 +71,7 @@
 	int i;
 	u32 reg;
 
+	arm_init_before_mmu();
 	/* Set up an identity-mapping for all 4GB, rw for everyone */
 	for (i = 0; i < 4096; i++)
 		page_table[i] = i << 20 | (3 << 10) | 0x12;
@@ -85,13 +92,18 @@
 	set_cr(reg | CR_M);
 }
 
+static int mmu_enabled(void)
+{
+	return get_cr() & CR_M;
+}
+
 /* cache_bit must be either CR_I or CR_C */
 static void cache_enable(uint32_t cache_bit)
 {
 	uint32_t reg;
 
 	/* The data cache is not active unless the mmu is enabled too */
-	if (cache_bit == CR_C)
+	if ((cache_bit == CR_C) && !mmu_enabled())
 		mmu_setup();
 	reg = get_cr();	/* get control reg. */
 	cp_delay();
@@ -110,7 +122,7 @@
 			return;
 		/* if disabling data cache, disable mmu too */
 		cache_bit |= CR_M;
-		flush_cache(0, ~0);
+		flush_dcache_all();
 	}
 	reg = get_cr();
 	cp_delay();
@@ -118,7 +130,7 @@
 }
 #endif
 
-#ifdef CONFIG_SYS_NO_ICACHE
+#ifdef CONFIG_SYS_ICACHE_OFF
 void icache_enable (void)
 {
 	return;
@@ -150,7 +162,7 @@
 }
 #endif
 
-#ifdef CONFIG_SYS_NO_DCACHE
+#ifdef CONFIG_SYS_DCACHE_OFF
 void dcache_enable (void)
 {
 	return;

diff -urN u-boot-2011.06/arch/arm/lib/cache-pl310.c u-boot-HEAD/arch/arm/lib/cache-pl310.c
--- u-boot-2011.06/arch/arm/lib/cache-pl310.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-HEAD/arch/arm/lib/cache-pl310.c	2011-09-19 23:25:08.000000000 +0200
@@ -0,0 +1,118 @@
+/*
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ * Aneesh V <aneesh@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <linux/types.h>
+#include <asm/io.h>
+#include <asm/armv7.h>
+#include <asm/pl310.h>
+#include <config.h>
+#include <common.h>
+
+struct pl310_regs *const pl310 = (struct pl310_regs *)CONFIG_SYS_PL310_BASE;
+
+static void pl310_cache_sync(void)
+{
+	writel(0, &pl310->pl310_cache_sync);
+}
+
+static void pl310_background_op_all_ways(u32 *op_reg)
+{
+	u32 assoc_16, associativity, way_mask;
+
+	assoc_16 = readl(&pl310->pl310_aux_ctrl) &
+			PL310_AUX_CTRL_ASSOCIATIVITY_MASK;
+	if (assoc_16)
+		associativity = 16;
+	else
+		associativity = 8;
+
+	way_mask = (1 << associativity) - 1;
+	/* Invalidate all ways */
+	writel(way_mask, op_reg);
+	/* Wait for all ways to be invalidated */
+	while (readl(op_reg) && way_mask)
+		;
+	pl310_cache_sync();
+}
+
+void v7_outer_cache_inval_all(void)
+{
+	pl310_background_op_all_ways(&pl310->pl310_inv_way);
+}
+
+void v7_outer_cache_flush_all(void)
+{
+	pl310_background_op_all_ways(&pl310->pl310_clean_inv_way);
+}
+
+/* Flush(clean invalidate) memory from start to stop-1 */
+void v7_outer_cache_flush_range(u32 start, u32 stop)
+{
+	/* PL310 currently supports only 32 bytes cache line */
+	u32 pa, line_size = 32;
+
+	/*
+	 * Align to the beginning of cache-line - this ensures that
+	 * the first 5 bits are 0 as required by PL310 TRM
+	 */
+	start &= ~(line_size - 1);
+
+	for (pa = start; pa < stop; pa = pa + line_size)
+		writel(pa, &pl310->pl310_clean_inv_line_pa);
+
+	pl310_cache_sync();
+}
+
+/* invalidate memory from start to stop-1 */
+void v7_outer_cache_inval_range(u32 start, u32 stop)
+{
+	/* PL310 currently supports only 32 bytes cache line */
+	u32 pa, line_size = 32;
+
+	/*
+	 * If start address is not aligned to cache-line do not
+	 * invalidate the first cache-line
+	 */
+	if (start & (line_size - 1)) {
+		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
+			__func__, start);
+		/* move to next cache line */
+		start = (start + line_size - 1) & ~(line_size - 1);
+	}
+
+	/*
+	 * If stop address is not aligned to cache-line do not
+	 * invalidate the last cache-line
+	 */
+	if (stop & (line_size - 1)) {
+		printf("ERROR: %s - stop address is not aligned - 0x%08x\n",
+			__func__, stop);
+		/* align to the beginning of this cache line */
+		stop &= ~(line_size - 1);
+	}
+
+	for (pa = start; pa < stop; pa = pa + line_size)
+		writel(pa, &pl310->pl310_inv_line_pa);
+
+	pl310_cache_sync();
+}

diff -urN u-boot-2011.06/arch/arm/lib/Makefile u-boot-HEAD/arch/arm/lib/Makefile
--- u-boot-2011.06/arch/arm/lib/Makefile	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/lib/Makefile	2011-09-19 23:25:08.000000000 +0200
@@ -26,6 +26,7 @@
 LIB	= $(obj)lib$(ARCH).o
 LIBGCC	= $(obj)libgcc.o
 
+ifndef CONFIG_SPL_BUILD
 GLSOBJS	+= _ashldi3.o
 GLSOBJS	+= _ashrdi3.o
 GLSOBJS	+= _divsi3.o
@@ -39,13 +40,13 @@
 COBJS-y	+= board.o
 COBJS-y	+= bootm.o
 COBJS-y	+= cache.o
-ifndef CONFIG_SYS_NO_CP15_CACHE
 COBJS-y	+= cache-cp15.o
-endif
+COBJS-$(CONFIG_SYS_L2_PL310) += cache-pl310.o
 COBJS-y	+= interrupts.o
 COBJS-y	+= reset.o
 SOBJS-$(CONFIG_USE_ARCH_MEMSET) += memset.o
 SOBJS-$(CONFIG_USE_ARCH_MEMCPY) += memcpy.o
+endif
 
 SRCS	:= $(GLSOBJS:.o=.S) $(GLCOBJS:.o=.c) \
 	   $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)

diff -urN u-boot-2011.06/arch/arm/lib/memcpy.S u-boot-HEAD/arch/arm/lib/memcpy.S
--- u-boot-2011.06/arch/arm/lib/memcpy.S	2011-06-27 22:22:42.000000000 +0200
+++ u-boot-HEAD/arch/arm/lib/memcpy.S	2011-09-19 23:25:08.000000000 +0200
@@ -60,6 +60,9 @@
 .globl memcpy
 memcpy:
 
+		cmp	r0, r1
+		moveq	pc, lr
+
 		enter	r4, lr
 
 		subs	r2, r2, #4
